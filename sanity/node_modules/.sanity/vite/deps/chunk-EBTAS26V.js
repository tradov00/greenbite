import {
  CheckmarkIcon,
  ChevronDownIcon,
  ChevronRightIcon,
  CloseIcon,
  RemoveIcon,
  SpinnerIcon,
  ToggleArrowRightIcon
} from "./chunk-QW3IFFEG.js";
import {
  require_react_dom
} from "./chunk-GAWKALSO.js";
import {
  require_dist
} from "./chunk-RIGTFENR.js";
import {
  require_jsx_runtime
} from "./chunk-5IL6NTPJ.js";
import {
  require_react
} from "./chunk-MEIUKHS4.js";
import {
  __commonJS,
  __esm,
  __export,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-5IKWDFCZ.js";

// ../node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize(fn) {
  var cache3 = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache3[arg] === void 0) cache3[arg] = fn(arg);
    return cache3[arg];
  };
}
var init_emotion_memoize_esm = __esm({
  "../node_modules/@emotion/memoize/dist/emotion-memoize.esm.js"() {
  }
});

// ../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var emotion_is_prop_valid_esm_exports = {};
__export(emotion_is_prop_valid_esm_exports, {
  default: () => isPropValid
});
var reactPropsRegex, isPropValid;
var init_emotion_is_prop_valid_esm = __esm({
  "../node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js"() {
    init_emotion_memoize_esm();
    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    isPropValid = memoize(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
  }
});

// ../node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "../node_modules/shallowequal/index.js"(exports, module) {
    module.exports = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key2 = keysA[idx];
        if (!bHasOwnProperty(key2)) {
          return false;
        }
        var valueA = objA[key2];
        var valueB = objB[key2];
        ret = compare ? compare.call(compareContext, valueA, valueB, key2) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "../node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    (function() {
      function typeOf(object) {
        if ("object" === typeof object && null !== object) {
          var $$typeof = object.$$typeof;
          switch ($$typeof) {
            case REACT_ELEMENT_TYPE:
              switch (object = object.type, object) {
                case REACT_FRAGMENT_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_SUSPENSE_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_VIEW_TRANSITION_TYPE:
                  return object;
                default:
                  switch (object = object && object.$$typeof, object) {
                    case REACT_CONTEXT_TYPE:
                    case REACT_FORWARD_REF_TYPE:
                    case REACT_LAZY_TYPE:
                    case REACT_MEMO_TYPE:
                      return object;
                    case REACT_CONSUMER_TYPE:
                      return object;
                    default:
                      return $$typeof;
                  }
              }
            case REACT_PORTAL_TYPE:
              return $$typeof;
          }
        }
      }
      var REACT_ELEMENT_TYPE = Symbol.for("react.transitional.element"), REACT_PORTAL_TYPE = Symbol.for("react.portal"), REACT_FRAGMENT_TYPE = Symbol.for("react.fragment"), REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode"), REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      Symbol.for("react.provider");
      var REACT_CONSUMER_TYPE = Symbol.for("react.consumer"), REACT_CONTEXT_TYPE = Symbol.for("react.context"), REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref"), REACT_SUSPENSE_TYPE = Symbol.for("react.suspense"), REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list"), REACT_MEMO_TYPE = Symbol.for("react.memo"), REACT_LAZY_TYPE = Symbol.for("react.lazy"), REACT_VIEW_TRANSITION_TYPE = Symbol.for("react.view_transition"), REACT_CLIENT_REFERENCE = Symbol.for("react.client.reference");
      exports.ContextConsumer = REACT_CONSUMER_TYPE;
      exports.ContextProvider = REACT_CONTEXT_TYPE;
      exports.Element = REACT_ELEMENT_TYPE;
      exports.ForwardRef = REACT_FORWARD_REF_TYPE;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Lazy = REACT_LAZY_TYPE;
      exports.Memo = REACT_MEMO_TYPE;
      exports.Portal = REACT_PORTAL_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.SuspenseList = REACT_SUSPENSE_LIST_TYPE;
      exports.isContextConsumer = function(object) {
        return typeOf(object) === REACT_CONSUMER_TYPE;
      };
      exports.isContextProvider = function(object) {
        return typeOf(object) === REACT_CONTEXT_TYPE;
      };
      exports.isElement = function(object) {
        return "object" === typeof object && null !== object && object.$$typeof === REACT_ELEMENT_TYPE;
      };
      exports.isForwardRef = function(object) {
        return typeOf(object) === REACT_FORWARD_REF_TYPE;
      };
      exports.isFragment = function(object) {
        return typeOf(object) === REACT_FRAGMENT_TYPE;
      };
      exports.isLazy = function(object) {
        return typeOf(object) === REACT_LAZY_TYPE;
      };
      exports.isMemo = function(object) {
        return typeOf(object) === REACT_MEMO_TYPE;
      };
      exports.isPortal = function(object) {
        return typeOf(object) === REACT_PORTAL_TYPE;
      };
      exports.isProfiler = function(object) {
        return typeOf(object) === REACT_PROFILER_TYPE;
      };
      exports.isStrictMode = function(object) {
        return typeOf(object) === REACT_STRICT_MODE_TYPE;
      };
      exports.isSuspense = function(object) {
        return typeOf(object) === REACT_SUSPENSE_TYPE;
      };
      exports.isSuspenseList = function(object) {
        return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
      };
      exports.isValidElementType = function(type) {
        return "string" === typeof type || "function" === typeof type || type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || "object" === typeof type && null !== type && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_CONSUMER_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_CLIENT_REFERENCE || void 0 !== type.getModuleId) ? true : false;
      };
      exports.typeOf = typeOf;
    })();
  }
});

// ../node_modules/react-is/index.js
var require_react_is = __commonJS({
  "../node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// ../node_modules/@sanity/color/dist/index.js
var COLOR_HUES = [
  "gray",
  "blue",
  "purple",
  "magenta",
  "red",
  "orange",
  "yellow",
  "green",
  "cyan"
];
var COLOR_TINTS = [
  "50",
  "100",
  "200",
  "300",
  "400",
  "500",
  "600",
  "700",
  "800",
  "900",
  "950"
];
var black = {
  title: "Black",
  hex: "#0d0e12"
};
var white = {
  title: "White",
  hex: "#ffffff"
};
var gray = {
  50: {
    title: "Gray 50",
    hex: "#f6f6f8"
  },
  100: {
    title: "Gray 100",
    hex: "#eeeef1"
  },
  200: {
    title: "Gray 200",
    hex: "#e3e4e8"
  },
  300: {
    title: "Gray 300",
    hex: "#bbbdc9"
  },
  400: {
    title: "Gray 400",
    hex: "#9499ad"
  },
  500: {
    title: "Gray 500",
    hex: "#727892"
  },
  600: {
    title: "Gray 600",
    hex: "#515870"
  },
  700: {
    title: "Gray 700",
    hex: "#383d51"
  },
  800: {
    title: "Gray 800",
    hex: "#252837"
  },
  900: {
    title: "Gray 900",
    hex: "#1b1d27"
  },
  950: {
    title: "Gray 950",
    hex: "#13141b"
  }
};
var blue = {
  50: {
    title: "Blue 50",
    hex: "#f5f8ff"
  },
  100: {
    title: "Blue 100",
    hex: "#e5edff"
  },
  200: {
    title: "Blue 200",
    hex: "#dbe5ff"
  },
  300: {
    title: "Blue 300",
    hex: "#a8bfff"
  },
  400: {
    title: "Blue 400",
    hex: "#7595ff"
  },
  500: {
    title: "Blue 500",
    hex: "#556bfc"
  },
  600: {
    title: "Blue 600",
    hex: "#4043e7"
  },
  700: {
    title: "Blue 700",
    hex: "#2927aa"
  },
  800: {
    title: "Blue 800",
    hex: "#192457"
  },
  900: {
    title: "Blue 900",
    hex: "#161a41"
  },
  950: {
    title: "Blue 950",
    hex: "#101228"
  }
};
var purple = {
  50: {
    title: "Purple 50",
    hex: "#f8f5ff"
  },
  100: {
    title: "Purple 100",
    hex: "#f1ebff"
  },
  200: {
    title: "Purple 200",
    hex: "#ece1fe"
  },
  300: {
    title: "Purple 300",
    hex: "#ccb1fc"
  },
  400: {
    title: "Purple 400",
    hex: "#b087f7"
  },
  500: {
    title: "Purple 500",
    hex: "#8f57ef"
  },
  600: {
    title: "Purple 600",
    hex: "#721fe5"
  },
  700: {
    title: "Purple 700",
    hex: "#4c1a9e"
  },
  800: {
    title: "Purple 800",
    hex: "#2f1862"
  },
  900: {
    title: "Purple 900",
    hex: "#23173f"
  },
  950: {
    title: "Purple 950",
    hex: "#181128"
  }
};
var magenta = {
  50: {
    title: "Magenta 50",
    hex: "#fef6f9"
  },
  100: {
    title: "Magenta 100",
    hex: "#fde8ef"
  },
  200: {
    title: "Magenta 200",
    hex: "#fcdee9"
  },
  300: {
    title: "Magenta 300",
    hex: "#f7abc5"
  },
  400: {
    title: "Magenta 400",
    hex: "#f0709b"
  },
  500: {
    title: "Magenta 500",
    hex: "#e72767"
  },
  600: {
    title: "Magenta 600",
    hex: "#b11651"
  },
  700: {
    title: "Magenta 700",
    hex: "#7c1342"
  },
  800: {
    title: "Magenta 800",
    hex: "#4b1130"
  },
  900: {
    title: "Magenta 900",
    hex: "#341325"
  },
  950: {
    title: "Magenta 950",
    hex: "#1f0f14"
  }
};
var red = {
  50: {
    title: "Red 50",
    hex: "#fff6f5"
  },
  100: {
    title: "Red 100",
    hex: "#ffe7e5"
  },
  200: {
    title: "Red 200",
    hex: "#ffdedc"
  },
  300: {
    title: "Red 300",
    hex: "#fdada5"
  },
  400: {
    title: "Red 400",
    hex: "#f77769"
  },
  500: {
    title: "Red 500",
    hex: "#ef4434"
  },
  600: {
    title: "Red 600",
    hex: "#cc2819"
  },
  700: {
    title: "Red 700",
    hex: "#8b2018"
  },
  800: {
    title: "Red 800",
    hex: "#4d1714"
  },
  900: {
    title: "Red 900",
    hex: "#321615"
  },
  950: {
    title: "Red 950",
    hex: "#1e1011"
  }
};
var orange = {
  50: {
    title: "Orange 50",
    hex: "#fff7f0"
  },
  100: {
    title: "Orange 100",
    hex: "#ffeadb"
  },
  200: {
    title: "Orange 200",
    hex: "#ffddc7"
  },
  300: {
    title: "Orange 300",
    hex: "#ffb685"
  },
  400: {
    title: "Orange 400",
    hex: "#ff8e42"
  },
  500: {
    title: "Orange 500",
    hex: "#fa6400"
  },
  600: {
    title: "Orange 600",
    hex: "#b14802"
  },
  700: {
    title: "Orange 700",
    hex: "#7c3404"
  },
  800: {
    title: "Orange 800",
    hex: "#461e07"
  },
  900: {
    title: "Orange 900",
    hex: "#32160b"
  },
  950: {
    title: "Orange 950",
    hex: "#21120d"
  }
};
var yellow = {
  50: {
    title: "Yellow 50",
    hex: "#fefae1"
  },
  100: {
    title: "Yellow 100",
    hex: "#fcf3bb"
  },
  200: {
    title: "Yellow 200",
    hex: "#f9e994"
  },
  300: {
    title: "Yellow 300",
    hex: "#f7d455"
  },
  400: {
    title: "Yellow 400",
    hex: "#f9bc15"
  },
  500: {
    title: "Yellow 500",
    hex: "#d28a04"
  },
  600: {
    title: "Yellow 600",
    hex: "#965908"
  },
  700: {
    title: "Yellow 700",
    hex: "#653a0b"
  },
  800: {
    title: "Yellow 800",
    hex: "#3b220c"
  },
  900: {
    title: "Yellow 900",
    hex: "#271a11"
  },
  950: {
    title: "Yellow 950",
    hex: "#181410"
  }
};
var green = {
  50: {
    title: "Green 50",
    hex: "#e7fef5"
  },
  100: {
    title: "Green 100",
    hex: "#c5fce8"
  },
  200: {
    title: "Green 200",
    hex: "#a9f9dc"
  },
  300: {
    title: "Green 300",
    hex: "#59f3ba"
  },
  400: {
    title: "Green 400",
    hex: "#0ff0a1"
  },
  500: {
    title: "Green 500",
    hex: "#04b97a"
  },
  600: {
    title: "Green 600",
    hex: "#01794f"
  },
  700: {
    title: "Green 700",
    hex: "#015133"
  },
  800: {
    title: "Green 800",
    hex: "#023120"
  },
  900: {
    title: "Green 900",
    hex: "#06231a"
  },
  950: {
    title: "Green 950",
    hex: "#071715"
  }
};
var cyan = {
  50: {
    title: "Cyan 50",
    hex: "#e7fefe"
  },
  100: {
    title: "Cyan 100",
    hex: "#c5fcfc"
  },
  200: {
    title: "Cyan 200",
    hex: "#96f8f8"
  },
  300: {
    title: "Cyan 300",
    hex: "#62efef"
  },
  400: {
    title: "Cyan 400",
    hex: "#18e2e2"
  },
  500: {
    title: "Cyan 500",
    hex: "#04b8be"
  },
  600: {
    title: "Cyan 600",
    hex: "#037782"
  },
  700: {
    title: "Cyan 700",
    hex: "#024950"
  },
  800: {
    title: "Cyan 800",
    hex: "#042f34"
  },
  900: {
    title: "Cyan 900",
    hex: "#072227"
  },
  950: {
    title: "Cyan 950",
    hex: "#0d181c"
  }
};
var hues = { gray, blue, purple, magenta, red, orange, yellow, green, cyan };
var color = { black, white, ...hues };

// ../node_modules/@sanity/ui/dist/theme.mjs
function createSelectableTones(opts, base, dark, solid, muted) {
  return {
    default: _createSelectableStates(opts, base, dark, solid, muted, "default"),
    primary: _createSelectableStates(opts, base, dark, solid, muted, "primary"),
    positive: _createSelectableStates(opts, base, dark, solid, muted, "positive"),
    caution: _createSelectableStates(opts, base, dark, solid, muted, "caution"),
    critical: _createSelectableStates(opts, base, dark, solid, muted, "critical")
  };
}
function _createSelectableStates(opts, base, dark, solid, muted, tone) {
  return {
    enabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "enabled",
      tone
    }),
    hovered: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "hovered",
      tone
    }),
    pressed: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "pressed",
      tone
    }),
    selected: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "selected",
      tone
    }),
    disabled: opts.selectable({
      base,
      dark,
      solid,
      muted,
      state: "disabled",
      tone
    })
  };
}
function createSolidTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "default",
        name,
        state: "selected"
      })
    },
    transparent: {
      enabled: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "transparent",
        name,
        state: "selected"
      })
    },
    primary: {
      enabled: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "primary",
        name,
        state: "selected"
      })
    },
    positive: {
      enabled: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "positive",
        name,
        state: "selected"
      })
    },
    caution: {
      enabled: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "caution",
        name,
        state: "selected"
      })
    },
    critical: {
      enabled: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "enabled"
      }),
      disabled: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "disabled"
      }),
      hovered: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "hovered"
      }),
      pressed: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "pressed"
      }),
      selected: opts.solid({
        base,
        dark,
        tone: "critical",
        name,
        state: "selected"
      })
    }
  };
}
function createButtonTones(opts, base, dark, solid, muted, mode) {
  return {
    default: opts.button({
      base,
      dark,
      solid: solid.default,
      muted: muted.default,
      mode
    }),
    primary: opts.button({
      base,
      dark,
      solid: solid.primary,
      muted: muted.primary,
      mode
    }),
    positive: opts.button({
      base,
      dark,
      solid: solid.positive,
      muted: muted.positive,
      mode
    }),
    caution: opts.button({
      base,
      dark,
      solid: solid.caution,
      muted: muted.caution,
      mode
    }),
    critical: opts.button({
      base,
      dark,
      solid: solid.critical,
      muted: muted.critical,
      mode
    })
  };
}
function createButtonModes(opts, base, dark, solid, muted) {
  return {
    default: createButtonTones(opts, base, dark, solid, muted, "default"),
    ghost: createButtonTones(opts, base, dark, solid, muted, "ghost"),
    bleed: createButtonTones(opts, base, dark, solid, muted, "bleed")
  };
}
function createCardStates(opts, base, dark, name, solid, muted) {
  return {
    enabled: opts.card({
      base,
      dark,
      name,
      state: "enabled",
      solid,
      muted
    }),
    disabled: opts.card({
      base,
      dark,
      name,
      state: "disabled",
      solid,
      muted
    }),
    hovered: opts.card({
      base,
      dark,
      name,
      state: "hovered",
      solid,
      muted
    }),
    pressed: opts.card({
      base,
      dark,
      name,
      state: "pressed",
      solid,
      muted
    }),
    selected: opts.card({
      base,
      dark,
      name,
      state: "selected",
      solid,
      muted
    })
  };
}
var black2 = "hsl(0, 0%, 0%)";
var white2 = "hsl(0, 0%, 100%)";
var colors = {
  default: {
    lightest: "hsl(0, 0%, 95%)",
    lighter: "hsl(0, 0%, 70%)",
    light: "hsl(0, 0%, 65%)",
    base: "hsl(0, 0%, 50%)",
    dark: "hsl(0, 0%, 35%)",
    darker: "hsl(0, 0%, 20%)",
    darkest: "hsl(0, 0%, 5%)"
  },
  transparent: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  primary: {
    lightest: "hsl(240, 100%, 95%)",
    lighter: "hsl(240, 100%, 70%)",
    light: "hsl(240, 100%, 65%)",
    base: "hsl(240, 100%, 50%)",
    dark: "hsl(240, 100%, 35%)",
    darker: "hsl(240, 100%, 20%)",
    darkest: "hsl(240, 100%, 5%)"
  },
  positive: {
    lightest: "hsl(120, 100%, 95%)",
    lighter: "hsl(120, 100%, 70%)",
    light: "hsl(120, 100%, 65%)",
    base: "hsl(120, 100%, 50%)",
    dark: "hsl(120, 100%, 35%)",
    darker: "hsl(120, 100%, 20%)",
    darkest: "hsl(120, 100%, 5%)"
  },
  caution: {
    lightest: "hsl(60, 100%, 95%)",
    lighter: "hsl(60, 100%, 70%)",
    light: "hsl(60, 100%, 65%)",
    base: "hsl(60, 100%, 50%)",
    dark: "hsl(60, 100%, 35%)",
    darker: "hsl(60, 100%, 20%)",
    darkest: "hsl(60, 100%, 5%)"
  },
  critical: {
    lightest: "hsl(0, 100%, 95%)",
    lighter: "hsl(0, 100%, 70%)",
    light: "hsl(0, 100%, 65%)",
    base: "hsl(0, 100%, 50%)",
    dark: "hsl(0, 100%, 35%)",
    darker: "hsl(0, 100%, 20%)",
    darkest: "hsl(0, 100%, 5%)"
  }
};
var spots = {
  gray: "hsl(0, 0%, 50%)",
  red: "hsl(0, 100%, 50%)",
  orange: "hsl(30, 100%, 50%)",
  yellow: "hsl(60, 100%, 50%)",
  green: "hsl(120, 100%, 50%)",
  cyan: "hsl(180, 100%, 50%)",
  blue: "hsl(240, 100%, 50%)",
  purple: "hsl(270, 100%, 50%)",
  magenta: "hsl(300, 100%, 50%)"
};
var tones = {
  transparent: {
    bg: [colors.transparent.darkest, colors.transparent.lightest],
    fg: [colors.transparent.lightest, colors.transparent.darkest],
    border: [colors.transparent.darker, colors.transparent.lighter],
    focusRing: [colors.transparent.base, colors.transparent.base]
  },
  primary: {
    bg: [colors.primary.darkest, colors.primary.lightest],
    fg: [colors.primary.lightest, colors.primary.darkest],
    border: [colors.primary.darker, colors.primary.lighter],
    focusRing: [colors.primary.base, colors.primary.base]
  },
  positive: {
    bg: [colors.positive.darkest, colors.positive.lightest],
    fg: [colors.positive.lightest, colors.positive.darkest],
    border: [colors.positive.darker, colors.positive.lighter],
    focusRing: [colors.positive.base, colors.positive.base]
  },
  caution: {
    bg: [colors.caution.darkest, colors.caution.lightest],
    fg: [colors.caution.lightest, colors.caution.darkest],
    border: [colors.caution.darker, colors.caution.lighter],
    focusRing: [colors.caution.base, colors.caution.base]
  },
  critical: {
    bg: [colors.critical.darkest, colors.critical.lightest],
    fg: [colors.critical.lightest, colors.critical.darkest],
    border: [colors.critical.darker, colors.critical.lighter],
    focusRing: [colors.critical.base, colors.critical.base]
  }
};
var defaultOpts = {
  base: ({
    dark,
    name
  }) => name === "default" ? {
    bg: dark ? black2 : white2,
    fg: dark ? white2 : black2,
    border: dark ? colors.default.darkest : colors.default.lightest,
    focusRing: colors.primary.base,
    shadow: {
      outline: black2,
      umbra: black2,
      penumbra: black2,
      ambient: black2
    },
    skeleton: {
      from: dark ? white2 : black2,
      to: dark ? white2 : black2
    }
  } : {
    bg: tones[name].bg[dark ? 0 : 1],
    fg: tones[name].fg[dark ? 0 : 1],
    border: tones[name].border[dark ? 0 : 1],
    focusRing: tones[name].focusRing[dark ? 0 : 1],
    shadow: {
      outline: black2,
      umbra: black2,
      penumbra: black2,
      ambient: black2
    },
    skeleton: {
      from: dark ? white2 : black2,
      to: dark ? white2 : black2
    }
  },
  solid: ({
    base,
    dark,
    state,
    tone
  }) => {
    const color22 = colors[tone];
    return state === "hovered" ? {
      bg: dark ? color22.light : color22.dark,
      bg2: dark ? color22.light : color22.dark,
      border: dark ? color22.lighter : color22.darker,
      fg: dark ? color22.darkest : color22.lightest,
      icon: dark ? color22.darkest : color22.lightest,
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    } : {
      bg: color22.base,
      bg2: color22.base,
      border: dark ? color22.light : color22.dark,
      fg: dark ? color22.darkest : color22.lightest,
      icon: dark ? color22.darkest : color22.lightest,
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    };
  },
  muted: ({
    base,
    dark,
    state,
    tone
  }) => {
    const color22 = colors[tone];
    return state === "hovered" ? {
      bg: dark ? color22.darker : color22.lighter,
      bg2: dark ? color22.darker : color22.lighter,
      border: dark ? color22.lighter : color22.darker,
      fg: dark ? color22.lightest : color22.darkest,
      icon: dark ? color22.lightest : color22.darkest,
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    } : {
      bg: dark ? color22.darkest : color22.lightest,
      bg2: dark ? color22.darkest : color22.lightest,
      border: dark ? color22.darker : color22.lighter,
      fg: dark ? color22.lighter : color22.darker,
      icon: dark ? color22.lighter : color22.darker,
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    };
  },
  button: ({
    base,
    mode,
    muted,
    solid
  }) => mode === "bleed" ? {
    ...muted,
    enabled: {
      bg: "transparent",
      bg2: "transparent",
      fg: muted.enabled.fg,
      icon: muted.enabled.fg,
      border: "transparent",
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    },
    hovered: {
      bg: muted.enabled.bg,
      bg2: muted.enabled.bg,
      fg: muted.hovered.fg,
      icon: muted.hovered.fg,
      border: "transparent",
      muted: {
        fg: black2
      },
      accent: {
        fg: black2
      },
      link: {
        fg: black2
      },
      code: {
        bg: black2,
        fg: black2
      },
      skeleton: base.skeleton
    }
  } : mode === "ghost" ? {
    ...solid,
    enabled: muted.enabled
  } : solid,
  card: ({
    base
  }) => ({
    bg: black2,
    bg2: black2,
    fg: black2,
    icon: black2,
    border: black2,
    muted: {
      fg: black2
    },
    accent: {
      fg: black2
    },
    link: {
      fg: black2
    },
    code: {
      bg: black2,
      fg: black2
    },
    skeleton: base.skeleton
  }),
  input: () => ({
    bg: black2,
    bg2: black2,
    fg: black2,
    border: black2,
    placeholder: black2
  }),
  selectable: ({
    muted,
    state,
    tone
  }) => muted[tone][state],
  spot: ({
    key: key2
  }) => spots[key2],
  syntax: () => ({
    atrule: black2,
    attrName: black2,
    attrValue: black2,
    attribute: black2,
    boolean: black2,
    builtin: black2,
    cdata: black2,
    char: black2,
    class: black2,
    className: black2,
    comment: black2,
    constant: black2,
    deleted: black2,
    doctype: black2,
    entity: black2,
    function: black2,
    hexcode: black2,
    id: black2,
    important: black2,
    inserted: black2,
    keyword: black2,
    number: black2,
    operator: black2,
    prolog: black2,
    property: black2,
    pseudoClass: black2,
    pseudoElement: black2,
    punctuation: black2,
    regex: black2,
    selector: black2,
    string: black2,
    symbol: black2,
    tag: black2,
    unit: black2,
    url: black2,
    variable: black2
  })
};
function createInputModes(opts, base, dark, solid, muted) {
  return {
    default: {
      enabled: opts.input({
        base,
        dark,
        mode: "default",
        state: "enabled",
        solid: solid.default,
        muted: muted.default
      }),
      disabled: opts.input({
        base,
        dark,
        mode: "default",
        state: "disabled",
        solid: solid.default,
        muted: muted.default
      }),
      hovered: opts.input({
        base,
        dark,
        mode: "default",
        state: "hovered",
        solid: solid.default,
        muted: muted.default
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: "default",
        state: "readOnly",
        solid: solid.default,
        muted: muted.default
      })
    },
    invalid: {
      enabled: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "enabled",
        solid: solid.default,
        muted: muted.default
      }),
      disabled: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "disabled",
        solid: solid.default,
        muted: muted.default
      }),
      hovered: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "hovered",
        solid: solid.default,
        muted: muted.default
      }),
      readOnly: opts.input({
        base,
        dark,
        mode: "invalid",
        state: "readOnly",
        solid: solid.default,
        muted: muted.default
      })
    }
  };
}
function createMutedTones(opts, base, dark, name) {
  return {
    default: {
      enabled: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "default",
        name,
        state: "selected"
      })
    },
    transparent: {
      enabled: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "transparent",
        name,
        state: "selected"
      })
    },
    primary: {
      enabled: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "primary",
        name,
        state: "selected"
      })
    },
    positive: {
      enabled: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "positive",
        name,
        state: "selected"
      })
    },
    caution: {
      enabled: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "caution",
        name,
        state: "selected"
      })
    },
    critical: {
      enabled: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "enabled"
      }),
      disabled: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "disabled"
      }),
      hovered: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "hovered"
      }),
      pressed: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "pressed"
      }),
      selected: opts.muted({
        base,
        dark,
        tone: "critical",
        name,
        state: "selected"
      })
    }
  };
}
function createSpot(opts, base, dark) {
  return {
    gray: opts.spot({
      base,
      dark,
      key: "gray"
    }),
    blue: opts.spot({
      base,
      dark,
      key: "blue"
    }),
    purple: opts.spot({
      base,
      dark,
      key: "purple"
    }),
    magenta: opts.spot({
      base,
      dark,
      key: "magenta"
    }),
    red: opts.spot({
      base,
      dark,
      key: "red"
    }),
    orange: opts.spot({
      base,
      dark,
      key: "orange"
    }),
    yellow: opts.spot({
      base,
      dark,
      key: "yellow"
    }),
    green: opts.spot({
      base,
      dark,
      key: "green"
    }),
    cyan: opts.spot({
      base,
      dark,
      key: "cyan"
    })
  };
}
function createColorTheme(partialOpts = {}) {
  const builders = {
    ...defaultOpts,
    ...partialOpts
  };
  return {
    light: _createColorScheme(builders, false),
    dark: _createColorScheme(builders, true)
  };
}
function _createColorScheme(opts, dark) {
  return {
    default: _createColor(opts, dark, "default"),
    transparent: _createColor(opts, dark, "transparent"),
    primary: _createColor(opts, dark, "primary"),
    positive: _createColor(opts, dark, "positive"),
    caution: _createColor(opts, dark, "caution"),
    critical: _createColor(opts, dark, "critical")
  };
}
function _createColor(opts, dark, name) {
  const base = opts.base({
    dark,
    name
  }), solid = createSolidTones(opts, base, dark, name), muted = createMutedTones(opts, base, dark, name);
  return {
    base,
    button: createButtonModes(opts, base, dark, solid, muted),
    card: createCardStates(opts, base, dark, name, solid, muted),
    dark,
    input: createInputModes(opts, base, dark, solid, muted),
    selectable: createSelectableTones(opts, base, dark, solid, muted),
    spot: createSpot(opts, base, dark),
    syntax: opts.syntax({
      base,
      dark
    }),
    solid,
    muted
  };
}
var defaultThemeConfig = {
  avatar: {
    sizes: [{
      distance: -4,
      size: 19
    }, {
      distance: -4,
      size: 25
    }, {
      distance: -8,
      size: 33
    }, {
      distance: -12,
      size: 49
    }],
    focusRing: {
      offset: 1,
      width: 1
    }
  },
  button: {
    textWeight: "medium",
    border: {
      width: 1
    },
    focusRing: {
      offset: -1,
      width: 1
    }
  },
  card: {
    border: {
      width: 1
    },
    focusRing: {
      offset: -1,
      width: 1
    },
    shadow: {
      outline: 0.5
    }
  },
  container: [320, 640, 960, 1280, 1600, 1920],
  media: [360, 600, 900, 1200, 1800, 2400],
  layer: {
    dialog: {
      zOffset: 600
    },
    popover: {
      zOffset: 400
    },
    tooltip: {
      zOffset: 200
    }
  },
  radius: [0, 1, 3, 6, 9, 12, 21],
  shadow: [null, {
    umbra: [0, 0, 0, 0],
    penumbra: [0, 0, 0, 0],
    ambient: [0, 0, 0, 0]
  }, {
    umbra: [0, 3, 5, -2],
    penumbra: [0, 6, 10, 0],
    ambient: [0, 1, 18, 1]
  }, {
    umbra: [0, 7, 8, -4],
    penumbra: [0, 12, 17, 2],
    ambient: [0, 5, 22, 4]
  }, {
    umbra: [0, 9, 11, -5],
    penumbra: [0, 18, 28, 2],
    ambient: [0, 7, 34, 6]
  }, {
    umbra: [0, 11, 15, -7],
    penumbra: [0, 24, 38, 3],
    ambient: [0, 9, 46, 8]
  }],
  space: [0, 4, 8, 12, 20, 32, 52, 84, 136, 220],
  input: {
    border: {
      width: 1
    },
    checkbox: {
      size: 17,
      focusRing: {
        offset: -1,
        width: 1
      }
    },
    radio: {
      size: 17,
      markSize: 9,
      focusRing: {
        offset: -1,
        width: 1
      }
    },
    switch: {
      width: 25,
      height: 17,
      padding: 5,
      transitionDurationMs: 150,
      transitionTimingFunction: "ease-out",
      focusRing: {
        offset: 1,
        width: 1
      }
    },
    select: {
      focusRing: {
        offset: -1,
        width: 1
      }
    },
    text: {
      focusRing: {
        offset: -1,
        width: 1
      }
    }
  },
  style: {
    button: {
      root: {
        transition: "background-color 100ms,border-color 100ms,color 100ms"
      }
    }
    // card: {
    //   root: {
    //     transition: 'background-color 100ms,border-color 100ms,color 100ms',
    //   },
    // },
  }
};
var defaultThemeFonts = {
  code: {
    family: "ui-monospace, SFMono-Regular, SF Mono, Menlo, Consolas, Liberation Mono, monospace",
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [{
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 10,
      iconSize: 17,
      lineHeight: 15,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 13,
      iconSize: 21,
      lineHeight: 19,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 23,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 19,
      iconSize: 29,
      lineHeight: 27,
      letterSpacing: 0
    }, {
      ascenderHeight: 8,
      descenderHeight: 8,
      fontSize: 22,
      iconSize: 33,
      lineHeight: 31,
      letterSpacing: 0
    }]
  },
  heading: {
    family: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 700,
      medium: 800,
      semibold: 900,
      bold: 900
    },
    sizes: [{
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 13,
      iconSize: 17,
      lineHeight: 19,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 16,
      iconSize: 25,
      lineHeight: 23,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 21,
      iconSize: 33,
      lineHeight: 29,
      letterSpacing: 0
    }, {
      ascenderHeight: 8,
      descenderHeight: 8,
      fontSize: 27,
      iconSize: 41,
      lineHeight: 35,
      letterSpacing: 0
    }, {
      ascenderHeight: 9.5,
      descenderHeight: 8.5,
      fontSize: 33,
      iconSize: 49,
      lineHeight: 41,
      letterSpacing: 0
    }, {
      ascenderHeight: 10.5,
      descenderHeight: 9.5,
      fontSize: 38,
      iconSize: 53,
      lineHeight: 47,
      letterSpacing: 0
    }]
  },
  label: {
    family: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", system-ui, sans-serif',
    weights: {
      regular: 600,
      medium: 700,
      semibold: 800,
      bold: 900
    },
    sizes: [{
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 8.1,
      iconSize: 13,
      lineHeight: 10,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 9.5,
      iconSize: 15,
      lineHeight: 11,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 10.8,
      iconSize: 17,
      lineHeight: 12,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 12.25,
      iconSize: 19,
      lineHeight: 13,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 13.6,
      iconSize: 21,
      lineHeight: 14,
      letterSpacing: 0.5
    }, {
      ascenderHeight: 2,
      descenderHeight: 2,
      fontSize: 15,
      iconSize: 23,
      lineHeight: 15,
      letterSpacing: 0.5
    }]
  },
  text: {
    family: 'Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", "Liberation Sans", Helvetica, Arial, system-ui, sans-serif',
    weights: {
      regular: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    sizes: [{
      ascenderHeight: 4,
      descenderHeight: 4,
      fontSize: 10,
      iconSize: 17,
      lineHeight: 15,
      letterSpacing: 0
    }, {
      ascenderHeight: 5,
      descenderHeight: 5,
      fontSize: 13,
      iconSize: 21,
      lineHeight: 19,
      letterSpacing: 0
    }, {
      ascenderHeight: 6,
      descenderHeight: 6,
      fontSize: 15,
      iconSize: 25,
      lineHeight: 23,
      letterSpacing: 0
    }, {
      ascenderHeight: 7,
      descenderHeight: 7,
      fontSize: 18,
      iconSize: 29,
      lineHeight: 27,
      letterSpacing: 0
    }, {
      ascenderHeight: 8,
      descenderHeight: 8,
      fontSize: 21,
      iconSize: 33,
      lineHeight: 31,
      letterSpacing: 0
    }]
  }
};
var cache$4 = /* @__PURE__ */ new WeakMap();
function themeColor_v0_v2(color_v0) {
  var _a, _b, _c;
  const cached_v2 = cache$4.get(color_v0);
  if (cached_v2) return cached_v2;
  const base = stateThemeColor_v0_v2(color_v0, color_v0.card.enabled), color_v2 = {
    _blend: color_v0._blend || (color_v0.dark ? "screen" : "multiply"),
    _dark: color_v0.dark,
    accent: base.accent,
    avatar: base.avatar,
    backdrop: color_v0.base.shadow.ambient,
    badge: base.badge,
    bg: color_v0.base.bg,
    border: color_v0.base.border,
    button: {
      default: stateTonesThemeColor_v0_v2(color_v0, color_v0.button.default),
      ghost: stateTonesThemeColor_v0_v2(color_v0, color_v0.button.ghost),
      bleed: stateTonesThemeColor_v0_v2(color_v0, color_v0.button.bleed)
    },
    code: base.code,
    fg: color_v0.base.fg,
    focusRing: color_v0.base.focusRing,
    icon: base.muted.fg,
    input: {
      default: inputStatesThemeColor_v0_v2(color_v0.input.default),
      invalid: inputStatesThemeColor_v0_v2(color_v0.input.invalid)
    },
    kbd: base.kbd,
    link: base.link,
    muted: {
      ...base.muted,
      bg: ((_a = color_v0.selectable) == null ? void 0 : _a.default.enabled.bg2) || color_v0.base.bg
    },
    selectable: stateTonesThemeColor_v0_v2(color_v0, color_v0.selectable || color_v0.muted),
    shadow: color_v0.base.shadow,
    skeleton: {
      from: ((_b = color_v0.skeleton) == null ? void 0 : _b.from) || color_v0.base.border,
      to: ((_c = color_v0.skeleton) == null ? void 0 : _c.to) || color_v0.base.border
    },
    syntax: color_v0.syntax
  };
  return cache$4.set(color_v0, color_v2), color_v2;
}
function stateTonesThemeColor_v0_v2(v0, t) {
  return {
    default: {
      enabled: stateThemeColor_v0_v2(v0, t.default.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.default.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.default.pressed),
      selected: stateThemeColor_v0_v2(v0, t.default.selected),
      disabled: stateThemeColor_v0_v2(v0, t.default.disabled)
    },
    neutral: {
      enabled: stateThemeColor_v0_v2(v0, t.default.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.default.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.default.pressed),
      selected: stateThemeColor_v0_v2(v0, t.default.selected),
      disabled: stateThemeColor_v0_v2(v0, t.default.disabled)
    },
    primary: {
      enabled: stateThemeColor_v0_v2(v0, t.primary.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.primary.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.primary.pressed),
      selected: stateThemeColor_v0_v2(v0, t.primary.selected),
      disabled: stateThemeColor_v0_v2(v0, t.primary.disabled)
    },
    suggest: {
      enabled: stateThemeColor_v0_v2(v0, t.primary.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.primary.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.primary.pressed),
      selected: stateThemeColor_v0_v2(v0, t.primary.selected),
      disabled: stateThemeColor_v0_v2(v0, t.primary.disabled)
    },
    positive: {
      enabled: stateThemeColor_v0_v2(v0, t.positive.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.positive.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.positive.pressed),
      selected: stateThemeColor_v0_v2(v0, t.positive.selected),
      disabled: stateThemeColor_v0_v2(v0, t.positive.disabled)
    },
    caution: {
      enabled: stateThemeColor_v0_v2(v0, t.caution.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.caution.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.caution.pressed),
      selected: stateThemeColor_v0_v2(v0, t.caution.selected),
      disabled: stateThemeColor_v0_v2(v0, t.caution.disabled)
    },
    critical: {
      enabled: stateThemeColor_v0_v2(v0, t.critical.enabled),
      hovered: stateThemeColor_v0_v2(v0, t.critical.hovered),
      pressed: stateThemeColor_v0_v2(v0, t.critical.pressed),
      selected: stateThemeColor_v0_v2(v0, t.critical.selected),
      disabled: stateThemeColor_v0_v2(v0, t.critical.disabled)
    }
  };
}
function stateThemeColor_v0_v2(v0, state) {
  var _a, _b;
  return {
    ...state,
    avatar: {
      gray: {
        bg: v0.spot.gray,
        fg: v0.base.bg
      },
      blue: {
        bg: v0.spot.blue,
        fg: v0.base.bg
      },
      purple: {
        bg: v0.spot.purple,
        fg: v0.base.bg
      },
      magenta: {
        bg: v0.spot.magenta,
        fg: v0.base.bg
      },
      red: {
        bg: v0.spot.red,
        fg: v0.base.bg
      },
      orange: {
        bg: v0.spot.orange,
        fg: v0.base.bg
      },
      yellow: {
        bg: v0.spot.yellow,
        fg: v0.base.bg
      },
      green: {
        bg: v0.spot.green,
        fg: v0.base.bg
      },
      cyan: {
        bg: v0.spot.cyan,
        fg: v0.base.bg
      }
    },
    badge: {
      default: {
        bg: v0.muted.default.enabled.bg,
        fg: v0.muted.default.enabled.fg,
        dot: v0.muted.default.enabled.muted.fg,
        icon: v0.muted.default.enabled.muted.fg
      },
      neutral: {
        bg: v0.muted.transparent.enabled.bg,
        fg: v0.muted.transparent.enabled.fg,
        dot: v0.muted.transparent.enabled.muted.fg,
        icon: v0.muted.transparent.enabled.muted.fg
      },
      primary: {
        bg: v0.muted.primary.enabled.bg,
        fg: v0.muted.primary.enabled.fg,
        dot: v0.muted.primary.enabled.muted.fg,
        icon: v0.muted.primary.enabled.muted.fg
      },
      suggest: {
        bg: v0.muted.primary.enabled.bg,
        fg: v0.muted.primary.enabled.fg,
        dot: v0.muted.primary.enabled.muted.fg,
        icon: v0.muted.primary.enabled.muted.fg
      },
      positive: {
        bg: v0.muted.positive.enabled.bg,
        fg: v0.muted.positive.enabled.fg,
        dot: v0.muted.positive.enabled.muted.fg,
        icon: v0.muted.positive.enabled.muted.fg
      },
      caution: {
        bg: v0.muted.caution.enabled.bg,
        fg: v0.muted.caution.enabled.fg,
        dot: v0.muted.caution.enabled.muted.fg,
        icon: v0.muted.caution.enabled.muted.fg
      },
      critical: {
        bg: v0.muted.critical.enabled.bg,
        fg: v0.muted.critical.enabled.fg,
        dot: v0.muted.critical.enabled.muted.fg,
        icon: v0.muted.critical.enabled.muted.fg
      }
    },
    kbd: {
      bg: v0.muted.default.enabled.bg,
      fg: v0.muted.default.enabled.fg,
      border: v0.muted.default.enabled.border
    },
    muted: {
      ...v0.muted.default.enabled.muted,
      bg: state.bg2 || state.bg
    },
    skeleton: {
      from: ((_a = state.skeleton) == null ? void 0 : _a.from) || state.border,
      to: ((_b = state.skeleton) == null ? void 0 : _b.to) || state.border
    }
  };
}
function inputStatesThemeColor_v0_v2(states) {
  return {
    enabled: inputStateThemeColor_v0_v2(states.enabled),
    disabled: inputStateThemeColor_v0_v2(states.disabled),
    readOnly: inputStateThemeColor_v0_v2(states.readOnly),
    hovered: inputStateThemeColor_v0_v2(states.hovered)
  };
}
function inputStateThemeColor_v0_v2(state) {
  return {
    bg: state.bg,
    border: state.border,
    fg: state.fg,
    muted: {
      bg: state.bg2
    },
    placeholder: state.placeholder
  };
}
var cache$3 = /* @__PURE__ */ new WeakMap();
function getTheme_v2(theme) {
  var _a;
  if ((_a = theme.sanity.v2) == null ? void 0 : _a._resolved) return theme.sanity.v2;
  const cached_v2 = cache$3.get(theme);
  if (cached_v2) return cached_v2;
  const v2 = {
    _version: 2,
    _resolved: true,
    avatar: {
      ...defaultThemeConfig.avatar,
      ...theme.sanity.avatar
    },
    button: {
      ...defaultThemeConfig.button,
      ...theme.sanity.button
    },
    card: defaultThemeConfig.card,
    color: themeColor_v0_v2(theme.sanity.color),
    container: theme.sanity.container,
    font: theme.sanity.fonts,
    input: {
      ...defaultThemeConfig.input,
      ...theme.sanity.input,
      checkbox: {
        ...defaultThemeConfig.input.checkbox,
        ...theme.sanity.input.checkbox
      },
      radio: {
        ...defaultThemeConfig.input.radio,
        ...theme.sanity.input.radio
      },
      switch: {
        ...defaultThemeConfig.input.switch,
        ...theme.sanity.input.switch
      }
    },
    layer: theme.sanity.layer ?? defaultThemeConfig.layer,
    media: theme.sanity.media,
    radius: theme.sanity.radius,
    shadow: theme.sanity.shadows,
    space: theme.sanity.space,
    style: theme.sanity.styles
  };
  return cache$3.set(theme, v2), v2;
}
function is_v2(themeProp) {
  return themeProp._version === 2;
}
var cache$2 = /* @__PURE__ */ new WeakMap();
function v0_v2(v0) {
  if (v0.v2) return v0.v2;
  const cached_v2 = cache$2.get(v0);
  if (cached_v2) return cached_v2;
  const {
    avatar,
    button,
    color: color22,
    container: container2,
    fonts: font,
    input,
    layer,
    media,
    radius,
    shadows: shadow,
    space,
    styles: style
  } = v0, v2 = {
    _version: 2,
    avatar: {
      ...defaultThemeConfig.avatar,
      ...avatar
    },
    button: {
      ...defaultThemeConfig.button,
      ...button
    },
    card: defaultThemeConfig.card,
    color: {
      light: {
        transparent: themeColor_v0_v2(color22.light.transparent),
        default: themeColor_v0_v2(color22.light.default),
        neutral: themeColor_v0_v2(color22.light.transparent),
        primary: themeColor_v0_v2(color22.light.primary),
        suggest: themeColor_v0_v2(color22.light.primary),
        positive: themeColor_v0_v2(color22.light.positive),
        caution: themeColor_v0_v2(color22.light.caution),
        critical: themeColor_v0_v2(color22.light.critical)
      },
      dark: {
        transparent: themeColor_v0_v2(color22.dark.transparent),
        default: themeColor_v0_v2(color22.dark.default),
        neutral: themeColor_v0_v2(color22.dark.transparent),
        primary: themeColor_v0_v2(color22.dark.primary),
        suggest: themeColor_v0_v2(color22.dark.primary),
        positive: themeColor_v0_v2(color22.dark.positive),
        caution: themeColor_v0_v2(color22.dark.caution),
        critical: themeColor_v0_v2(color22.dark.critical)
      }
    },
    container: container2,
    font,
    input: {
      ...defaultThemeConfig.input,
      ...input,
      checkbox: {
        ...defaultThemeConfig.input.checkbox,
        ...input.checkbox
      },
      radio: {
        ...defaultThemeConfig.input.radio,
        ...input.radio
      },
      switch: {
        ...defaultThemeConfig.input.switch,
        ...input.switch
      }
    },
    layer: layer ?? defaultThemeConfig.layer,
    media,
    radius,
    shadow,
    space,
    style
  };
  return cache$2.set(v0, v2), v2;
}
var cache$1 = /* @__PURE__ */ new WeakMap();
function v2_v0(v2) {
  const cachedTheme = cache$1.get(v2);
  if (cachedTheme) return cachedTheme;
  const {
    avatar,
    button,
    color: color22,
    container: container2,
    font: fonts,
    input,
    media,
    radius,
    shadow: shadows,
    space,
    style: styles
  } = v2;
  return {
    _version: 0,
    avatar,
    button,
    container: container2,
    color: {
      light: {
        transparent: themeColor_v2_v0(color22.light.transparent),
        default: themeColor_v2_v0(color22.light.default),
        primary: themeColor_v2_v0(color22.light.primary),
        positive: themeColor_v2_v0(color22.light.positive),
        caution: themeColor_v2_v0(color22.light.caution),
        critical: themeColor_v2_v0(color22.light.critical)
      },
      dark: {
        transparent: themeColor_v2_v0(color22.dark.transparent),
        default: themeColor_v2_v0(color22.dark.default),
        primary: themeColor_v2_v0(color22.dark.primary),
        positive: themeColor_v2_v0(color22.dark.positive),
        caution: themeColor_v2_v0(color22.dark.caution),
        critical: themeColor_v2_v0(color22.dark.critical)
      }
    },
    focusRing: input.text.focusRing,
    fonts,
    input,
    media,
    radius,
    shadows,
    space,
    styles,
    v2
  };
}
function themeColor_v2_v0(color_v2) {
  return {
    base: {
      bg: color_v2.bg,
      fg: color_v2.fg,
      border: color_v2.border,
      focusRing: color_v2.focusRing,
      shadow: color_v2.shadow
    },
    button: color_v2.button,
    card: color_v2.selectable.default,
    dark: color_v2._dark,
    input: {
      default: inputStatesThemeColor_v2_v0(color_v2.input.default),
      invalid: inputStatesThemeColor_v2_v0(color_v2.input.invalid)
    },
    muted: {
      ...color_v2.button.ghost,
      transparent: color_v2.button.ghost.default
    },
    solid: {
      ...color_v2.button.default,
      transparent: color_v2.button.default.default
    },
    selectable: color_v2.selectable,
    spot: {
      gray: color_v2.avatar.gray.bg,
      blue: color_v2.avatar.blue.bg,
      purple: color_v2.avatar.purple.bg,
      magenta: color_v2.avatar.magenta.bg,
      red: color_v2.avatar.red.bg,
      orange: color_v2.avatar.orange.bg,
      yellow: color_v2.avatar.yellow.bg,
      green: color_v2.avatar.green.bg,
      cyan: color_v2.avatar.cyan.bg
    },
    syntax: color_v2.syntax
  };
}
function inputStatesThemeColor_v2_v0(t) {
  return {
    enabled: inputStateThemeColor_v2_v0(t.enabled),
    disabled: inputStateThemeColor_v2_v0(t.disabled),
    readOnly: inputStateThemeColor_v2_v0(t.readOnly),
    hovered: inputStateThemeColor_v2_v0(t.hovered)
  };
}
function inputStateThemeColor_v2_v0(t) {
  return {
    bg: t.bg,
    bg2: t.muted.bg,
    border: t.border,
    fg: t.fg,
    placeholder: t.placeholder
  };
}
var THEME_COLOR_BLEND_MODES = ["multiply", "screen"];
var THEME_COLOR_CARD_TONES = [
  "transparent",
  "default",
  "neutral",
  "primary",
  // deprecated
  "suggest",
  "positive",
  "caution",
  "critical"
];
var THEME_COLOR_STATE_TONES = [
  "default",
  "neutral",
  "primary",
  // deprecated
  "suggest",
  "positive",
  "caution",
  "critical"
];
var THEME_COLOR_STATES = ["enabled", "hovered", "pressed", "selected", "disabled"];
var THEME_COLOR_BUTTON_MODES = ["default", "ghost", "bleed"];
var THEME_COLOR_INPUT_MODES = ["default", "invalid"];
var THEME_COLOR_INPUT_STATES = ["enabled", "hovered", "readOnly", "disabled"];
var THEME_COLOR_AVATAR_COLORS = COLOR_HUES;
function isColorBlendModeValue(str) {
  return THEME_COLOR_BLEND_MODES.includes(str);
}
function isColorHueKey(str) {
  return COLOR_HUES.includes(str);
}
function isColorTintKey(str) {
  return COLOR_TINTS.includes(str);
}
var COLOR_CONFIG_STATE_KEYS = ["_hue", "bg", "fg", "border", "focusRing", "muted/fg", "accent/fg", "link/fg", "code/bg", "code/fg", "skeleton/from", "skeleton/to", "status/dot", "status/icon"];
var COLOR_CONFIG_CARD_KEYS = [...COLOR_CONFIG_STATE_KEYS, "_hue", "bg", "fg", "border", "focusRing", "shadow/outline", "shadow/umbra", "shadow/penumbra", "shadow/ambient"];
var COLOR_CONFIG_AVATAR_COLORS = ["*", ...THEME_COLOR_AVATAR_COLORS];
var COLOR_CONFIG_CARD_TONES = ["*", ...THEME_COLOR_CARD_TONES];
var COLOR_CONFIG_STATE_TONES = ["*", ...THEME_COLOR_STATE_TONES];
var COLOR_CONFIG_STATES = ["*", ...THEME_COLOR_STATES];
var COLOR_CONFIG_INPUT_MODES = ["*", ...THEME_COLOR_INPUT_MODES];
var COLOR_CONFIG_INPUT_STATES = ["*", ...THEME_COLOR_INPUT_STATES];
function isColorMixPercentValue(str) {
  return /^\d+%$/.test(str);
}
function parseTokenValue(str) {
  const segments = str.split("/");
  let nextSegment = segments.shift() || "";
  const [segment0, segment0mix] = nextSegment.split(" ");
  if (isColorTintKey(segment0)) {
    const tint = segment0, segment1 = segments.shift() || "";
    if (isColorMixPercentValue(segment0mix)) {
      const mix22 = Number(segment0mix.slice(0, -1)) / 100;
      return {
        type: "color",
        tint,
        mix: mix22
      };
    }
    if (isColorOpacityValue(segment1)) {
      const opacity = Number(segment1);
      return {
        type: "color",
        tint,
        opacity
      };
    }
    return {
      type: "color",
      tint
    };
  }
  if (isColorValue(segment0)) {
    const key2 = segment0, segment1 = segments.shift() || "";
    if (isColorMixPercentValue(segment0mix)) {
      const mix22 = Number(segment0mix.slice(0, -1)) / 100;
      return {
        type: "color",
        key: key2,
        mix: mix22
      };
    }
    if (isColorOpacityValue(segment1)) {
      const opacity = Number(segment1);
      return {
        type: "color",
        key: key2,
        opacity
      };
    }
    return {
      type: "color",
      key: key2
    };
  }
  if (isColorHueKey(segment0)) {
    const hue = segment0;
    nextSegment = segments.shift() || "";
    const [segment1, segment1mix] = nextSegment.split(" ");
    if (isColorTintKey(segment1)) {
      const tint = segment1, segment2 = segments.shift() || "";
      if (isColorMixPercentValue(segment1mix)) {
        const mix22 = Number(segment1mix.slice(0, -1)) / 100;
        return {
          type: "color",
          hue,
          tint,
          mix: mix22
        };
      }
      if (isColorOpacityValue(segment2)) {
        const opacity = Number(segment2);
        return {
          type: "color",
          hue,
          tint,
          opacity
        };
      }
      return {
        type: "color",
        hue,
        tint
      };
    }
    return {
      type: "hue",
      value: hue
    };
  }
  if (isColorBlendModeValue(segment0))
    return {
      type: "blendMode",
      value: segment0
    };
}
function isColorValue(str) {
  return str === "black" || str === "white";
}
function isColorOpacityValue(str) {
  return str === "0" || /^0\.[0-9]+$/.test(str) || str === "1";
}
function compileColorTokenValue(node2) {
  let key2 = "";
  return node2.key === "black" || node2.key === "white" ? key2 = node2.key : key2 = `${node2.hue}/${node2.tint}`, node2.mix !== void 0 ? `${key2} ${node2.mix * 100}%` : (node2.opacity !== void 0 && (key2 += `/${node2.opacity}`), key2);
}
var DEFAULT_COLOR_TOKEN_VALUE = ["500", "500"];
function resolveColorTokenValue(context, value = DEFAULT_COLOR_TOKEN_VALUE) {
  const {
    hue,
    scheme
  } = context, node2 = parseTokenValue(value[scheme === "light" ? 0 : 1]);
  if (!node2 || node2.type !== "color")
    throw new Error(`Invalid color token: ${value[0]}`);
  return compileColorTokenValue({
    ...node2,
    hue: node2.hue || hue
  });
}
var defaultColorTokens = {
  base: {
    "*": {
      _blend: ["multiply", "screen"],
      accent: {
        fg: ["purple/600", "purple/400"]
      },
      avatar: {
        "*": {
          _blend: ["screen", "multiply"],
          bg: ["500", "400"],
          fg: ["white", "black"]
        }
      },
      backdrop: ["gray/200/0.5", "black/0.5"],
      badge: {
        "*": {
          bg: ["100", "900"],
          fg: ["600", "400"],
          icon: ["500", "500"],
          dot: ["500", "500"]
        },
        positive: {
          bg: ["200 50%", "900"],
          fg: ["600", "500"]
        },
        caution: {
          bg: ["200 50%", "900"],
          fg: ["600", "500"]
        }
      },
      bg: ["50", "950"],
      border: ["200", "800"],
      code: {
        bg: ["50", "950"],
        fg: ["600", "400"]
      },
      fg: ["800", "200"],
      focusRing: ["blue/500", "blue/500"],
      icon: ["600", "400"],
      kbd: {
        bg: ["white", "black"],
        fg: ["600", "400"],
        border: ["200", "800"]
      },
      link: {
        fg: ["blue/600", "blue/300"]
      },
      muted: {
        bg: ["50", "950"],
        fg: ["700 75%", "300 75%"]
      },
      shadow: {
        outline: ["500/0.3", "500/0.4"],
        umbra: ["gray/500/0.1", "black/0.2"],
        penumbra: ["gray/500/0.07", "black/0.14"],
        ambient: ["gray/500/0.06", "black/0.12"]
      },
      skeleton: {
        from: ["100", "900"],
        to: ["100 50%", "900 50%"]
      }
    },
    transparent: {
      bg: ["50", "black"]
    },
    default: {
      bg: ["white", "950"],
      fg: ["800", "200"],
      muted: {
        fg: ["600", "400"]
      }
    },
    primary: {
      _hue: "blue"
    },
    suggest: {
      _hue: "purple"
    },
    positive: {
      _hue: "green",
      shadow: {
        outline: ["500/0.4", "500/0.4"]
      }
    },
    caution: {
      _hue: "yellow",
      shadow: {
        outline: ["600/0.3", "500/0.4"]
      }
    },
    critical: {
      _hue: "red"
    }
  },
  button: {
    default: {
      "*": {
        "*": {
          _blend: ["screen", "multiply"],
          accent: {
            fg: ["purple/300", "purple/700"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["900", "100"],
              fg: ["400", "600"],
              dot: ["500", "500"],
              icon: ["500", "500"]
            }
          },
          bg: ["500", "400"],
          border: ["500/0", "400/0"],
          code: {
            bg: ["500 20%", "400 20%"],
            fg: ["200", "600"]
          },
          fg: ["white", "black"],
          icon: ["100 70%", "900 70%"],
          kbd: {
            bg: ["black", "white"],
            fg: ["200", "600"],
            border: ["800", "200"]
          },
          link: {
            fg: ["blue/200", "blue/600"]
          },
          muted: {
            bg: ["950", "50"],
            fg: ["100 70%", "900 70%"]
          },
          skeleton: {
            from: ["900", "100"],
            to: ["900 50%", "100 50%"]
          }
        },
        hovered: {
          bg: ["600", "300"],
          border: ["700/0", "300/0"]
        },
        pressed: {
          bg: ["700", "300"]
        },
        selected: {
          bg: ["700", "300"]
        },
        disabled: {
          _hue: "gray",
          accent: {
            fg: ["100 70%", "900 70%"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["gray/500", "gray/400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["gray/700", "gray/300"],
              fg: ["white", "black"],
              dot: ["white", "black"],
              icon: ["white", "black"]
            }
          },
          bg: ["300", "600"],
          code: {
            bg: ["950", "50"],
            fg: ["300", "600"]
          },
          fg: ["300", "600"],
          muted: {
            bg: ["950", "50"],
            fg: ["300", "600"]
          },
          kbd: {
            bg: ["black", "white"],
            fg: ["white", "black"],
            border: ["700", "300"]
          },
          link: {
            fg: ["100 70%", "900 70%"]
          }
        }
      },
      default: {
        "*": {
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          bg: ["800", "200"],
          muted: {
            bg: ["950", "50"],
            fg: ["400", "600"]
          }
        },
        hovered: {
          bg: ["900", "100"]
        },
        pressed: {
          bg: ["black", "white"]
        },
        selected: {
          bg: ["black", "white"]
        }
      }
    },
    ghost: {
      "*": {
        "*": {
          _blend: ["multiply", "screen"],
          accent: {
            fg: ["purple/700 60%", "purple/300 70%"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["100", "900"],
              fg: ["600", "400"],
              dot: ["500", "500"],
              icon: ["500", "500"]
            }
          },
          bg: ["50", "950"],
          border: ["100", "900"],
          code: {
            bg: ["500 10%", "400 10%"],
            fg: ["700 60%", "400 60%"]
          },
          fg: ["600", "400"],
          icon: ["700 60%", "300 60%"],
          kbd: {
            bg: ["white", "black"],
            fg: ["600", "400"],
            border: ["200", "800"]
          },
          link: {
            fg: ["blue/700 60%", "blue/300 60%"]
          },
          muted: {
            bg: ["100", "950"],
            fg: ["700 60%", "300 60%"]
          },
          skeleton: {
            from: ["100", "900"],
            to: ["100 50%", "900 50%"]
          }
        },
        hovered: {
          bg: ["100", "900"],
          fg: ["700", "300"]
        },
        pressed: {
          bg: ["200", "800"],
          fg: ["800", "200"]
        },
        selected: {
          bg: ["200", "800"],
          fg: ["800", "200"]
        },
        disabled: {
          _hue: "gray",
          accent: {
            fg: ["200", "800"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["gray/100", "gray/900"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              _hue: "gray",
              bg: ["50", "950"],
              fg: ["gray/200", "gray/800"],
              dot: ["gray/200", "gray/800"],
              icon: ["gray/200", "gray/800"]
            }
          },
          border: ["100", "900"],
          code: {
            bg: ["50", "950"],
            fg: ["200", "800"]
          },
          fg: ["400", "600"],
          icon: ["300", "700"],
          muted: {
            fg: ["300", "700"]
          },
          kbd: {
            bg: ["white", "black"],
            fg: ["200", "800"],
            border: ["100", "900"]
          },
          link: {
            fg: ["200", "800"]
          }
        }
      },
      positive: {
        "*": {
          border: ["600 20%", "800"]
        }
      },
      caution: {
        "*": {
          border: ["600 20%", "800"]
        }
      }
    },
    bleed: {
      "*": {
        "*": {
          _blend: ["multiply", "screen"],
          accent: {
            fg: ["purple/700 70%", "purple/300 70%"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["500", "400"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              bg: ["100", "900"],
              fg: ["600", "400"],
              dot: ["500", "500"],
              icon: ["500", "500"]
            }
          },
          bg: ["white", "black"],
          border: ["white/0", "black/0"],
          code: {
            bg: ["50", "950"],
            fg: ["700 75%", "300 75%"]
          },
          fg: ["700", "300"],
          icon: ["700 75%", "300 75%"],
          kbd: {
            bg: ["white", "black"],
            fg: ["700", "300"],
            border: ["200", "800"]
          },
          link: {
            fg: ["blue/700 70%", "blue/300 70%"]
          },
          muted: {
            bg: ["100", "950"],
            fg: ["700 75%", "300 75%"]
          },
          skeleton: {
            from: ["100", "900"],
            to: ["100 50%", "900 50%"]
          }
        },
        hovered: {
          bg: ["50", "900"],
          fg: ["800", "200"],
          icon: ["800 70%", "300 70%"]
        },
        pressed: {
          bg: ["100", "800"],
          fg: ["800", "200"],
          icon: ["800 70%", "200 70%"]
        },
        selected: {
          bg: ["100", "900"],
          fg: ["800", "200"],
          icon: ["800 60%", "200 60%"]
        },
        disabled: {
          _hue: "gray",
          accent: {
            fg: ["200", "800"]
          },
          avatar: {
            "*": {
              _blend: ["screen", "multiply"],
              bg: ["gray/100", "gray/900"],
              fg: ["white", "black"]
            }
          },
          badge: {
            "*": {
              _hue: "gray",
              bg: ["50", "950"],
              fg: ["gray/200", "gray/800"],
              dot: ["gray/200", "gray/800"],
              icon: ["gray/200", "gray/800"]
            }
          },
          code: {
            bg: ["50", "950"],
            fg: ["200", "800"]
          },
          fg: ["400", "600"],
          icon: ["300", "700"],
          muted: {
            fg: ["400", "600"]
          },
          kbd: {
            bg: ["white", "black"],
            fg: ["200", "800"],
            border: ["100", "900"]
          },
          link: {
            fg: ["200", "800"]
          }
        }
      }
    }
  },
  input: {
    "*": {
      "*": {
        _blend: ["multiply", "screen"],
        bg: ["white", "black"],
        border: ["200", "700"],
        fg: ["black", "200"],
        muted: {
          bg: ["50", "950"]
        },
        placeholder: ["400", "600"]
      },
      hovered: {
        border: ["300", "700"]
      },
      readOnly: {
        bg: ["50", "950"],
        border: ["200", "800"],
        fg: ["800", "200"]
      },
      disabled: {
        bg: ["50", "950"],
        fg: ["400", "600"],
        border: ["100", "900"],
        placeholder: ["200", "800 50%"]
      }
    },
    invalid: {
      "*": {
        _hue: "red",
        bg: ["100", "950"]
      }
    }
  },
  selectable: {
    "*": {
      "*": {
        _blend: ["multiply", "screen"],
        accent: {
          fg: ["purple/700 70%", "purple/300 70%"]
        },
        avatar: {
          "*": {
            _blend: ["screen", "multiply"],
            bg: ["500", "400"],
            fg: ["white", "black"]
          }
        },
        badge: {
          "*": {
            bg: ["100", "900"],
            fg: ["600", "400"],
            dot: ["500", "500"],
            icon: ["500", "500"]
          }
        },
        bg: ["white", "black"],
        border: ["200", "800"],
        code: {
          bg: ["50", "950"],
          fg: ["600", "400"]
        },
        fg: ["700", "300"],
        icon: ["700 75%", "300 75%"],
        kbd: {
          bg: ["white", "black"],
          fg: ["600", "400"],
          border: ["200", "800"]
        },
        link: {
          fg: ["blue/700 70%", "blue/300 70%"]
        },
        muted: {
          bg: ["50", "950"],
          fg: ["700 75%", "300 75%"]
        },
        skeleton: {
          from: ["100", "900"],
          to: ["100 50%", "900 50%"]
        }
      },
      hovered: {
        bg: ["50", "950"]
      },
      pressed: {
        bg: ["100", "900"]
      },
      selected: {
        _blend: ["screen", "multiply"],
        accent: {
          fg: ["purple/300", "purple/700"]
        },
        avatar: {
          "*": {
            _blend: ["multiply", "screen"],
            bg: ["white", "black"],
            fg: ["black", "white"]
          }
        },
        badge: {
          "*": {
            bg: ["900", "100"],
            fg: ["400", "600"],
            dot: ["500", "500"],
            icon: ["500", "500"]
          }
        },
        bg: ["500", "400"],
        border: ["500 20%", "400 20%"],
        code: {
          bg: ["500 20%", "400 20%"],
          fg: ["200", "600"]
        },
        fg: ["white", "black"],
        icon: ["100 70%", "900 70%"],
        kbd: {
          bg: ["black", "white"],
          fg: ["200", "600"],
          border: ["800", "200"]
        },
        link: {
          fg: ["blue/200", "blue/600"]
        },
        muted: {
          bg: ["500 10%", "400 10%"],
          fg: ["100 70%", "900 70%"]
        },
        skeleton: {
          from: ["900", "100"],
          to: ["900 50%", "100 50%"]
        }
      },
      disabled: {
        _hue: "gray",
        accent: {
          fg: ["200", "800"]
        },
        avatar: {
          "*": {
            _blend: ["screen", "multiply"],
            bg: ["gray/100", "gray/900"],
            fg: ["white", "black"]
          }
        },
        badge: {
          "*": {
            _hue: "gray",
            bg: ["50", "950"],
            fg: ["gray/200", "gray/800"],
            dot: ["gray/200", "gray/800"],
            icon: ["gray/200", "gray/800"]
          }
        },
        border: ["100", "900"],
        code: {
          bg: ["50", "950"],
          fg: ["200", "800"]
        },
        fg: ["200", "800"],
        icon: ["200", "800"],
        kbd: {
          bg: ["white", "black"],
          fg: ["200", "800"],
          border: ["100", "900"]
        },
        link: {
          fg: ["200", "800"]
        },
        muted: {
          bg: ["50 50%", "950 50%"],
          fg: ["200", "800"]
        }
      }
    },
    default: {
      selected: {
        _hue: "blue"
      }
    },
    critical: {
      disabled: {
        bg: ["50 50%", "950 50%"]
      }
    }
  },
  syntax: {
    atrule: ["purple/600", "purple/400"],
    attrName: ["green/600", "green/400"],
    attrValue: ["yellow/600", "yellow/400"],
    attribute: ["yellow/600", "yellow/400"],
    boolean: ["purple/600", "purple/400"],
    builtin: ["purple/600", "purple/400"],
    cdata: ["yellow/600", "yellow/400"],
    char: ["yellow/600", "yellow/400"],
    class: ["orange/600", "orange/400"],
    className: ["cyan/600", "cyan/400"],
    comment: ["gray/400", "gray/600"],
    constant: ["purple/600", "purple/400"],
    deleted: ["red/600", "red/400"],
    entity: ["red/600", "red/400"],
    function: ["green/600", "green/400"],
    hexcode: ["blue/600", "blue/400"],
    id: ["purple/600", "purple/400"],
    important: ["purple/600", "purple/400"],
    inserted: ["yellow/600", "yellow/400"],
    keyword: ["magenta/600", "magenta/400"],
    number: ["purple/600", "purple/400"],
    operator: ["magenta/600", "magenta/400"],
    property: ["blue/600", "blue/400"],
    pseudoClass: ["yellow/600", "yellow/400"],
    pseudoElement: ["yellow/600", "yellow/400"],
    punctuation: ["gray/600", "gray/400"],
    regex: ["blue/600", "blue/400"],
    selector: ["red/600", "red/400"],
    string: ["yellow/600", "yellow/400"],
    symbol: ["purple/600", "purple/400"],
    tag: ["red/600", "red/400"],
    unit: ["orange/600", "orange/400"],
    url: ["red/600", "red/400"],
    variable: ["red/600", "red/400"]
  }
};
function isRecord(value) {
  return !!(value && typeof value == "object" && !Array.isArray(value));
}
function merge(...records) {
  const _records = records.filter(Boolean);
  return _records.length === 0 ? {} : _records.reduce(_merge, {});
}
function _merge(acc, source) {
  for (const key2 of Object.keys(source)) {
    const prevValue = acc[key2], nextValue = source[key2];
    isRecord(prevValue) && isRecord(nextValue) ? acc[key2] = merge(prevValue, nextValue) : acc[key2] = nextValue;
  }
  return acc;
}
function resolveColorTokens(inputTokens) {
  const tokens = merge(defaultColorTokens, inputTokens);
  return {
    base: resolveBaseColorTokens(tokens),
    button: resolveButtonColorTokens(tokens),
    input: resolveInputColorTokens(tokens),
    selectable: resolveSelectableColorTokens(tokens),
    syntax: tokens.syntax
  };
}
function resolveBaseColorTokens(sparseTokens) {
  const tokens = {};
  for (const tone of THEME_COLOR_CARD_TONES)
    tokens[tone] = resolveBaseColorTones(sparseTokens, tone);
  return tokens;
}
function resolveBaseColorTones(inputTokens, tone) {
  var _a, _b, _c, _d;
  const spec = merge((_a = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _a["*"], (_b = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _b[tone]), hue = spec._hue || ((_d = (_c = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _c[tone]) == null ? void 0 : _d._hue) || "gray";
  return {
    ...spec,
    _hue: hue,
    avatar: COLOR_HUES.reduce((acc, hue2) => {
      var _a2, _b2;
      return {
        ...acc,
        [hue2]: merge({
          _hue: hue2
        }, (_a2 = spec.avatar) == null ? void 0 : _a2["*"], (_b2 = spec.avatar) == null ? void 0 : _b2[hue2])
      };
    }, {}),
    badge: THEME_COLOR_STATE_TONES.reduce((acc, tone2) => {
      var _a2, _b2, _c2, _d2;
      return {
        ...acc,
        [tone2]: {
          _hue: ((_b2 = (_a2 = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _a2[tone2]) == null ? void 0 : _b2._hue) || hue,
          ...(_c2 = spec.badge) == null ? void 0 : _c2["*"],
          ...(_d2 = spec.badge) == null ? void 0 : _d2[tone2]
        }
      };
    }, {})
  };
}
function resolveButtonColorTokens(inputTokens) {
  const tokens = {};
  for (const mode of THEME_COLOR_BUTTON_MODES)
    tokens[mode] = resolveButtonToneColorTokens(inputTokens, mode);
  return tokens;
}
function resolveButtonToneColorTokens(inputTokens, mode) {
  const tokens = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tokens[tone] = resolveButtonModeColorTokens(inputTokens, mode, tone);
  return tokens;
}
function resolveButtonModeColorTokens(inputTokens, mode, tone) {
  const tokens = {};
  for (const state of THEME_COLOR_STATES)
    tokens[state] = resolveButtonStateColorTokens(inputTokens, tone, mode, state);
  return tokens;
}
function resolveButtonStateColorTokens(inputTokens, tone, mode, state) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n;
  const spec = merge((_c = (_b = (_a = inputTokens == null ? void 0 : inputTokens.button) == null ? void 0 : _a[mode]) == null ? void 0 : _b["*"]) == null ? void 0 : _c["*"], (_f = (_e2 = (_d = inputTokens == null ? void 0 : inputTokens.button) == null ? void 0 : _d[mode]) == null ? void 0 : _e2[tone]) == null ? void 0 : _f["*"], (_i = (_h = (_g = inputTokens == null ? void 0 : inputTokens.button) == null ? void 0 : _g[mode]) == null ? void 0 : _h["*"]) == null ? void 0 : _i[state], (_l = (_k = (_j = inputTokens == null ? void 0 : inputTokens.button) == null ? void 0 : _j[mode]) == null ? void 0 : _k[tone]) == null ? void 0 : _l[state]), hue = spec._hue || ((_n = (_m = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _m[tone]) == null ? void 0 : _n._hue);
  return {
    ...spec,
    _hue: hue,
    avatar: COLOR_HUES.reduce((acc, hue2) => {
      var _a2, _b2;
      return {
        ...acc,
        [hue2]: merge({
          _hue: hue2
        }, (_a2 = spec.avatar) == null ? void 0 : _a2["*"], (_b2 = spec.avatar) == null ? void 0 : _b2[hue2])
      };
    }, {}),
    badge: THEME_COLOR_STATE_TONES.reduce((acc, tone2) => {
      var _a2, _b2, _c2, _d2;
      return {
        ...acc,
        [tone2]: {
          _hue: ((_b2 = (_a2 = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _a2[tone2]) == null ? void 0 : _b2._hue) || hue,
          ...(_c2 = spec.badge) == null ? void 0 : _c2["*"],
          ...(_d2 = spec.badge) == null ? void 0 : _d2[tone2]
        }
      };
    }, {})
  };
}
function resolveInputColorTokens(inputTokens) {
  const tokens = {};
  for (const mode of THEME_COLOR_INPUT_MODES)
    tokens[mode] = resolveInputModeColorTokens(inputTokens, mode);
  return tokens;
}
function resolveInputModeColorTokens(inputTokens, mode) {
  const states = {};
  for (const state of THEME_COLOR_INPUT_STATES)
    states[state] = resolveInputStateColorTokens(inputTokens, mode, state);
  return states;
}
function resolveInputStateColorTokens(inputTokens, mode, state) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j;
  const spec = merge((_b = (_a = inputTokens == null ? void 0 : inputTokens.input) == null ? void 0 : _a["*"]) == null ? void 0 : _b["*"], (_d = (_c = inputTokens == null ? void 0 : inputTokens.input) == null ? void 0 : _c[mode]) == null ? void 0 : _d["*"], (_f = (_e2 = inputTokens == null ? void 0 : inputTokens.input) == null ? void 0 : _e2["*"]) == null ? void 0 : _f[state], (_h = (_g = inputTokens == null ? void 0 : inputTokens.input) == null ? void 0 : _g[mode]) == null ? void 0 : _h[state]), hue = spec._hue || ((_j = (_i = inputTokens == null ? void 0 : inputTokens.input) == null ? void 0 : _i[mode]) == null ? void 0 : _j._hue);
  return {
    ...spec,
    _hue: hue
  };
}
function resolveSelectableColorTokens(inputTokens) {
  const tokens = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tokens[tone] = resolveSelectableToneColorTokens(inputTokens, tone);
  return tokens;
}
function resolveSelectableToneColorTokens(inputTokens, tone) {
  var _a, _b, _c, _d;
  const states = {
    _hue: ((_b = (_a = inputTokens == null ? void 0 : inputTokens.selectable) == null ? void 0 : _a[tone]) == null ? void 0 : _b._hue) || ((_d = (_c = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _c[tone]) == null ? void 0 : _d._hue)
  };
  for (const state of THEME_COLOR_STATES)
    states[state] = resolveSelectableStateColorTokens(inputTokens, tone, state);
  return states;
}
function resolveSelectableStateColorTokens(inputTokens, tone, state) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j;
  const spec = merge((_b = (_a = inputTokens == null ? void 0 : inputTokens.selectable) == null ? void 0 : _a["*"]) == null ? void 0 : _b["*"], (_d = (_c = inputTokens == null ? void 0 : inputTokens.selectable) == null ? void 0 : _c[tone]) == null ? void 0 : _d["*"], (_f = (_e2 = inputTokens == null ? void 0 : inputTokens.selectable) == null ? void 0 : _e2["*"]) == null ? void 0 : _f[state], (_h = (_g = inputTokens == null ? void 0 : inputTokens.selectable) == null ? void 0 : _g[tone]) == null ? void 0 : _h[state]), hue = spec._hue || ((_j = (_i = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _i[tone]) == null ? void 0 : _j._hue);
  return {
    ...spec,
    _hue: hue,
    avatar: COLOR_HUES.reduce((acc, hue2) => {
      var _a2, _b2;
      return {
        ...acc,
        [hue2]: merge({
          _hue: hue2
        }, (_a2 = spec.avatar) == null ? void 0 : _a2["*"], (_b2 = spec.avatar) == null ? void 0 : _b2[hue2])
      };
    }, {}),
    badge: THEME_COLOR_STATE_TONES.reduce((acc, tone2) => {
      var _a2, _b2, _c2, _d2;
      return {
        ...acc,
        [tone2]: {
          _hue: ((_b2 = (_a2 = inputTokens == null ? void 0 : inputTokens.base) == null ? void 0 : _a2[tone2]) == null ? void 0 : _b2._hue) || hue,
          ...(_c2 = spec.badge) == null ? void 0 : _c2["*"],
          ...(_d2 = spec.badge) == null ? void 0 : _d2[tone2]
        }
      };
    }, {})
  };
}
function buildColorTheme(config) {
  const resolvedConfig = {
    color: resolveColorTokens(config == null ? void 0 : config.color)
  };
  return {
    light: buildColorScheme({
      scheme: "light"
    }, resolvedConfig),
    dark: buildColorScheme({
      scheme: "dark"
    }, resolvedConfig)
  };
}
function buildColorScheme(options, config) {
  const {
    scheme
  } = options, colorScheme = {};
  for (const tone of THEME_COLOR_CARD_TONES)
    colorScheme[tone] = buildCardColorTheme({
      scheme,
      tone
    }, config);
  return colorScheme;
}
function buildCardColorTheme(options, config) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m;
  const {
    scheme,
    tone
  } = options, tokens = (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.base) == null ? void 0 : _b[tone], context = {
    hue: (tokens == null ? void 0 : tokens._hue) || "gray",
    scheme
  };
  return {
    _blend: ((tokens == null ? void 0 : tokens._blend) || ["multiply", "screen"])[scheme === "light" ? 0 : 1],
    _dark: scheme === "dark",
    accent: {
      fg: resolveColorTokenValue(context, (_c = tokens == null ? void 0 : tokens.accent) == null ? void 0 : _c.fg)
    },
    avatar: buildAvatarColorTheme({
      scheme
    }, tokens),
    backdrop: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.backdrop),
    badge: buildBadgeColorTheme(tokens == null ? void 0 : tokens.badge, {
      scheme
    }, config),
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    border: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.border),
    button: buildButtonColorTheme({
      scheme,
      tone
    }, config),
    code: {
      bg: resolveColorTokenValue(context, (_d = tokens == null ? void 0 : tokens.code) == null ? void 0 : _d.bg),
      fg: resolveColorTokenValue(context, (_e2 = tokens == null ? void 0 : tokens.code) == null ? void 0 : _e2.fg)
    },
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg),
    focusRing: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.focusRing),
    icon: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.icon),
    input: buildInputColorTheme({
      scheme,
      tone
    }, config),
    kbd: {
      bg: resolveColorTokenValue(context, (_f = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _f.bg),
      fg: resolveColorTokenValue(context, (_g = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _g.fg),
      border: resolveColorTokenValue(context, (_h = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _h.border)
    },
    link: {
      fg: resolveColorTokenValue(context, (_i = tokens == null ? void 0 : tokens.link) == null ? void 0 : _i.fg)
    },
    muted: {
      bg: resolveColorTokenValue(context, (_j = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _j.bg),
      fg: resolveColorTokenValue(context, (_k = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _k.fg)
    },
    selectable: buildSelectableColorTheme({
      scheme,
      tone
    }, config),
    shadow: buildShadowColorTheme({
      scheme,
      tone
    }, config),
    skeleton: {
      from: resolveColorTokenValue(context, (_l = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _l.from),
      to: resolveColorTokenValue(context, (_m = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _m.to)
    },
    syntax: buildSyntaxColorTheme({
      scheme
    }, config)
  };
}
function buildShadowColorTheme(options, config) {
  var _a, _b, _c, _d, _e2, _f;
  const {
    scheme,
    tone
  } = options, tokens = (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.base) == null ? void 0 : _b[tone], context = {
    hue: (tokens == null ? void 0 : tokens._hue) || "gray",
    scheme
  };
  return {
    outline: resolveColorTokenValue(context, (_c = tokens == null ? void 0 : tokens.shadow) == null ? void 0 : _c.outline),
    umbra: resolveColorTokenValue(context, (_d = tokens == null ? void 0 : tokens.shadow) == null ? void 0 : _d.umbra),
    penumbra: resolveColorTokenValue(context, (_e2 = tokens == null ? void 0 : tokens.shadow) == null ? void 0 : _e2.penumbra),
    ambient: resolveColorTokenValue(context, (_f = tokens == null ? void 0 : tokens.shadow) == null ? void 0 : _f.ambient)
  };
}
function buildAvatarColorTheme(options, stateTokens) {
  const {
    scheme
  } = options;
  return {
    gray: _buildAvatarColorTheme({
      color: "gray",
      scheme
    }, stateTokens),
    blue: _buildAvatarColorTheme({
      color: "blue",
      scheme
    }, stateTokens),
    purple: _buildAvatarColorTheme({
      color: "purple",
      scheme
    }, stateTokens),
    magenta: _buildAvatarColorTheme({
      color: "magenta",
      scheme
    }, stateTokens),
    red: _buildAvatarColorTheme({
      color: "red",
      scheme
    }, stateTokens),
    orange: _buildAvatarColorTheme({
      color: "orange",
      scheme
    }, stateTokens),
    yellow: _buildAvatarColorTheme({
      color: "yellow",
      scheme
    }, stateTokens),
    green: _buildAvatarColorTheme({
      color: "green",
      scheme
    }, stateTokens),
    cyan: _buildAvatarColorTheme({
      color: "cyan",
      scheme
    }, stateTokens)
  };
}
function _buildAvatarColorTheme(options, stateTokens) {
  var _a;
  const {
    color: color22,
    scheme
  } = options, tokens = (_a = stateTokens == null ? void 0 : stateTokens.avatar) == null ? void 0 : _a[color22], context = {
    hue: (tokens == null ? void 0 : tokens._hue) || "gray",
    scheme
  };
  return {
    _blend: ((tokens == null ? void 0 : tokens._blend) || ["screen", "multiply"])[scheme === "light" ? 0 : 1],
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg)
  };
}
function buildBadgeColorTheme(tokens, options, config) {
  const {
    scheme
  } = options, colorBadge = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    colorBadge[tone] = _buildBadgeColorTheme(tokens, {
      scheme,
      tone
    }, config);
  return colorBadge;
}
function _buildBadgeColorTheme(parentTokens, options, config) {
  var _a, _b, _c;
  const {
    scheme,
    tone
  } = options, tokens = parentTokens == null ? void 0 : parentTokens[tone], context = {
    hue: (tokens == null ? void 0 : tokens._hue) || ((_c = (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.base) == null ? void 0 : _b[tone]) == null ? void 0 : _c._hue) || "gray",
    scheme
  };
  return {
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg),
    dot: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.dot),
    icon: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.icon)
  };
}
function buildButtonColorTheme(options, config) {
  const {
    scheme,
    tone: cardTone
  } = options, modes = {};
  for (const mode of THEME_COLOR_BUTTON_MODES)
    modes[mode] = buildButtonTonesColorTheme({
      cardTone,
      scheme,
      mode
    }, config);
  return modes;
}
function buildButtonTonesColorTheme(options, config) {
  const {
    cardTone,
    mode,
    scheme
  } = options, tones2 = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tones2[tone] = buildButtonStatesColorTheme({
      cardTone,
      mode,
      scheme,
      tone
    }, config);
  return tones2;
}
function buildButtonStatesColorTheme(options, config) {
  const {
    cardTone,
    mode,
    scheme,
    tone
  } = options, states = {};
  for (const state of THEME_COLOR_STATES)
    states[state] = buildButtonStateColorTheme({
      cardTone,
      mode,
      tone,
      scheme,
      state
    }, config);
  return states;
}
function buildButtonStateColorTheme(options, config) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
  const {
    cardTone,
    mode,
    tone,
    scheme,
    state
  } = options, cardTokens = (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.base) == null ? void 0 : _b[cardTone], tokens = (_f = (_e2 = (_d = (_c = config == null ? void 0 : config.color) == null ? void 0 : _c.button) == null ? void 0 : _d[mode]) == null ? void 0 : _e2[tone]) == null ? void 0 : _f[state], hue = (tokens == null ? void 0 : tokens._hue) || (cardTokens == null ? void 0 : cardTokens._hue) || "gray", blendMode = (tokens == null ? void 0 : tokens._blend) || ["screen", "multiply"], context = {
    hue,
    scheme
  };
  return {
    _blend: blendMode[scheme === "light" ? 0 : 1],
    accent: {
      fg: resolveColorTokenValue(context, (_g = tokens == null ? void 0 : tokens.accent) == null ? void 0 : _g.fg)
    },
    avatar: buildAvatarColorTheme({
      scheme
    }, tokens),
    badge: buildBadgeColorTheme(tokens == null ? void 0 : tokens.badge, {
      scheme
    }, config),
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    border: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.border),
    code: {
      bg: resolveColorTokenValue(context, (_h = tokens == null ? void 0 : tokens.code) == null ? void 0 : _h.bg),
      fg: resolveColorTokenValue(context, (_i = tokens == null ? void 0 : tokens.code) == null ? void 0 : _i.fg)
    },
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg),
    icon: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.icon),
    muted: {
      bg: resolveColorTokenValue(context, (_j = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _j.bg),
      fg: resolveColorTokenValue(context, (_k = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _k.fg)
    },
    kbd: {
      bg: resolveColorTokenValue(context, (_l = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _l.bg),
      fg: resolveColorTokenValue(context, (_m = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _m.fg),
      border: resolveColorTokenValue(context, (_n = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _n.border)
    },
    link: {
      fg: resolveColorTokenValue(context, (_o = tokens == null ? void 0 : tokens.link) == null ? void 0 : _o.fg)
    },
    skeleton: {
      from: resolveColorTokenValue(context, (_p = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _p.from),
      to: resolveColorTokenValue(context, (_q = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _q.to)
    }
  };
}
function buildInputColorTheme(options, config) {
  const {
    scheme,
    tone
  } = options;
  return {
    default: buildInputStatesColorTheme({
      mode: "default",
      scheme,
      tone
    }, config),
    invalid: buildInputStatesColorTheme({
      mode: "invalid",
      scheme,
      tone
    }, config)
  };
}
function buildInputStatesColorTheme(options, config) {
  const {
    mode,
    scheme,
    tone
  } = options;
  return {
    enabled: buildInputStateColorTheme({
      mode,
      scheme,
      state: "enabled",
      cardTone: tone
    }, config),
    hovered: buildInputStateColorTheme({
      mode,
      scheme,
      state: "hovered",
      cardTone: tone
    }, config),
    readOnly: buildInputStateColorTheme({
      mode,
      scheme,
      state: "readOnly",
      cardTone: tone
    }, config),
    disabled: buildInputStateColorTheme({
      mode,
      scheme,
      state: "disabled",
      cardTone: tone
    }, config)
  };
}
function buildInputStateColorTheme(options, config) {
  var _a, _b, _c, _d, _e2, _f;
  const {
    cardTone,
    mode,
    scheme,
    state
  } = options, cardTokens = (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.base) == null ? void 0 : _b[cardTone], tokens = (_e2 = (_d = (_c = config == null ? void 0 : config.color) == null ? void 0 : _c.input) == null ? void 0 : _d[mode]) == null ? void 0 : _e2[state], hue = (tokens == null ? void 0 : tokens._hue) || (cardTokens == null ? void 0 : cardTokens._hue) || "gray", blendMode = (tokens == null ? void 0 : tokens._blend) || ["screen", "multiply"], context = {
    hue,
    scheme
  };
  return {
    _blend: blendMode[scheme === "light" ? 0 : 1],
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    border: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.border),
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg),
    muted: {
      bg: resolveColorTokenValue(context, (_f = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _f.bg)
    },
    placeholder: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.placeholder)
  };
}
function buildSelectableColorTheme(options, config) {
  const {
    scheme,
    tone: cardTone
  } = options, tones2 = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    tones2[tone] = buildSelectableStatesColorTheme({
      cardTone,
      scheme,
      tone
    }, config);
  return tones2;
}
function buildSelectableStatesColorTheme(options, config) {
  const {
    cardTone,
    scheme,
    tone
  } = options, states = {};
  for (const state of THEME_COLOR_STATES)
    states[state] = buildSelectableStateColorTheme({
      cardTone,
      tone,
      scheme,
      state
    }, config);
  return states;
}
function buildSelectableStateColorTheme(options, config) {
  var _a, _b, _c, _d, _e2, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  const {
    cardTone,
    scheme,
    state,
    tone
  } = options, cardTokens = (_b = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.base) == null ? void 0 : _b[cardTone], tokens = (_e2 = (_d = (_c = config == null ? void 0 : config.color) == null ? void 0 : _c.selectable) == null ? void 0 : _d[tone]) == null ? void 0 : _e2[state], hue = (tokens == null ? void 0 : tokens._hue) || (cardTokens == null ? void 0 : cardTokens._hue) || "gray", blendMode = (tokens == null ? void 0 : tokens._blend) || ["screen", "multiply"], context = {
    hue,
    scheme
  };
  return {
    _blend: blendMode[scheme === "light" ? 0 : 1],
    accent: {
      fg: resolveColorTokenValue(context, (_f = tokens == null ? void 0 : tokens.accent) == null ? void 0 : _f.fg)
    },
    avatar: buildAvatarColorTheme({
      scheme
    }, tokens),
    badge: buildBadgeColorTheme(tokens == null ? void 0 : tokens.badge, {
      scheme
    }, config),
    bg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.bg),
    border: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.border),
    code: {
      bg: resolveColorTokenValue(context, (_g = tokens == null ? void 0 : tokens.code) == null ? void 0 : _g.bg),
      fg: resolveColorTokenValue(context, (_h = tokens == null ? void 0 : tokens.code) == null ? void 0 : _h.fg)
    },
    fg: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.fg),
    icon: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.icon),
    muted: {
      bg: resolveColorTokenValue(context, (_i = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _i.bg),
      fg: resolveColorTokenValue(context, (_j = tokens == null ? void 0 : tokens.muted) == null ? void 0 : _j.fg)
    },
    kbd: {
      bg: resolveColorTokenValue(context, (_k = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _k.bg),
      fg: resolveColorTokenValue(context, (_l = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _l.fg),
      border: resolveColorTokenValue(context, (_m = tokens == null ? void 0 : tokens.kbd) == null ? void 0 : _m.border)
    },
    link: {
      fg: resolveColorTokenValue(context, (_n = tokens == null ? void 0 : tokens.link) == null ? void 0 : _n.fg)
    },
    skeleton: {
      from: resolveColorTokenValue(context, (_o = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _o.from),
      to: resolveColorTokenValue(context, (_p = tokens == null ? void 0 : tokens.skeleton) == null ? void 0 : _p.to)
    }
  };
}
function buildSyntaxColorTheme(options, config) {
  var _a;
  const {
    scheme
  } = options, tokens = (_a = config == null ? void 0 : config.color) == null ? void 0 : _a.syntax, context = {
    hue: "gray",
    scheme
  };
  return {
    atrule: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.atrule),
    attrName: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.attrName),
    attrValue: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.attrValue),
    attribute: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.attribute),
    boolean: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.boolean),
    builtin: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.builtin),
    cdata: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.cdata),
    char: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.char),
    class: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.class),
    className: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.className),
    comment: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.comment),
    constant: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.constant),
    deleted: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.deleted),
    doctype: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.doctype),
    entity: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.entity),
    function: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.function),
    hexcode: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.hexcode),
    id: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.id),
    important: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.important),
    inserted: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.inserted),
    keyword: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.keyword),
    number: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.number),
    operator: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.operator),
    prolog: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.prolog),
    property: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.property),
    pseudoClass: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.pseudoClass),
    pseudoElement: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.pseudoElement),
    punctuation: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.punctuation),
    regex: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.regex),
    selector: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.selector),
    string: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.string),
    symbol: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.symbol),
    tag: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.tag),
    unit: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.unit),
    url: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.url),
    variable: resolveColorTokenValue(context, tokens == null ? void 0 : tokens.variable)
  };
}
var defaultColorPalette = color;
function mixChannel(b2, s2, weight) {
  const delta = (s2 - b2) * weight;
  return b2 + delta;
}
function mix(b2, s2, weight) {
  return {
    r: mixChannel(b2.r, s2.r, weight),
    g: mixChannel(b2.g, s2.g, weight),
    b: mixChannel(b2.b, s2.b, weight)
  };
}
function multiplyChannel(b2, s2) {
  return b2 * s2;
}
function multiply(b2, s2) {
  return {
    r: multiplyChannel(b2.r / 255, s2.r / 255) * 255,
    g: multiplyChannel(b2.g / 255, s2.g / 255) * 255,
    b: multiplyChannel(b2.b / 255, s2.b / 255) * 255
  };
}
function screenChannel(b2, s2) {
  return b2 + s2 - b2 * s2;
}
function screen(b2, s2) {
  return {
    r: screenChannel(b2.r / 255, s2.r / 255) * 255,
    g: screenChannel(b2.g / 255, s2.g / 255) * 255,
    b: screenChannel(b2.b / 255, s2.b / 255) * 255
  };
}
function lerp(x2, y2, a2) {
  return x2 * (1 - a2) + y2 * a2;
}
function invlerp(x2, y2, a2) {
  return clamp((a2 - x2) / (y2 - x2));
}
function clamp(a2, min2 = 0, max2 = 1) {
  return Math.min(max2, Math.max(min2, a2));
}
function range(x1, y1, x2, y2, a2) {
  return lerp(x2, y2, invlerp(x1, y1, a2));
}
function round(value) {
  return Math.round(value);
}
function hexToRgb(hex2) {
  if (hex2.length === 4) {
    const hexR = hex2.slice(1, 2), hexG = hex2.slice(2, 3), hexB = hex2.slice(3, 4);
    return {
      r: parseInt(hexR + hexR, 16),
      g: parseInt(hexG + hexG, 16),
      b: parseInt(hexB + hexB, 16)
    };
  }
  return {
    r: parseInt(hex2.slice(1, 3), 16),
    g: parseInt(hex2.slice(3, 5), 16),
    b: parseInt(hex2.slice(5, 7), 16)
  };
}
function rgbaToRGBA(rgba22) {
  const values = rgba22.replace(/rgba\(|\)/g, "").split(",");
  return {
    r: parseInt(values[0]),
    g: parseInt(values[1]),
    b: parseInt(values[2]),
    a: parseFloat(values[3])
  };
}
function rgbToHex(color22) {
  const r2 = round(clamp(Math.round(color22.r), 0, 255)), g2 = round(clamp(Math.round(color22.g), 0, 255)), b2 = round(clamp(Math.round(color22.b), 0, 255));
  return "a" in color22 ? `rgba(${r2},${g2},${b2},${color22.a})` : "#" + ((1 << 24) + (r2 << 16) + (g2 << 8) + b2).toString(16).slice(1);
}
function hslToRgb(hsl) {
  const s2 = hsl.s / 100, l2 = hsl.l / 100, c4 = (1 - Math.abs(2 * l2 - 1)) * s2, x2 = c4 * (1 - Math.abs(hsl.h / 60 % 2 - 1)), m3 = l2 - c4 / 2;
  let r2 = 0, g2 = 0, b2 = 0;
  return 0 <= hsl.h && hsl.h < 60 ? (r2 = c4, g2 = x2, b2 = 0) : 60 <= hsl.h && hsl.h < 120 ? (r2 = x2, g2 = c4, b2 = 0) : 120 <= hsl.h && hsl.h < 180 ? (r2 = 0, g2 = c4, b2 = x2) : 180 <= hsl.h && hsl.h < 240 ? (r2 = 0, g2 = x2, b2 = c4) : 240 <= hsl.h && hsl.h < 300 ? (r2 = x2, g2 = 0, b2 = c4) : 300 <= hsl.h && hsl.h < 360 && (r2 = c4, g2 = 0, b2 = x2), {
    r: Math.round((r2 + m3) * 255),
    g: Math.round((g2 + m3) * 255),
    b: Math.round((b2 + m3) * 255)
  };
}
var HEX_CHARS = "0123456789ABCDEFabcdef";
var HSL_RE = /hsl\(\s*(\d+)\s*,\s*((\d+(?:\.\d+)?)%)\s*,\s*((\d+(?:\.\d+)?)%)\s*\)/i;
function isHexChars(str) {
  for (const c4 of str)
    if (HEX_CHARS.indexOf(c4) === -1)
      return false;
  return true;
}
function isHex(str) {
  return str[0] !== "#" || !(str.length === 4 || str.length === 7) ? false : isHexChars(str.slice(1));
}
function parseHsl(str) {
  const res = HSL_RE.exec(str);
  if (!res)
    throw new Error(`parseHsl: string is not a HSL color: "${str}"`);
  return {
    h: parseInt(res[1]),
    s: parseFloat(res[3]),
    l: parseFloat(res[5])
  };
}
function parseColor(color22) {
  if (!color22) return {
    r: 0,
    g: 0,
    b: 0
  };
  if (typeof color22 != "string")
    throw new Error("parseColor: expected a string");
  if (isHex(color22))
    return hexToRgb(color22);
  if (color22.startsWith("hsl("))
    return hslToRgb(parseHsl(color22));
  if (color22.startsWith("rgba("))
    return rgbaToRGBA(color22);
  throw new Error(`parseColor: unexpected color format: "${color22}"`);
}
function rgba(color22, a2) {
  const rgb = parseColor(color22);
  return `rgba(${rgb.r},${rgb.g},${rgb.b},${a2})`;
}
var RGB_RANGE = [0, 255];
function mixThemeColor(value, options) {
  const {
    blendMode
  } = options, color22 = parseColor(value), black22 = parseColor(options.black), white22 = parseColor(options.white), bg = options.bg ? parseColor(options.bg) : blendMode === "multiply" ? white22 : black22, paletteRange = {
    r: [black22.r, white22.r],
    g: [black22.g, white22.g],
    b: [black22.b, white22.b]
  }, convertedBgColor = {
    r: clamp(range(...paletteRange.r, ...RGB_RANGE, bg.r), ...RGB_RANGE),
    g: clamp(range(...paletteRange.g, ...RGB_RANGE, bg.g), ...RGB_RANGE),
    b: clamp(range(...paletteRange.b, ...RGB_RANGE, bg.b), ...RGB_RANGE)
  }, convertedColor = {
    r: clamp(range(...paletteRange.r, ...RGB_RANGE, color22.r), ...RGB_RANGE),
    g: clamp(range(...paletteRange.g, ...RGB_RANGE, color22.g), ...RGB_RANGE),
    b: clamp(range(...paletteRange.b, ...RGB_RANGE, color22.b), ...RGB_RANGE)
  }, resultColor = blendMode === "multiply" ? multiply(convertedBgColor, convertedColor) : screen(convertedBgColor, convertedColor), v2 = {
    r: clamp(range(...RGB_RANGE, ...paletteRange.r, resultColor.r), ...paletteRange.r),
    g: clamp(range(...RGB_RANGE, ...paletteRange.g, resultColor.g), ...paletteRange.g),
    b: clamp(range(...RGB_RANGE, ...paletteRange.b, resultColor.b), ...paletteRange.b)
  };
  return rgbToHex(v2);
}
function renderColorValue(str, options) {
  const {
    bg,
    blendMode,
    colorPalette
  } = options;
  if (bg === "white")
    throw new Error("Cannot blend with white background");
  const node2 = parseTokenValue(str);
  if (!node2 || node2.type !== "color")
    throw new Error(`Invalid color token value: ${str}`);
  let hex2 = "";
  if (node2.key === "black" && (hex2 = renderColorHex(colorPalette.black)), node2.key === "white" && (hex2 = renderColorHex(colorPalette.white)), node2.hue && node2.tint && (hex2 = renderColorHex(colorPalette[node2.hue][node2.tint])), !hex2)
    throw new Error(`Invalid color token value: ${str}`);
  const hexBeforeMix = hex2, mixOptions = {
    blendMode,
    bg,
    black: renderColorHex(colorPalette.black),
    // opacity: node.opacity,
    white: renderColorHex(colorPalette.white)
  };
  try {
    if (hex2 = mixThemeColor(hex2, mixOptions), bg && node2.mix !== void 0) {
      const from2 = hexToRgb(bg), to = hexToRgb(hex2);
      hex2 = rgbToHex(mix(from2, to, node2.mix));
    }
  } catch (err) {
    throw console.warn("could not blend", hex2, mixOptions), err;
  }
  return hex2 === "#aN" && (console.warn(`invalid color token value: ${str}`), hex2 = hexBeforeMix), node2.opacity !== void 0 && (hex2 = rgba(hex2, node2.opacity)), hex2;
}
function renderColorHex(color22) {
  return typeof color22 == "string" ? color22 : color22.hex;
}
function renderThemeColorSchemes(value, config) {
  const colorPalette = (config == null ? void 0 : config.palette) ?? defaultColorPalette;
  return {
    light: renderThemeColorScheme(colorPalette, value.light),
    dark: renderThemeColorScheme(colorPalette, value.dark)
  };
}
function renderThemeColorScheme(colorPalette, value) {
  const toneEntries = Object.entries(value), [, transparentTone] = toneEntries.find(([k2]) => k2 === "transparent"), [, defaultTone] = toneEntries.find(([k2]) => k2 === "default"), renderedTransparentTone = renderThemeColor(transparentTone, {
    colorPalette
  }), renderedDefaultTone = renderThemeColor(defaultTone, {
    colorPalette
  }), bg = renderedDefaultTone.bg;
  if (bg === "white")
    throw new Error("Cannot blend with white background");
  return Object.fromEntries([["transparent", renderedTransparentTone], ["default", renderedDefaultTone], ...toneEntries.filter(([k2]) => k2 !== "default" && k2 !== "transparent").map(([k2, v2]) => [k2, renderThemeColor(v2, {
    bg,
    colorPalette
  })])]);
}
function renderThemeColor(value, options) {
  const {
    colorPalette,
    bg
  } = options, blendMode = value._blend || "multiply", baseBg = renderColorValue(value.bg, {
    colorPalette,
    bg,
    blendMode
  }), colorOptions = {
    colorPalette,
    bg: baseBg,
    blendMode
  }, button = renderThemeColorButton(value.button, {
    baseBg,
    blendMode,
    colorPalette
  }), selectable = renderThemeColorSelectable(value.selectable, {
    colorPalette,
    baseBg,
    blendMode
  }), shadow = {
    outline: renderColorValue(value.shadow.outline, colorOptions),
    umbra: renderColorValue(value.shadow.umbra, {
      ...colorOptions,
      bg: void 0,
      colorPalette: {
        ...colorPalette,
        black: "#000000"
      }
    }),
    penumbra: renderColorValue(value.shadow.penumbra, {
      ...colorOptions,
      bg: void 0,
      colorPalette: {
        ...colorPalette,
        black: "#000000"
      }
    }),
    ambient: renderColorValue(value.shadow.ambient, {
      ...colorOptions,
      bg: void 0,
      colorPalette: {
        ...colorPalette,
        black: "#000000"
      }
    })
  };
  return {
    _blend: blendMode,
    _dark: value._dark,
    accent: {
      fg: renderColorValue(value.accent.fg, colorOptions)
    },
    avatar: renderThemeColorAvatar(value.avatar, {
      baseBg,
      colorPalette,
      blendMode
    }),
    backdrop: renderColorValue(value.backdrop, colorOptions),
    badge: renderThemeColorBadge(value.badge, {
      baseBg,
      colorPalette,
      blendMode
    }),
    bg: baseBg,
    border: renderColorValue(value.border, colorOptions),
    button,
    code: {
      bg: renderColorValue(value.code.bg, colorOptions),
      fg: renderColorValue(value.code.fg, colorOptions)
    },
    fg: renderColorValue(value.fg, colorOptions),
    focusRing: renderColorValue(value.focusRing, colorOptions),
    icon: renderColorValue(value.icon, colorOptions),
    input: renderThemeColorInput(value.input, {
      baseBg,
      colorPalette,
      blendMode
    }),
    kbd: renderThemeColorKBD(value.kbd, {
      baseBg,
      colorPalette,
      blendMode
    }),
    link: {
      fg: renderColorValue(value.link.fg, colorOptions)
    },
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions),
      fg: renderColorValue(value.muted.fg, colorOptions)
    },
    shadow,
    skeleton: {
      from: renderColorValue(value.skeleton.from, colorOptions),
      to: renderColorValue(value.skeleton.to, colorOptions)
    },
    syntax: renderSyntaxColorTheme(value.syntax, {
      baseBg,
      colorPalette,
      blendMode
    }),
    selectable
  };
}
function renderThemeColorKBD(value, options) {
  const {
    baseBg,
    blendMode,
    colorPalette
  } = options, rootOptions = {
    bg: baseBg,
    blendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    bg,
    fg: renderColorValue(value.fg, colorOptions),
    border: renderColorValue(value.border, colorOptions)
  };
}
function renderThemeColorAvatar(value, options) {
  const colorAvatar = {};
  for (const hue of COLOR_HUES)
    colorAvatar[hue] = renderThemeColorAvatarColor(value[hue], options);
  return colorAvatar;
}
function renderThemeColorAvatarColor(value, options) {
  const {
    baseBg,
    blendMode: rootBlendMode,
    colorPalette
  } = options, blendMode = value._blend || "multiply", rootOptions = {
    bg: baseBg,
    blendMode: rootBlendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    _blend: blendMode,
    bg,
    fg: renderColorValue(value.fg, colorOptions)
  };
}
function renderThemeColorBadge(value, options) {
  const colorBadge = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    colorBadge[tone] = renderThemeColorBadgeColor(value[tone], options);
  return colorBadge;
}
function renderThemeColorBadgeColor(value, options) {
  const {
    baseBg,
    blendMode: rootBlendMode,
    colorPalette
  } = options, blendMode = rootBlendMode, rootOptions = {
    bg: baseBg,
    blendMode: rootBlendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    bg,
    dot: renderColorValue(value.dot, colorOptions),
    fg: renderColorValue(value.fg, colorOptions),
    icon: renderColorValue(value.icon, colorOptions)
  };
}
function renderThemeColorButton(value, options) {
  return {
    default: renderThemeColorButtonTones(value.default, options),
    ghost: renderThemeColorButtonTones(value.ghost, options),
    bleed: renderThemeColorButtonTones(value.bleed, options)
  };
}
function renderThemeColorButtonTones(value, options) {
  const colorButtonMode = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    colorButtonMode[tone] = renderThemeColorButtonStates(value[tone], options);
  return colorButtonMode;
}
function renderThemeColorButtonStates(value, options) {
  return {
    enabled: renderThemeColorState(value.enabled, options),
    hovered: renderThemeColorState(value.hovered, options),
    pressed: renderThemeColorState(value.pressed, options),
    selected: renderThemeColorState(value.selected, options),
    disabled: renderThemeColorState(value.disabled, options)
  };
}
function renderThemeColorState(value, options) {
  var _a, _b;
  const {
    baseBg,
    blendMode: rootBlendMode,
    colorPalette
  } = options, blendMode = value._blend || "multiply", rootOptions = {
    bg: baseBg,
    blendMode: rootBlendMode,
    colorPalette
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    bg,
    blendMode,
    colorPalette
  };
  return {
    _blend: blendMode,
    accent: {
      fg: renderColorValue(value.accent.fg, colorOptions)
    },
    avatar: renderThemeColorAvatar(value.avatar, {
      baseBg: bg,
      colorPalette,
      blendMode
    }),
    badge: renderThemeColorBadge(value.badge, {
      baseBg: bg,
      colorPalette,
      blendMode
    }),
    bg,
    border: renderColorValue(value.border, colorOptions),
    code: {
      bg: renderColorValue(value.code.bg, colorOptions),
      fg: renderColorValue(value.code.fg, colorOptions)
    },
    fg: renderColorValue(value.fg, colorOptions),
    icon: renderColorValue(value.icon, colorOptions),
    link: {
      fg: renderColorValue(value.link.fg, colorOptions)
    },
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions),
      fg: renderColorValue(value.muted.fg, colorOptions)
    },
    kbd: {
      bg: renderColorValue(value.kbd.bg, colorOptions),
      fg: renderColorValue(value.kbd.fg, colorOptions),
      border: renderColorValue(value.kbd.border, colorOptions)
    },
    skeleton: {
      from: renderColorValue((_a = value.skeleton) == null ? void 0 : _a.from, colorOptions),
      to: renderColorValue((_b = value.skeleton) == null ? void 0 : _b.to, colorOptions)
    }
  };
}
function renderThemeColorInput(value, options) {
  return {
    default: renderInputStatesColorTheme(value.default, options),
    invalid: renderInputStatesColorTheme(value.invalid, options)
  };
}
function renderInputStatesColorTheme(value, options) {
  return {
    enabled: renderInputStateColorTheme(value.enabled, options),
    hovered: renderInputStateColorTheme(value.hovered, options),
    readOnly: renderInputStateColorTheme(value.readOnly, options),
    disabled: renderInputStateColorTheme(value.disabled, options)
  };
}
function renderInputStateColorTheme(value, options) {
  const {
    baseBg,
    blendMode: rootBlendMode,
    colorPalette
  } = options, blendMode = value._blend || "multiply", rootOptions = {
    colorPalette,
    bg: baseBg,
    blendMode: rootBlendMode
  }, bg = renderColorValue(value.bg, rootOptions), colorOptions = {
    colorPalette,
    bg,
    blendMode
  };
  return {
    _blend: blendMode,
    bg,
    border: renderColorValue(value.border, colorOptions),
    fg: renderColorValue(value.fg, colorOptions),
    muted: {
      bg: renderColorValue(value.muted.bg, colorOptions)
    },
    placeholder: renderColorValue(value.placeholder, colorOptions)
  };
}
function renderThemeColorSelectable(value, options) {
  const colorSelectable = {};
  for (const tone of THEME_COLOR_STATE_TONES)
    colorSelectable[tone] = renderThemeColorSelectableStates(value[tone], options);
  return colorSelectable;
}
function renderThemeColorSelectableStates(value, options) {
  return {
    enabled: renderThemeColorState(value.enabled, options),
    hovered: renderThemeColorState(value.hovered, options),
    pressed: renderThemeColorState(value.pressed, options),
    selected: renderThemeColorState(value.selected, options),
    disabled: renderThemeColorState(value.disabled, options)
  };
}
function renderSyntaxColorTheme(value, options) {
  const {
    colorPalette,
    baseBg,
    blendMode
  } = options, colorOptions = {
    colorPalette,
    bg: baseBg,
    blendMode
  };
  return {
    atrule: renderColorValue(value.atrule, colorOptions),
    attrName: renderColorValue(value.attrName, colorOptions),
    attrValue: renderColorValue(value.attrValue, colorOptions),
    attribute: renderColorValue(value.attribute, colorOptions),
    boolean: renderColorValue(value.boolean, colorOptions),
    builtin: renderColorValue(value.builtin, colorOptions),
    cdata: renderColorValue(value.cdata, colorOptions),
    char: renderColorValue(value.char, colorOptions),
    class: renderColorValue(value.class, colorOptions),
    className: renderColorValue(value.className, colorOptions),
    comment: renderColorValue(value.comment, colorOptions),
    constant: renderColorValue(value.constant, colorOptions),
    deleted: renderColorValue(value.deleted, colorOptions),
    doctype: renderColorValue(value.doctype, colorOptions),
    entity: renderColorValue(value.entity, colorOptions),
    function: renderColorValue(value.function, colorOptions),
    hexcode: renderColorValue(value.hexcode, colorOptions),
    id: renderColorValue(value.id, colorOptions),
    important: renderColorValue(value.important, colorOptions),
    inserted: renderColorValue(value.inserted, colorOptions),
    keyword: renderColorValue(value.keyword, colorOptions),
    number: renderColorValue(value.number, colorOptions),
    operator: renderColorValue(value.operator, colorOptions),
    prolog: renderColorValue(value.prolog, colorOptions),
    property: renderColorValue(value.property, colorOptions),
    pseudoClass: renderColorValue(value.pseudoClass, colorOptions),
    pseudoElement: renderColorValue(value.pseudoElement, colorOptions),
    punctuation: renderColorValue(value.punctuation, colorOptions),
    regex: renderColorValue(value.regex, colorOptions),
    selector: renderColorValue(value.selector, colorOptions),
    string: renderColorValue(value.string, colorOptions),
    symbol: renderColorValue(value.symbol, colorOptions),
    tag: renderColorValue(value.tag, colorOptions),
    unit: renderColorValue(value.unit, colorOptions),
    url: renderColorValue(value.url, colorOptions),
    variable: renderColorValue(value.variable, colorOptions)
  };
}
function buildTheme(config) {
  const colorTheme = buildColorTheme(config), v2 = {
    _version: 2,
    avatar: (config == null ? void 0 : config.avatar) ?? defaultThemeConfig.avatar,
    button: (config == null ? void 0 : config.button) ?? defaultThemeConfig.button,
    card: (config == null ? void 0 : config.card) ?? defaultThemeConfig.card,
    // How colors are generated:
    // 1. Merge custom tokens with default tokens
    // 2. Generate tree of color keys (gray/500, black, white, etc.)
    // 3. Apply mixing and render to hex values
    // render(build(mergeWithDefaults()))
    color: renderThemeColorSchemes(colorTheme, config),
    container: (config == null ? void 0 : config.container) ?? defaultThemeConfig.container,
    font: (config == null ? void 0 : config.font) ?? defaultThemeFonts,
    input: (config == null ? void 0 : config.input) ?? defaultThemeConfig.input,
    layer: (config == null ? void 0 : config.layer) ?? defaultThemeConfig.layer,
    media: (config == null ? void 0 : config.media) ?? defaultThemeConfig.media,
    radius: (config == null ? void 0 : config.radius) ?? defaultThemeConfig.radius,
    shadow: (config == null ? void 0 : config.shadow) ?? defaultThemeConfig.shadow,
    space: (config == null ? void 0 : config.space) ?? defaultThemeConfig.space,
    style: (config == null ? void 0 : config.style) ?? defaultThemeConfig.style
  };
  return v2_v0(v2);
}
function themeColor_v0_v2_9(color22) {
  if ("neutral" in color22.badge)
    return color22;
  const colors2 = color22;
  return {
    ...colors2,
    badge: {
      ...colors2.badge,
      neutral: colors2.badge.default,
      suggest: colors2.badge.primary
    },
    button: {
      bleed: {
        ...colors2.button.bleed,
        neutral: colors2.button.bleed.default,
        suggest: colors2.button.bleed.primary
      },
      default: {
        ...colors2.button.default,
        neutral: colors2.button.default.default,
        suggest: colors2.button.default.primary
      },
      ghost: {
        ...colors2.button.ghost,
        neutral: colors2.button.ghost.default,
        suggest: colors2.button.ghost.primary
      }
    },
    selectable: {
      ...colors2.selectable,
      neutral: colors2.selectable.default,
      suggest: colors2.selectable.primary
    }
  };
}
var cache = /* @__PURE__ */ new Map();
function getScopedTheme(themeProp, scheme, tone) {
  const cachedTheme = _getCachedTheme(themeProp, scheme, tone);
  if (cachedTheme) return cachedTheme;
  const v0 = is_v2(themeProp) ? v2_v0(themeProp) : themeProp, v2 = is_v2(themeProp) ? themeProp : v0_v2(themeProp), colorScheme_v0 = v0.color[scheme] || v0.color.light, color_v0 = colorScheme_v0[tone] || colorScheme_v0.default, layer_v0 = v0.layer || defaultThemeConfig.layer, colorScheme_v2 = v2.color[scheme] || v2.color.light, color_v2 = colorScheme_v2[tone] || colorScheme_v2.default, color_v2_9 = themeColor_v0_v2_9(color_v2), layer_v2 = v2.layer || defaultThemeConfig.layer, theme = {
    sanity: {
      ...v0,
      color: color_v0,
      layer: layer_v0,
      v2: {
        ...v2,
        _resolved: true,
        color: color_v2_9,
        layer: layer_v2
      }
    }
  };
  return _setCachedTheme(themeProp, scheme, tone, theme), theme;
}
function _getCachedTheme(rootTheme, scheme, tone) {
  const schemeCache = cache.get(scheme);
  if (!schemeCache) return;
  const toneCache = schemeCache.get(tone);
  if (toneCache)
    return toneCache.get(rootTheme);
}
function _setCachedTheme(rootTheme, scheme, tone, theme) {
  cache.has(scheme) || cache.set(scheme, /* @__PURE__ */ new Map());
  const schemeCache = cache.get(scheme);
  schemeCache.has(tone) || schemeCache.set(tone, /* @__PURE__ */ new WeakMap()), schemeCache.get(tone).set(rootTheme, theme);
}

// ../node_modules/styled-components/node_modules/tslib/tslib.es6.mjs
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s2, i2 = 1, n = arguments.length; i2 < n; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t[p2] = s2[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __spreadArray(to, from2, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from2.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i2);
      ar[i2] = from2[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}

// ../node_modules/styled-components/dist/styled-components.browser.esm.js
init_emotion_is_prop_valid_esm();
var import_react = __toESM(require_react());
var import_shallowequal = __toESM(require_shallowequal());

// ../node_modules/stylis/src/Enum.js
var MS = "-ms-";
var MOZ = "-moz-";
var WEBKIT = "-webkit-";
var COMMENT = "comm";
var RULESET = "rule";
var DECLARATION = "decl";
var IMPORT = "@import";
var KEYFRAMES = "@keyframes";
var LAYER = "@layer";

// ../node_modules/stylis/src/Utility.js
var abs = Math.abs;
var from = String.fromCharCode;
var assign = Object.assign;
function hash(value, length2) {
  return charat(value, 0) ^ 45 ? (((length2 << 2 ^ charat(value, 0)) << 2 ^ charat(value, 1)) << 2 ^ charat(value, 2)) << 2 ^ charat(value, 3) : 0;
}
function trim(value) {
  return value.trim();
}
function match(value, pattern) {
  return (value = pattern.exec(value)) ? value[0] : value;
}
function replace(value, pattern, replacement) {
  return value.replace(pattern, replacement);
}
function indexof(value, search, position2) {
  return value.indexOf(search, position2);
}
function charat(value, index2) {
  return value.charCodeAt(index2) | 0;
}
function substr(value, begin, end) {
  return value.slice(begin, end);
}
function strlen(value) {
  return value.length;
}
function sizeof(value) {
  return value.length;
}
function append(value, array) {
  return array.push(value), value;
}
function combine(array, callback) {
  return array.map(callback).join("");
}
function filter(array, pattern) {
  return array.filter(function(value) {
    return !match(value, pattern);
  });
}

// ../node_modules/stylis/src/Tokenizer.js
var line = 1;
var column = 1;
var length = 0;
var position = 0;
var character = 0;
var characters = "";
function node(value, root, parent, type, props, children, length2, siblings) {
  return { value, root, parent, type, props, children, line, column, length: length2, return: "", siblings };
}
function copy(root, props) {
  return assign(node("", null, null, "", null, null, 0, root.siblings), root, { length: -root.length }, props);
}
function lift(root) {
  while (root.root)
    root = copy(root.root, { children: [root] });
  append(root, root.siblings);
}
function char() {
  return character;
}
function prev() {
  character = position > 0 ? charat(characters, --position) : 0;
  if (column--, character === 10)
    column = 1, line--;
  return character;
}
function next() {
  character = position < length ? charat(characters, position++) : 0;
  if (column++, character === 10)
    column = 1, line++;
  return character;
}
function peek() {
  return charat(characters, position);
}
function caret() {
  return position;
}
function slice(begin, end) {
  return substr(characters, begin, end);
}
function token(type) {
  switch (type) {
    // \0 \t \n \r \s whitespace token
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    // ! + , / > @ ~ isolate token
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    // ; { } breakpoint token
    case 59:
    case 123:
    case 125:
      return 4;
    // : accompanied token
    case 58:
      return 3;
    // " ' ( [ opening delimit token
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    // ) ] closing delimit token
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function alloc(value) {
  return line = column = 1, length = strlen(characters = value), position = 0, [];
}
function dealloc(value) {
  return characters = "", value;
}
function delimit(type) {
  return trim(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)));
}
function whitespace(type) {
  while (character = peek())
    if (character < 33)
      next();
    else
      break;
  return token(type) > 2 || token(character) > 3 ? "" : " ";
}
function escaping(index2, count) {
  while (--count && next())
    if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
      break;
  return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
}
function delimiter(type) {
  while (next())
    switch (character) {
      // ] ) " '
      case type:
        return position;
      // " '
      case 34:
      case 39:
        if (type !== 34 && type !== 39)
          delimiter(character);
        break;
      // (
      case 40:
        if (type === 41)
          delimiter(type);
        break;
      // \
      case 92:
        next();
        break;
    }
  return position;
}
function commenter(type, index2) {
  while (next())
    if (type + character === 47 + 10)
      break;
    else if (type + character === 42 + 42 && peek() === 47)
      break;
  return "/*" + slice(index2, position - 1) + "*" + from(type === 47 ? type : next());
}
function identifier(index2) {
  while (!token(peek()))
    next();
  return slice(index2, position);
}

// ../node_modules/stylis/src/Parser.js
function compile(value) {
  return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
}
function parse(value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
  var index2 = 0;
  var offset4 = 0;
  var length2 = pseudo;
  var atrule = 0;
  var property = 0;
  var previous = 0;
  var variable = 1;
  var scanning = 1;
  var ampersand = 1;
  var character2 = 0;
  var type = "";
  var props = rules;
  var children = rulesets;
  var reference = rule;
  var characters2 = type;
  while (scanning)
    switch (previous = character2, character2 = next()) {
      // (
      case 40:
        if (previous != 108 && charat(characters2, length2 - 1) == 58) {
          if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f", abs(index2 ? points[index2 - 1] : 0)) != -1)
            ampersand = -1;
          break;
        }
      // " ' [
      case 34:
      case 39:
      case 91:
        characters2 += delimit(character2);
        break;
      // \t \n \r \s
      case 9:
      case 10:
      case 13:
      case 32:
        characters2 += whitespace(previous);
        break;
      // \
      case 92:
        characters2 += escaping(caret() - 1, 7);
        continue;
      // /
      case 47:
        switch (peek()) {
          case 42:
          case 47:
            append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
            break;
          default:
            characters2 += "/";
        }
        break;
      // {
      case 123 * variable:
        points[index2++] = strlen(characters2) * ampersand;
      // } ; \0
      case 125 * variable:
      case 59:
      case 0:
        switch (character2) {
          // \0 }
          case 0:
          case 125:
            scanning = 0;
          // ;
          case 59 + offset4:
            if (ampersand == -1) characters2 = replace(characters2, /\f/g, "");
            if (property > 0 && strlen(characters2) - length2)
              append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
            break;
          // @ ;
          case 59:
            characters2 += ";";
          // { rule/at-rule
          default:
            append(reference = ruleset(characters2, root, parent, index2, offset4, rules, points, type, props = [], children = [], length2, rulesets), rulesets);
            if (character2 === 123)
              if (offset4 === 0)
                parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
              else
                switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                  // d l m s
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length2, children), children), rules, children, length2, points, rule ? props : children);
                    break;
                  default:
                    parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                }
        }
        index2 = offset4 = property = 0, variable = ampersand = 1, type = characters2 = "", length2 = pseudo;
        break;
      // :
      case 58:
        length2 = 1 + strlen(characters2), property = previous;
      default:
        if (variable < 1) {
          if (character2 == 123)
            --variable;
          else if (character2 == 125 && variable++ == 0 && prev() == 125)
            continue;
        }
        switch (characters2 += from(character2), character2 * variable) {
          // &
          case 38:
            ampersand = offset4 > 0 ? 1 : (characters2 += "\f", -1);
            break;
          // ,
          case 44:
            points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
            break;
          // @
          case 64:
            if (peek() === 45)
              characters2 += delimit(next());
            atrule = peek(), offset4 = length2 = strlen(type = characters2 += identifier(caret())), character2++;
            break;
          // -
          case 45:
            if (previous === 45 && strlen(characters2) == 2)
              variable = 0;
        }
    }
  return rulesets;
}
function ruleset(value, root, parent, index2, offset4, rules, points, type, props, children, length2, siblings) {
  var post = offset4 - 1;
  var rule = offset4 === 0 ? rules : [""];
  var size5 = sizeof(rule);
  for (var i2 = 0, j2 = 0, k2 = 0; i2 < index2; ++i2)
    for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j2 = points[i2])), z2 = value; x2 < size5; ++x2)
      if (z2 = trim(j2 > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
        props[k2++] = z2;
  return node(value, root, parent, offset4 === 0 ? RULESET : type, props, children, length2, siblings);
}
function comment(value, root, parent, siblings) {
  return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
}
function declaration(value, root, parent, length2, siblings) {
  return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
}

// ../node_modules/stylis/src/Prefixer.js
function prefix(value, length2, children) {
  switch (hash(value, length2)) {
    // color-adjust
    case 5103:
      return WEBKIT + "print-" + value + value;
    // animation, animation-(delay|direction|duration|fill-mode|iteration-count|name|play-state|timing-function)
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    // text-decoration, filter, clip-path, backface-visibility, column, box-decoration-break
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    // mask, mask-image, mask-(mode|clip|size), mask-(repeat|origin), mask-position, mask-composite,
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    // background-clip, columns, column-(count|fill|gap|rule|rule-color|rule-style|rule-width|span|width)
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return WEBKIT + value + value;
    // tab-size
    case 4789:
      return MOZ + value + value;
    // appearance, user-select, transform, hyphens, text-size-adjust
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return WEBKIT + value + MOZ + value + MS + value + value;
    // writing-mode
    case 5936:
      switch (charat(value, length2 + 11)) {
        // vertical-l(r)
        case 114:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb") + value;
        // vertical-r(l)
        case 108:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "tb-rl") + value;
        // horizontal(-)tb
        case 45:
          return WEBKIT + value + MS + replace(value, /[svh]\w+-[tblr]{2}/, "lr") + value;
      }
    // flex, flex-direction, scroll-snap-type, writing-mode
    case 6828:
    case 4268:
    case 2903:
      return WEBKIT + value + MS + value + value;
    // order
    case 6165:
      return WEBKIT + value + MS + "flex-" + value + value;
    // align-items
    case 5187:
      return WEBKIT + value + replace(value, /(\w+).+(:[^]+)/, WEBKIT + "box-$1$2" + MS + "flex-$1$2") + value;
    // align-self
    case 5443:
      return WEBKIT + value + MS + "flex-item-" + replace(value, /flex-|-self/g, "") + (!match(value, /flex-|baseline/) ? MS + "grid-row-" + replace(value, /flex-|-self/g, "") : "") + value;
    // align-content
    case 4675:
      return WEBKIT + value + MS + "flex-line-pack" + replace(value, /align-content|flex-|-self/g, "") + value;
    // flex-shrink
    case 5548:
      return WEBKIT + value + MS + replace(value, "shrink", "negative") + value;
    // flex-basis
    case 5292:
      return WEBKIT + value + MS + replace(value, "basis", "preferred-size") + value;
    // flex-grow
    case 6060:
      return WEBKIT + "box-" + replace(value, "-grow", "") + WEBKIT + value + MS + replace(value, "grow", "positive") + value;
    // transition
    case 4554:
      return WEBKIT + replace(value, /([^-])(transform)/g, "$1" + WEBKIT + "$2") + value;
    // cursor
    case 6187:
      return replace(replace(replace(value, /(zoom-|grab)/, WEBKIT + "$1"), /(image-set)/, WEBKIT + "$1"), value, "") + value;
    // background, background-image
    case 5495:
    case 3959:
      return replace(value, /(image-set\([^]*)/, WEBKIT + "$1$`$1");
    // justify-content
    case 4968:
      return replace(replace(value, /(.+:)(flex-)?(.*)/, WEBKIT + "box-pack:$3" + MS + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + WEBKIT + value + value;
    // justify-self
    case 4200:
      if (!match(value, /flex-|baseline/)) return MS + "grid-column-align" + substr(value, length2) + value;
      break;
    // grid-template-(columns|rows)
    case 2592:
    case 3360:
      return MS + replace(value, "template-", "") + value;
    // grid-(row|column)-start
    case 4384:
    case 3616:
      if (children && children.some(function(element, index2) {
        return length2 = index2, match(element.props, /grid-\w+-end/);
      })) {
        return ~indexof(value + (children = children[length2].value), "span", 0) ? value : MS + replace(value, "-start", "") + value + MS + "grid-row-span:" + (~indexof(children, "span", 0) ? match(children, /\d+/) : +match(children, /\d+/) - +match(value, /\d+/)) + ";";
      }
      return MS + replace(value, "-start", "") + value;
    // grid-(row|column)-end
    case 4896:
    case 4128:
      return children && children.some(function(element) {
        return match(element.props, /grid-\w+-start/);
      }) ? value : MS + replace(replace(value, "-end", "-span"), "span ", "") + value;
    // (margin|padding)-inline-(start|end)
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return replace(value, /(.+)-inline(.+)/, WEBKIT + "$1$2") + value;
    // (min|max)?(width|height|inline-size|block-size)
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (strlen(value) - 1 - length2 > 6)
        switch (charat(value, length2 + 1)) {
          // (m)ax-content, (m)in-content
          case 109:
            if (charat(value, length2 + 4) !== 45)
              break;
          // (f)ill-available, (f)it-content
          case 102:
            return replace(value, /(.+:)(.+)-([^]+)/, "$1" + WEBKIT + "$2-$3$1" + MOZ + (charat(value, length2 + 3) == 108 ? "$3" : "$2-$3")) + value;
          // (s)tretch
          case 115:
            return ~indexof(value, "stretch", 0) ? prefix(replace(value, "stretch", "fill-available"), length2, children) + value : value;
        }
      break;
    // grid-(column|row)
    case 5152:
    case 5920:
      return replace(value, /(.+?):(\d+)(\s*\/\s*(span)?\s*(\d+))?(.*)/, function(_2, a2, b2, c4, d, e, f2) {
        return MS + a2 + ":" + b2 + f2 + (c4 ? MS + a2 + "-span:" + (d ? e : +e - +b2) + f2 : "") + value;
      });
    // position: sticky
    case 4949:
      if (charat(value, length2 + 6) === 121)
        return replace(value, ":", ":" + WEBKIT) + value;
      break;
    // display: (flex|inline-flex|grid|inline-grid)
    case 6444:
      switch (charat(value, charat(value, 14) === 45 ? 18 : 11)) {
        // (inline-)?fle(x)
        case 120:
          return replace(value, /(.+:)([^;\s!]+)(;|(\s+)?!.+)?/, "$1" + WEBKIT + (charat(value, 14) === 45 ? "inline-" : "") + "box$3$1" + WEBKIT + "$2$3$1" + MS + "$2box$3") + value;
        // (inline-)?gri(d)
        case 100:
          return replace(value, ":", ":" + MS) + value;
      }
      break;
    // scroll-margin, scroll-margin-(top|right|bottom|left)
    case 5719:
    case 2647:
    case 2135:
    case 3927:
    case 2391:
      return replace(value, "scroll-", "scroll-snap-") + value;
  }
  return value;
}

// ../node_modules/stylis/src/Serializer.js
function serialize(children, callback) {
  var output = "";
  for (var i2 = 0; i2 < children.length; i2++)
    output += callback(children[i2], i2, children, callback) || "";
  return output;
}
function stringify(element, index2, children, callback) {
  switch (element.type) {
    case LAYER:
      if (element.children.length) break;
    case IMPORT:
    case DECLARATION:
      return element.return = element.return || element.value;
    case COMMENT:
      return "";
    case KEYFRAMES:
      return element.return = element.value + "{" + serialize(element.children, callback) + "}";
    case RULESET:
      if (!strlen(element.value = element.props.join(","))) return "";
  }
  return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
}

// ../node_modules/stylis/src/Middleware.js
function middleware(collection) {
  var length2 = sizeof(collection);
  return function(element, index2, children, callback) {
    var output = "";
    for (var i2 = 0; i2 < length2; i2++)
      output += collection[i2](element, index2, children, callback) || "";
    return output;
  };
}
function rulesheet(callback) {
  return function(element) {
    if (!element.root) {
      if (element = element.return)
        callback(element);
    }
  };
}
function prefixer(element, index2, children, callback) {
  if (element.length > -1) {
    if (!element.return)
      switch (element.type) {
        case DECLARATION:
          element.return = prefix(element.value, element.length, children);
          return;
        case KEYFRAMES:
          return serialize([copy(element, { value: replace(element.value, "@", "@" + WEBKIT) })], callback);
        case RULESET:
          if (element.length)
            return combine(children = element.props, function(value) {
              switch (match(value, callback = /(::plac\w+|:read-\w+)/)) {
                // :read-(only|write)
                case ":read-only":
                case ":read-write":
                  lift(copy(element, { props: [replace(value, /:(read-\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
                // :placeholder
                case "::placeholder":
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + WEBKIT + "input-$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, ":" + MOZ + "$1")] }));
                  lift(copy(element, { props: [replace(value, /:(plac\w+)/, MS + "input-$1")] }));
                  lift(copy(element, { props: [value] }));
                  assign(element, { props: filter(children, callback) });
                  break;
              }
              return "";
            });
      }
  }
}

// ../node_modules/@emotion/unitless/dist/emotion-unitless.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};

// ../node_modules/styled-components/dist/styled-components.browser.esm.js
var f = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
var m = "active";
var y = "data-styled-version";
var v = "6.1.18";
var g = "/*!sc*/\n";
var S = "undefined" != typeof window && "undefined" != typeof document;
var w = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true);
var b = {};
var E = /invalid hook call/i;
var N = /* @__PURE__ */ new Set();
var P = function(t, n) {
  if (true) {
    var o2 = n ? ' with the id of "'.concat(n, '"') : "", s2 = "The component ".concat(t).concat(o2, " has been created dynamically.\n") + "You may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.\nSee https://styled-components.com/docs/basics#define-styled-components-outside-of-the-render-method for more info.\n", i2 = console.error;
    try {
      var a2 = true;
      console.error = function(t2) {
        for (var n2 = [], o3 = 1; o3 < arguments.length; o3++) n2[o3 - 1] = arguments[o3];
        E.test(t2) ? (a2 = false, N.delete(s2)) : i2.apply(void 0, __spreadArray([t2], n2, false));
      }, (0, import_react.useRef)(), a2 && !N.has(s2) && (console.warn(s2), N.add(s2));
    } catch (e) {
      E.test(e.message) && N.delete(s2);
    } finally {
      console.error = i2;
    }
  }
};
var _ = Object.freeze([]);
var C = Object.freeze({});
function I(e, t, n) {
  return void 0 === n && (n = C), e.theme !== n.theme && e.theme || t || n.theme;
}
var A = /* @__PURE__ */ new Set(["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "u", "ul", "use", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "tspan"]);
var O = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
var D = /(^-|-$)/g;
function R(e) {
  return e.replace(O, "-").replace(D, "");
}
var T = /(a)(d)/gi;
var k = 52;
var j = function(e) {
  return String.fromCharCode(e + (e > 25 ? 39 : 97));
};
function x(e) {
  var t, n = "";
  for (t = Math.abs(e); t > k; t = t / k | 0) n = j(t % k) + n;
  return (j(t % k) + n).replace(T, "$1-$2");
}
var V;
var F = 5381;
var M = function(e, t) {
  for (var n = t.length; n; ) e = 33 * e ^ t.charCodeAt(--n);
  return e;
};
var z = function(e) {
  return M(F, e);
};
function $(e) {
  return x(z(e) >>> 0);
}
function B(e) {
  return "string" == typeof e && e || e.displayName || e.name || "Component";
}
function L(e) {
  return "string" == typeof e && e.charAt(0) === e.charAt(0).toLowerCase();
}
var G = "function" == typeof Symbol && Symbol.for;
var Y = G ? Symbol.for("react.memo") : 60115;
var W = G ? Symbol.for("react.forward_ref") : 60112;
var q = { childContextTypes: true, contextType: true, contextTypes: true, defaultProps: true, displayName: true, getDefaultProps: true, getDerivedStateFromError: true, getDerivedStateFromProps: true, mixins: true, propTypes: true, type: true };
var H = { name: true, length: true, prototype: true, caller: true, callee: true, arguments: true, arity: true };
var U = { $$typeof: true, compare: true, defaultProps: true, displayName: true, propTypes: true, type: true };
var J = ((V = {})[W] = { $$typeof: true, render: true, defaultProps: true, displayName: true, propTypes: true }, V[Y] = U, V);
function X(e) {
  return ("type" in (t = e) && t.type.$$typeof) === Y ? U : "$$typeof" in e ? J[e.$$typeof] : q;
  var t;
}
var Z = Object.defineProperty;
var K = Object.getOwnPropertyNames;
var Q = Object.getOwnPropertySymbols;
var ee = Object.getOwnPropertyDescriptor;
var te = Object.getPrototypeOf;
var ne = Object.prototype;
function oe(e, t, n) {
  if ("string" != typeof t) {
    if (ne) {
      var o2 = te(t);
      o2 && o2 !== ne && oe(e, o2, n);
    }
    var r2 = K(t);
    Q && (r2 = r2.concat(Q(t)));
    for (var s2 = X(e), i2 = X(t), a2 = 0; a2 < r2.length; ++a2) {
      var c4 = r2[a2];
      if (!(c4 in H || n && n[c4] || i2 && c4 in i2 || s2 && c4 in s2)) {
        var l2 = ee(t, c4);
        try {
          Z(e, c4, l2);
        } catch (e2) {
        }
      }
    }
  }
  return e;
}
function re(e) {
  return "function" == typeof e;
}
function se(e) {
  return "object" == typeof e && "styledComponentId" in e;
}
function ie(e, t) {
  return e && t ? "".concat(e, " ").concat(t) : e || t || "";
}
function ae(e, t) {
  if (0 === e.length) return "";
  for (var n = e[0], o2 = 1; o2 < e.length; o2++) n += t ? t + e[o2] : e[o2];
  return n;
}
function ce(e) {
  return null !== e && "object" == typeof e && e.constructor.name === Object.name && !("props" in e && e.$$typeof);
}
function le(e, t, n) {
  if (void 0 === n && (n = false), !n && !ce(e) && !Array.isArray(e)) return t;
  if (Array.isArray(t)) for (var o2 = 0; o2 < t.length; o2++) e[o2] = le(e[o2], t[o2]);
  else if (ce(t)) for (var o2 in t) e[o2] = le(e[o2], t[o2]);
  return e;
}
function ue(e, t) {
  Object.defineProperty(e, "toString", { value: t });
}
var pe = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n", 18: "ThemeProvider: Please make sure your useTheme hook is within a `<ThemeProvider>`" } : {};
function de() {
  for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
  for (var n = e[0], o2 = [], r2 = 1, s2 = e.length; r2 < s2; r2 += 1) o2.push(e[r2]);
  return o2.forEach(function(e2) {
    n = n.replace(/%[a-z]/, e2);
  }), n;
}
function he(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  return false ? new Error("An error occurred. See https://github.com/styled-components/styled-components/blob/main/packages/styled-components/src/utils/errors.md#".concat(t, " for more information.").concat(n.length > 0 ? " Args: ".concat(n.join(", ")) : "")) : new Error(de.apply(void 0, __spreadArray([pe[t]], n, false)).trim());
}
var fe = function() {
  function e(e2) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e2;
  }
  return e.prototype.indexOfGroup = function(e2) {
    for (var t = 0, n = 0; n < e2; n++) t += this.groupSizes[n];
    return t;
  }, e.prototype.insertRules = function(e2, t) {
    if (e2 >= this.groupSizes.length) {
      for (var n = this.groupSizes, o2 = n.length, r2 = o2; e2 >= r2; ) if ((r2 <<= 1) < 0) throw he(16, "".concat(e2));
      this.groupSizes = new Uint32Array(r2), this.groupSizes.set(n), this.length = r2;
      for (var s2 = o2; s2 < r2; s2++) this.groupSizes[s2] = 0;
    }
    for (var i2 = this.indexOfGroup(e2 + 1), a2 = (s2 = 0, t.length); s2 < a2; s2++) this.tag.insertRule(i2, t[s2]) && (this.groupSizes[e2]++, i2++);
  }, e.prototype.clearGroup = function(e2) {
    if (e2 < this.length) {
      var t = this.groupSizes[e2], n = this.indexOfGroup(e2), o2 = n + t;
      this.groupSizes[e2] = 0;
      for (var r2 = n; r2 < o2; r2++) this.tag.deleteRule(n);
    }
  }, e.prototype.getGroup = function(e2) {
    var t = "";
    if (e2 >= this.length || 0 === this.groupSizes[e2]) return t;
    for (var n = this.groupSizes[e2], o2 = this.indexOfGroup(e2), r2 = o2 + n, s2 = o2; s2 < r2; s2++) t += "".concat(this.tag.getRule(s2)).concat(g);
    return t;
  }, e;
}();
var me = 1 << 30;
var ye = /* @__PURE__ */ new Map();
var ve = /* @__PURE__ */ new Map();
var ge = 1;
var Se = function(e) {
  if (ye.has(e)) return ye.get(e);
  for (; ve.has(ge); ) ge++;
  var t = ge++;
  if ((0 | t) < 0 || t > me) throw he(16, "".concat(t));
  return ye.set(e, t), ve.set(t, e), t;
};
var we = function(e, t) {
  ge = t + 1, ye.set(e, t), ve.set(t, e);
};
var be = "style[".concat(f, "][").concat(y, '="').concat(v, '"]');
var Ee = new RegExp("^".concat(f, '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)'));
var Ne = function(e, t, n) {
  for (var o2, r2 = n.split(","), s2 = 0, i2 = r2.length; s2 < i2; s2++) (o2 = r2[s2]) && e.registerName(t, o2);
};
var Pe = function(e, t) {
  for (var n, o2 = (null !== (n = t.textContent) && void 0 !== n ? n : "").split(g), r2 = [], s2 = 0, i2 = o2.length; s2 < i2; s2++) {
    var a2 = o2[s2].trim();
    if (a2) {
      var c4 = a2.match(Ee);
      if (c4) {
        var l2 = 0 | parseInt(c4[1], 10), u2 = c4[2];
        0 !== l2 && (we(u2, l2), Ne(e, u2, c4[3]), e.getTag().insertRules(l2, r2)), r2.length = 0;
      } else r2.push(a2);
    }
  }
};
var _e = function(e) {
  for (var t = document.querySelectorAll(be), n = 0, o2 = t.length; n < o2; n++) {
    var r2 = t[n];
    r2 && r2.getAttribute(f) !== m && (Pe(e, r2), r2.parentNode && r2.parentNode.removeChild(r2));
  }
};
function Ce() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
}
var Ie = function(e) {
  var t = document.head, n = e || t, o2 = document.createElement("style"), r2 = function(e2) {
    var t2 = Array.from(e2.querySelectorAll("style[".concat(f, "]")));
    return t2[t2.length - 1];
  }(n), s2 = void 0 !== r2 ? r2.nextSibling : null;
  o2.setAttribute(f, m), o2.setAttribute(y, v);
  var i2 = Ce();
  return i2 && o2.setAttribute("nonce", i2), n.insertBefore(o2, s2), o2;
};
var Ae = function() {
  function e(e2) {
    this.element = Ie(e2), this.element.appendChild(document.createTextNode("")), this.sheet = function(e3) {
      if (e3.sheet) return e3.sheet;
      for (var t = document.styleSheets, n = 0, o2 = t.length; n < o2; n++) {
        var r2 = t[n];
        if (r2.ownerNode === e3) return r2;
      }
      throw he(17);
    }(this.element), this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    try {
      return this.sheet.insertRule(t, e2), this.length++, true;
    } catch (e3) {
      return false;
    }
  }, e.prototype.deleteRule = function(e2) {
    this.sheet.deleteRule(e2), this.length--;
  }, e.prototype.getRule = function(e2) {
    var t = this.sheet.cssRules[e2];
    return t && t.cssText ? t.cssText : "";
  }, e;
}();
var Oe = function() {
  function e(e2) {
    this.element = Ie(e2), this.nodes = this.element.childNodes, this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    if (e2 <= this.length && e2 >= 0) {
      var n = document.createTextNode(t);
      return this.element.insertBefore(n, this.nodes[e2] || null), this.length++, true;
    }
    return false;
  }, e.prototype.deleteRule = function(e2) {
    this.element.removeChild(this.nodes[e2]), this.length--;
  }, e.prototype.getRule = function(e2) {
    return e2 < this.length ? this.nodes[e2].textContent : "";
  }, e;
}();
var De = function() {
  function e(e2) {
    this.rules = [], this.length = 0;
  }
  return e.prototype.insertRule = function(e2, t) {
    return e2 <= this.length && (this.rules.splice(e2, 0, t), this.length++, true);
  }, e.prototype.deleteRule = function(e2) {
    this.rules.splice(e2, 1), this.length--;
  }, e.prototype.getRule = function(e2) {
    return e2 < this.length ? this.rules[e2] : "";
  }, e;
}();
var Re = S;
var Te = { isServer: !S, useCSSOMInjection: !w };
var ke = function() {
  function e(e2, n, o2) {
    void 0 === e2 && (e2 = C), void 0 === n && (n = {});
    var r2 = this;
    this.options = __assign(__assign({}, Te), e2), this.gs = n, this.names = new Map(o2), this.server = !!e2.isServer, !this.server && S && Re && (Re = false, _e(this)), ue(this, function() {
      return function(e3) {
        for (var t = e3.getTag(), n2 = t.length, o3 = "", r3 = function(n3) {
          var r4 = function(e4) {
            return ve.get(e4);
          }(n3);
          if (void 0 === r4) return "continue";
          var s3 = e3.names.get(r4), i2 = t.getGroup(n3);
          if (void 0 === s3 || !s3.size || 0 === i2.length) return "continue";
          var a2 = "".concat(f, ".g").concat(n3, '[id="').concat(r4, '"]'), c4 = "";
          void 0 !== s3 && s3.forEach(function(e4) {
            e4.length > 0 && (c4 += "".concat(e4, ","));
          }), o3 += "".concat(i2).concat(a2, '{content:"').concat(c4, '"}').concat(g);
        }, s2 = 0; s2 < n2; s2++) r3(s2);
        return o3;
      }(r2);
    });
  }
  return e.registerId = function(e2) {
    return Se(e2);
  }, e.prototype.rehydrate = function() {
    !this.server && S && _e(this);
  }, e.prototype.reconstructWithOptions = function(n, o2) {
    return void 0 === o2 && (o2 = true), new e(__assign(__assign({}, this.options), n), this.gs, o2 && this.names || void 0);
  }, e.prototype.allocateGSInstance = function(e2) {
    return this.gs[e2] = (this.gs[e2] || 0) + 1;
  }, e.prototype.getTag = function() {
    return this.tag || (this.tag = (e2 = function(e3) {
      var t = e3.useCSSOMInjection, n = e3.target;
      return e3.isServer ? new De(n) : t ? new Ae(n) : new Oe(n);
    }(this.options), new fe(e2)));
    var e2;
  }, e.prototype.hasNameForId = function(e2, t) {
    return this.names.has(e2) && this.names.get(e2).has(t);
  }, e.prototype.registerName = function(e2, t) {
    if (Se(e2), this.names.has(e2)) this.names.get(e2).add(t);
    else {
      var n = /* @__PURE__ */ new Set();
      n.add(t), this.names.set(e2, n);
    }
  }, e.prototype.insertRules = function(e2, t, n) {
    this.registerName(e2, t), this.getTag().insertRules(Se(e2), n);
  }, e.prototype.clearNames = function(e2) {
    this.names.has(e2) && this.names.get(e2).clear();
  }, e.prototype.clearRules = function(e2) {
    this.getTag().clearGroup(Se(e2)), this.clearNames(e2);
  }, e.prototype.clearTag = function() {
    this.tag = void 0;
  }, e;
}();
var je = /&/g;
var xe = /^\s*\/\/.*$/gm;
function Ve(e, t) {
  return e.map(function(e2) {
    return "rule" === e2.type && (e2.value = "".concat(t, " ").concat(e2.value), e2.value = e2.value.replaceAll(",", ",".concat(t, " ")), e2.props = e2.props.map(function(e3) {
      return "".concat(t, " ").concat(e3);
    })), Array.isArray(e2.children) && "@keyframes" !== e2.type && (e2.children = Ve(e2.children, t)), e2;
  });
}
function Fe(e) {
  var t, n, o2, r2 = void 0 === e ? C : e, s2 = r2.options, i2 = void 0 === s2 ? C : s2, a2 = r2.plugins, c4 = void 0 === a2 ? _ : a2, l2 = function(e2, o3, r3) {
    return r3.startsWith(n) && r3.endsWith(n) && r3.replaceAll(n, "").length > 0 ? ".".concat(t) : e2;
  }, u2 = c4.slice();
  u2.push(function(e2) {
    e2.type === RULESET && e2.value.includes("&") && (e2.props[0] = e2.props[0].replace(je, n).replace(o2, l2));
  }), i2.prefix && u2.push(prefixer), u2.push(stringify);
  var p2 = function(e2, r3, s3, a3) {
    void 0 === r3 && (r3 = ""), void 0 === s3 && (s3 = ""), void 0 === a3 && (a3 = "&"), t = a3, n = r3, o2 = new RegExp("\\".concat(n, "\\b"), "g");
    var c5 = e2.replace(xe, ""), l3 = compile(s3 || r3 ? "".concat(s3, " ").concat(r3, " { ").concat(c5, " }") : c5);
    i2.namespace && (l3 = Ve(l3, i2.namespace));
    var p3 = [];
    return serialize(l3, middleware(u2.concat(rulesheet(function(e3) {
      return p3.push(e3);
    })))), p3;
  };
  return p2.hash = c4.length ? c4.reduce(function(e2, t2) {
    return t2.name || he(15), M(e2, t2.name);
  }, F).toString() : "", p2;
}
var Me = new ke();
var ze = Fe();
var $e = import_react.default.createContext({ shouldForwardProp: void 0, styleSheet: Me, stylis: ze });
var Be = $e.Consumer;
var Le = import_react.default.createContext(void 0);
function Ge() {
  return (0, import_react.useContext)($e);
}
function Ye(e) {
  var t = (0, import_react.useState)(e.stylisPlugins), n = t[0], r2 = t[1], c4 = Ge().styleSheet, l2 = (0, import_react.useMemo)(function() {
    var t2 = c4;
    return e.sheet ? t2 = e.sheet : e.target && (t2 = t2.reconstructWithOptions({ target: e.target }, false)), e.disableCSSOMInjection && (t2 = t2.reconstructWithOptions({ useCSSOMInjection: false })), t2;
  }, [e.disableCSSOMInjection, e.sheet, e.target, c4]), u2 = (0, import_react.useMemo)(function() {
    return Fe({ options: { namespace: e.namespace, prefix: e.enableVendorPrefixes }, plugins: n });
  }, [e.enableVendorPrefixes, e.namespace, n]);
  (0, import_react.useEffect)(function() {
    (0, import_shallowequal.default)(n, e.stylisPlugins) || r2(e.stylisPlugins);
  }, [e.stylisPlugins]);
  var d = (0, import_react.useMemo)(function() {
    return { shouldForwardProp: e.shouldForwardProp, styleSheet: l2, stylis: u2 };
  }, [e.shouldForwardProp, l2, u2]);
  return import_react.default.createElement($e.Provider, { value: d }, import_react.default.createElement(Le.Provider, { value: u2 }, e.children));
}
var We = function() {
  function e(e2, t) {
    var n = this;
    this.inject = function(e3, t2) {
      void 0 === t2 && (t2 = ze);
      var o2 = n.name + t2.hash;
      e3.hasNameForId(n.id, o2) || e3.insertRules(n.id, o2, t2(n.rules, o2, "@keyframes"));
    }, this.name = e2, this.id = "sc-keyframes-".concat(e2), this.rules = t, ue(this, function() {
      throw he(12, String(n.name));
    });
  }
  return e.prototype.getName = function(e2) {
    return void 0 === e2 && (e2 = ze), this.name + e2.hash;
  }, e;
}();
var qe = function(e) {
  return e >= "A" && e <= "Z";
};
function He(e) {
  for (var t = "", n = 0; n < e.length; n++) {
    var o2 = e[n];
    if (1 === n && "-" === o2 && "-" === e[0]) return e;
    qe(o2) ? t += "-" + o2.toLowerCase() : t += o2;
  }
  return t.startsWith("ms-") ? "-" + t : t;
}
var Ue = function(e) {
  return null == e || false === e || "" === e;
};
var Je = function(t) {
  var n, o2, r2 = [];
  for (var s2 in t) {
    var i2 = t[s2];
    t.hasOwnProperty(s2) && !Ue(i2) && (Array.isArray(i2) && i2.isCss || re(i2) ? r2.push("".concat(He(s2), ":"), i2, ";") : ce(i2) ? r2.push.apply(r2, __spreadArray(__spreadArray(["".concat(s2, " {")], Je(i2), false), ["}"], false)) : r2.push("".concat(He(s2), ": ").concat((n = s2, null == (o2 = i2) || "boolean" == typeof o2 || "" === o2 ? "" : "number" != typeof o2 || 0 === o2 || n in unitlessKeys || n.startsWith("--") ? String(o2).trim() : "".concat(o2, "px")), ";")));
  }
  return r2;
};
function Xe(e, t, n, o2) {
  if (Ue(e)) return [];
  if (se(e)) return [".".concat(e.styledComponentId)];
  if (re(e)) {
    if (!re(s2 = e) || s2.prototype && s2.prototype.isReactComponent || !t) return [e];
    var r2 = e(t);
    return "object" != typeof r2 || Array.isArray(r2) || r2 instanceof We || ce(r2) || null === r2 || console.error("".concat(B(e), " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.")), Xe(r2, t, n, o2);
  }
  var s2;
  return e instanceof We ? n ? (e.inject(n, o2), [e.getName(o2)]) : [e] : ce(e) ? Je(e) : Array.isArray(e) ? Array.prototype.concat.apply(_, e.map(function(e2) {
    return Xe(e2, t, n, o2);
  })) : [e.toString()];
}
function Ze(e) {
  for (var t = 0; t < e.length; t += 1) {
    var n = e[t];
    if (re(n) && !se(n)) return false;
  }
  return true;
}
var Ke = z(v);
var Qe = function() {
  function e(e2, t, n) {
    this.rules = e2, this.staticRulesId = "", this.isStatic = false, this.componentId = t, this.baseHash = M(Ke, t), this.baseStyle = n, ke.registerId(t);
  }
  return e.prototype.generateAndInjectStyles = function(e2, t, n) {
    var o2 = this.baseStyle ? this.baseStyle.generateAndInjectStyles(e2, t, n) : "";
    if (this.isStatic && !n.hash) if (this.staticRulesId && t.hasNameForId(this.componentId, this.staticRulesId)) o2 = ie(o2, this.staticRulesId);
    else {
      var r2 = ae(Xe(this.rules, e2, t, n)), s2 = x(M(this.baseHash, r2) >>> 0);
      if (!t.hasNameForId(this.componentId, s2)) {
        var i2 = n(r2, ".".concat(s2), void 0, this.componentId);
        t.insertRules(this.componentId, s2, i2);
      }
      o2 = ie(o2, s2), this.staticRulesId = s2;
    }
    else {
      for (var a2 = M(this.baseHash, n.hash), c4 = "", l2 = 0; l2 < this.rules.length; l2++) {
        var u2 = this.rules[l2];
        if ("string" == typeof u2) c4 += u2, a2 = M(a2, u2);
        else if (u2) {
          var p2 = ae(Xe(u2, e2, t, n));
          a2 = M(a2, p2 + l2), c4 += p2;
        }
      }
      if (c4) {
        var d = x(a2 >>> 0);
        t.hasNameForId(this.componentId, d) || t.insertRules(this.componentId, d, n(c4, ".".concat(d), void 0, this.componentId)), o2 = ie(o2, d);
      }
    }
    return o2;
  }, e;
}();
var et = import_react.default.createContext(void 0);
var tt = et.Consumer;
function nt() {
  var e = (0, import_react.useContext)(et);
  if (!e) throw he(18);
  return e;
}
function ot(e) {
  var n = import_react.default.useContext(et), r2 = (0, import_react.useMemo)(function() {
    return function(e2, n2) {
      if (!e2) throw he(14);
      if (re(e2)) {
        var o2 = e2(n2);
        if (null === o2 || Array.isArray(o2) || "object" != typeof o2) throw he(7);
        return o2;
      }
      if (Array.isArray(e2) || "object" != typeof e2) throw he(8);
      return n2 ? __assign(__assign({}, n2), e2) : e2;
    }(e.theme, n);
  }, [e.theme, n]);
  return e.children ? import_react.default.createElement(et.Provider, { value: r2 }, e.children) : null;
}
var rt = {};
var st = /* @__PURE__ */ new Set();
function it(e, r2, s2) {
  var i2 = se(e), a2 = e, c4 = !L(e), p2 = r2.attrs, d = void 0 === p2 ? _ : p2, h = r2.componentId, f2 = void 0 === h ? function(e2, t) {
    var n = "string" != typeof e2 ? "sc" : R(e2);
    rt[n] = (rt[n] || 0) + 1;
    var o2 = "".concat(n, "-").concat($(v + n + rt[n]));
    return t ? "".concat(t, "-").concat(o2) : o2;
  }(r2.displayName, r2.parentComponentId) : h, m3 = r2.displayName, y2 = void 0 === m3 ? function(e2) {
    return L(e2) ? "styled.".concat(e2) : "Styled(".concat(B(e2), ")");
  }(e) : m3, g2 = r2.displayName && r2.componentId ? "".concat(R(r2.displayName), "-").concat(r2.componentId) : r2.componentId || f2, S2 = i2 && a2.attrs ? a2.attrs.concat(d).filter(Boolean) : d, w2 = r2.shouldForwardProp;
  if (i2 && a2.shouldForwardProp) {
    var b2 = a2.shouldForwardProp;
    if (r2.shouldForwardProp) {
      var E2 = r2.shouldForwardProp;
      w2 = function(e2, t) {
        return b2(e2, t) && E2(e2, t);
      };
    } else w2 = b2;
  }
  var N2 = new Qe(s2, g2, i2 ? a2.componentStyle : void 0);
  function O2(e2, r3) {
    return function(e3, r4, s3) {
      var i3 = e3.attrs, a3 = e3.componentStyle, c5 = e3.defaultProps, p3 = e3.foldedComponentIds, d2 = e3.styledComponentId, h2 = e3.target, f3 = import_react.default.useContext(et), m4 = Ge(), y3 = e3.shouldForwardProp || m4.shouldForwardProp;
      (0, import_react.useDebugValue)(d2);
      var v2 = I(r4, f3, c5) || C, g3 = function(e4, n, o2) {
        for (var r5, s4 = __assign(__assign({}, n), { className: void 0, theme: o2 }), i4 = 0; i4 < e4.length; i4 += 1) {
          var a4 = re(r5 = e4[i4]) ? r5(s4) : r5;
          for (var c6 in a4) s4[c6] = "className" === c6 ? ie(s4[c6], a4[c6]) : "style" === c6 ? __assign(__assign({}, s4[c6]), a4[c6]) : a4[c6];
        }
        return n.className && (s4.className = ie(s4.className, n.className)), s4;
      }(i3, r4, v2), S3 = g3.as || h2, w3 = {};
      for (var b3 in g3) void 0 === g3[b3] || "$" === b3[0] || "as" === b3 || "theme" === b3 && g3.theme === v2 || ("forwardedAs" === b3 ? w3.as = g3.forwardedAs : y3 && !y3(b3, S3) || (w3[b3] = g3[b3], y3 || false || isPropValid(b3) || st.has(b3) || !A.has(S3) || (st.add(b3), console.warn('styled-components: it looks like an unknown prop "'.concat(b3, '" is being sent through to the DOM, which will likely trigger a React console error. If you would like automatic filtering of unknown props, you can opt-into that behavior via `<StyleSheetManager shouldForwardProp={...}>` (connect an API like `@emotion/is-prop-valid`) or consider using transient props (`$` prefix for automatic filtering.)')))));
      var E3 = function(e4, t) {
        var n = Ge(), o2 = e4.generateAndInjectStyles(t, n.styleSheet, n.stylis);
        return (0, import_react.useDebugValue)(o2), o2;
      }(a3, g3);
      e3.warnTooManyClasses && e3.warnTooManyClasses(E3);
      var N3 = ie(p3, d2);
      return E3 && (N3 += " " + E3), g3.className && (N3 += " " + g3.className), w3[L(S3) && !A.has(S3) ? "class" : "className"] = N3, s3 && (w3.ref = s3), (0, import_react.createElement)(S3, w3);
    }(D2, e2, r3);
  }
  O2.displayName = y2;
  var D2 = import_react.default.forwardRef(O2);
  return D2.attrs = S2, D2.componentStyle = N2, D2.displayName = y2, D2.shouldForwardProp = w2, D2.foldedComponentIds = i2 ? ie(a2.foldedComponentIds, a2.styledComponentId) : "", D2.styledComponentId = g2, D2.target = i2 ? a2.target : e, Object.defineProperty(D2, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(e2) {
    this._foldedDefaultProps = i2 ? function(e3) {
      for (var t = [], n = 1; n < arguments.length; n++) t[n - 1] = arguments[n];
      for (var o2 = 0, r3 = t; o2 < r3.length; o2++) le(e3, r3[o2], true);
      return e3;
    }({}, a2.defaultProps, e2) : e2;
  } }), P(y2, g2), D2.warnTooManyClasses = /* @__PURE__ */ function(e2, t) {
    var n = {}, o2 = false;
    return function(r3) {
      if (!o2 && (n[r3] = true, Object.keys(n).length >= 200)) {
        var s3 = t ? ' with the id of "'.concat(t, '"') : "";
        console.warn("Over ".concat(200, " classes were generated for component ").concat(e2).concat(s3, ".\n") + "Consider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), o2 = true, n = {};
      }
    };
  }(y2, g2), ue(D2, function() {
    return ".".concat(D2.styledComponentId);
  }), c4 && oe(D2, e, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true }), D2;
}
function at(e, t) {
  for (var n = [e[0]], o2 = 0, r2 = t.length; o2 < r2; o2 += 1) n.push(t[o2], e[o2 + 1]);
  return n;
}
var ct = function(e) {
  return Object.assign(e, { isCss: true });
};
function lt(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  if (re(t) || ce(t)) return ct(Xe(at(_, __spreadArray([t], n, true))));
  var r2 = t;
  return 0 === n.length && 1 === r2.length && "string" == typeof r2[0] ? Xe(r2) : ct(Xe(at(r2, n)));
}
function ut(n, o2, r2) {
  if (void 0 === r2 && (r2 = C), !o2) throw he(1, o2);
  var s2 = function(t) {
    for (var s3 = [], i2 = 1; i2 < arguments.length; i2++) s3[i2 - 1] = arguments[i2];
    return n(o2, r2, lt.apply(void 0, __spreadArray([t], s3, false)));
  };
  return s2.attrs = function(e) {
    return ut(n, o2, __assign(__assign({}, r2), { attrs: Array.prototype.concat(r2.attrs, e).filter(Boolean) }));
  }, s2.withConfig = function(e) {
    return ut(n, o2, __assign(__assign({}, r2), e));
  }, s2;
}
var pt = function(e) {
  return ut(it, e);
};
var dt = pt;
A.forEach(function(e) {
  dt[e] = pt(e);
});
var ht = function() {
  function e(e2, t) {
    this.rules = e2, this.componentId = t, this.isStatic = Ze(e2), ke.registerId(this.componentId + 1);
  }
  return e.prototype.createStyles = function(e2, t, n, o2) {
    var r2 = o2(ae(Xe(this.rules, t, n, o2)), ""), s2 = this.componentId + e2;
    n.insertRules(s2, s2, r2);
  }, e.prototype.removeStyles = function(e2, t) {
    t.clearRules(this.componentId + e2);
  }, e.prototype.renderStyles = function(e2, t, n, o2) {
    e2 > 2 && ke.registerId(this.componentId + e2), this.removeStyles(e2, n), this.createStyles(e2, t, n, o2);
  }, e;
}();
function ft(n) {
  for (var r2 = [], s2 = 1; s2 < arguments.length; s2++) r2[s2 - 1] = arguments[s2];
  var i2 = lt.apply(void 0, __spreadArray([n], r2, false)), a2 = "sc-global-".concat($(JSON.stringify(i2))), c4 = new ht(i2, a2);
  P(a2);
  var l2 = function(e) {
    var t = Ge(), n2 = import_react.default.useContext(et), r3 = import_react.default.useRef(t.styleSheet.allocateGSInstance(a2)).current;
    return import_react.default.Children.count(e.children) && console.warn("The global style component ".concat(a2, " was given child JSX. createGlobalStyle does not render children.")), i2.some(function(e2) {
      return "string" == typeof e2 && -1 !== e2.indexOf("@import");
    }) && console.warn("Please do not use @import CSS syntax in createGlobalStyle at this time, as the CSSOM APIs we use in production do not handle it well. Instead, we recommend using a library such as react-helmet to inject a typical <link> meta tag to the stylesheet, or simply embedding it manually in your index.html <head> section for a simpler app."), t.styleSheet.server && u2(r3, e, t.styleSheet, n2, t.stylis), import_react.default.useLayoutEffect(function() {
      if (!t.styleSheet.server) return u2(r3, e, t.styleSheet, n2, t.stylis), function() {
        return c4.removeStyles(r3, t.styleSheet);
      };
    }, [r3, e, t.styleSheet, n2, t.stylis]), null;
  };
  function u2(e, n2, o2, r3, s3) {
    if (c4.isStatic) c4.renderStyles(e, b, o2, s3);
    else {
      var i3 = __assign(__assign({}, n2), { theme: I(n2, r3, l2.defaultProps) });
      c4.renderStyles(e, i3, o2, s3);
    }
  }
  return import_react.default.memo(l2);
}
function mt(t) {
  for (var n = [], o2 = 1; o2 < arguments.length; o2++) n[o2 - 1] = arguments[o2];
  "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  var r2 = ae(lt.apply(void 0, __spreadArray([t], n, false))), s2 = $(r2);
  return new We(s2, r2);
}
var vt = function() {
  function e() {
    var e2 = this;
    this._emitSheetCSS = function() {
      var t = e2.instance.toString();
      if (!t) return "";
      var n = Ce(), o2 = ae([n && 'nonce="'.concat(n, '"'), "".concat(f, '="true"'), "".concat(y, '="').concat(v, '"')].filter(Boolean), " ");
      return "<style ".concat(o2, ">").concat(t, "</style>");
    }, this.getStyleTags = function() {
      if (e2.sealed) throw he(2);
      return e2._emitSheetCSS();
    }, this.getStyleElement = function() {
      var n;
      if (e2.sealed) throw he(2);
      var r2 = e2.instance.toString();
      if (!r2) return [];
      var s2 = ((n = {})[f] = "", n[y] = v, n.dangerouslySetInnerHTML = { __html: r2 }, n), i2 = Ce();
      return i2 && (s2.nonce = i2), [import_react.default.createElement("style", __assign({}, s2, { key: "sc-0-0" }))];
    }, this.seal = function() {
      e2.sealed = true;
    }, this.instance = new ke({ isServer: true }), this.sealed = false;
  }
  return e.prototype.collectStyles = function(e2) {
    if (this.sealed) throw he(2);
    return import_react.default.createElement(Ye, { sheet: this.instance }, e2);
  }, e.prototype.interleaveWithNodeStream = function(e2) {
    throw he(3);
  }, e;
}();
"undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native");
var St = "__sc-".concat(f, "__");
"undefined" != typeof window && (window[St] || (window[St] = 0), 1 === window[St] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window[St] += 1);

// ../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react11 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
var import_react2 = __toESM(require_react(), 1);
var LayoutGroupContext = (0, import_react2.createContext)({});

// ../node_modules/framer-motion/dist/es/utils/use-constant.mjs
var import_react3 = __toESM(require_react(), 1);
function useConstant(init) {
  const ref = (0, import_react3.useRef)(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}

// ../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var import_react4 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/utils/is-browser.mjs
var isBrowser = typeof window !== "undefined";

// ../node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var useIsomorphicLayoutEffect = isBrowser ? import_react4.useLayoutEffect : import_react4.useEffect;

// ../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var React2 = __toESM(require_react(), 1);
var import_react8 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/context/PresenceContext.mjs
var import_react5 = __toESM(require_react(), 1);
var PresenceContext = (0, import_react5.createContext)(null);

// ../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);

// ../node_modules/motion-utils/dist/es/array.mjs
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1)
    arr.push(item);
}
function removeItem(arr, item) {
  const index2 = arr.indexOf(item);
  if (index2 > -1)
    arr.splice(index2, 1);
}
function moveItem([...arr], fromIndex, toIndex) {
  const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
  if (startIndex >= 0 && startIndex < arr.length) {
    const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
    const [item] = arr.splice(fromIndex, 1);
    arr.splice(endIndex, 0, item);
  }
  return arr;
}

// ../node_modules/motion-utils/dist/es/clamp.mjs
var clamp2 = (min2, max2, v2) => {
  if (v2 > max2)
    return max2;
  if (v2 < min2)
    return min2;
  return v2;
};

// ../node_modules/motion-utils/dist/es/errors.mjs
var warning = () => {
};
var invariant = () => {
};
if (true) {
  warning = (check, message) => {
    if (!check && typeof console !== "undefined") {
      console.warn(message);
    }
  };
  invariant = (check, message) => {
    if (!check) {
      throw new Error(message);
    }
  };
}

// ../node_modules/motion-utils/dist/es/global-config.mjs
var MotionGlobalConfig = {};

// ../node_modules/motion-utils/dist/es/is-numerical-string.mjs
var isNumericalString = (v2) => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v2);

// ../node_modules/motion-utils/dist/es/is-object.mjs
function isObject(value) {
  return typeof value === "object" && value !== null;
}

// ../node_modules/motion-utils/dist/es/is-zero-value-string.mjs
var isZeroValueString = (v2) => /^0[^.\s]+$/u.test(v2);

// ../node_modules/motion-utils/dist/es/memo.mjs
function memo(callback) {
  let result;
  return () => {
    if (result === void 0)
      result = callback();
    return result;
  };
}

// ../node_modules/motion-utils/dist/es/noop.mjs
var noop = (any) => any;

// ../node_modules/motion-utils/dist/es/pipe.mjs
var combineFunctions = (a2, b2) => (v2) => b2(a2(v2));
var pipe = (...transformers) => transformers.reduce(combineFunctions);

// ../node_modules/motion-utils/dist/es/progress.mjs
var progress = (from2, to, value) => {
  const toFromDifference = to - from2;
  return toFromDifference === 0 ? 1 : (value - from2) / toFromDifference;
};

// ../node_modules/motion-utils/dist/es/subscription-manager.mjs
var SubscriptionManager = class {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a2, b2, c4) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions)
      return;
    if (numSubscriptions === 1) {
      this.subscriptions[0](a2, b2, c4);
    } else {
      for (let i2 = 0; i2 < numSubscriptions; i2++) {
        const handler = this.subscriptions[i2];
        handler && handler(a2, b2, c4);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
};

// ../node_modules/motion-utils/dist/es/time-conversion.mjs
var secondsToMilliseconds = (seconds) => seconds * 1e3;
var millisecondsToSeconds = (milliseconds) => milliseconds / 1e3;

// ../node_modules/motion-utils/dist/es/velocity-per-second.mjs
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}

// ../node_modules/motion-utils/dist/es/warn-once.mjs
var warned = /* @__PURE__ */ new Set();
function warnOnce(condition, message, element) {
  if (condition || warned.has(message))
    return;
  console.warn(message);
  if (element)
    console.warn(element);
  warned.add(message);
}

// ../node_modules/motion-utils/dist/es/wrap.mjs
var wrap = (min2, max2, v2) => {
  const rangeSize = max2 - min2;
  return ((v2 - min2) % rangeSize + rangeSize) % rangeSize + min2;
};

// ../node_modules/motion-utils/dist/es/easing/cubic-bezier.mjs
var calcBezier = (t, a1, a2) => (((1 - 3 * a2 + 3 * a1) * t + (3 * a2 - 6 * a1)) * t + 3 * a1) * t;
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 12;
function binarySubdivide(x2, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - x2;
    if (currentX > 0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return noop;
  const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);
  return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}

// ../node_modules/motion-utils/dist/es/easing/modifiers/mirror.mjs
var mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;

// ../node_modules/motion-utils/dist/es/easing/modifiers/reverse.mjs
var reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);

// ../node_modules/motion-utils/dist/es/easing/back.mjs
var backOut = cubicBezier(0.33, 1.53, 0.69, 0.99);
var backIn = reverseEasing(backOut);
var backInOut = mirrorEasing(backIn);

// ../node_modules/motion-utils/dist/es/easing/anticipate.mjs
var anticipate = (p2) => (p2 *= 2) < 1 ? 0.5 * backIn(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));

// ../node_modules/motion-utils/dist/es/easing/circ.mjs
var circIn = (p2) => 1 - Math.sin(Math.acos(p2));
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circIn);

// ../node_modules/motion-utils/dist/es/easing/ease.mjs
var easeIn = cubicBezier(0.42, 0, 1, 1);
var easeOut = cubicBezier(0, 0, 0.58, 1);
var easeInOut = cubicBezier(0.42, 0, 0.58, 1);

// ../node_modules/motion-utils/dist/es/easing/utils/is-easing-array.mjs
var isEasingArray = (ease2) => {
  return Array.isArray(ease2) && typeof ease2[0] !== "number";
};

// ../node_modules/motion-utils/dist/es/easing/utils/get-easing-for-segment.mjs
function getEasingForSegment(easing, i2) {
  return isEasingArray(easing) ? easing[wrap(0, easing.length, i2)] : easing;
}

// ../node_modules/motion-utils/dist/es/easing/utils/is-bezier-definition.mjs
var isBezierDefinition = (easing) => Array.isArray(easing) && typeof easing[0] === "number";

// ../node_modules/motion-utils/dist/es/easing/utils/map.mjs
var easingLookup = {
  linear: noop,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
var isValidEasing = (easing) => {
  return typeof easing === "string";
};
var easingDefinitionToFunction = (definition) => {
  if (isBezierDefinition(definition)) {
    invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (isValidEasing(definition)) {
    invariant(easingLookup[definition] !== void 0, `Invalid easing type '${definition}'`);
    return easingLookup[definition];
  }
  return definition;
};

// ../node_modules/motion-dom/dist/es/frameloop/order.mjs
var stepsOrder = [
  "setup",
  // Compute
  "read",
  // Read
  "resolveKeyframes",
  // Write/Read/Write/Read
  "preUpdate",
  // Compute
  "update",
  // Compute
  "preRender",
  // Compute
  "render",
  // Write
  "postRender"
  // Compute
];

// ../node_modules/motion-dom/dist/es/stats/buffer.mjs
var statsBuffer = {
  value: null,
  addProjectionMetrics: null
};

// ../node_modules/motion-dom/dist/es/frameloop/render-step.mjs
function createRenderStep(runNextFrame, stepName) {
  let thisFrame = /* @__PURE__ */ new Set();
  let nextFrame = /* @__PURE__ */ new Set();
  let isProcessing = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  let latestFrameData = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  let numCalls = 0;
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame();
    }
    numCalls++;
    callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (!queue.has(callback))
        queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: (callback) => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: (frameData2) => {
      latestFrameData = frameData2;
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      thisFrame.forEach(triggerCallback);
      if (stepName && statsBuffer.value) {
        statsBuffer.value.frameloop[stepName].push(numCalls);
      }
      numCalls = 0;
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData2);
      }
    }
  };
  return step;
}

// ../node_modules/motion-dom/dist/es/frameloop/batcher.mjs
var maxElapsed = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0,
    timestamp: 0,
    isProcessing: false
  };
  const flagRunNextFrame = () => runNextFrame = true;
  const steps2 = stepsOrder.reduce((acc, key2) => {
    acc[key2] = createRenderStep(flagRunNextFrame, allowKeepAlive ? key2 : void 0);
    return acc;
  }, {});
  const { setup, read, resolveKeyframes, preUpdate, update, preRender, render, postRender } = steps2;
  const processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = false;
    if (!MotionGlobalConfig.useManualTiming) {
      state.delta = useDefaultElapsed ? 1e3 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed), 1);
    }
    state.timestamp = timestamp;
    state.isProcessing = true;
    setup.process(state);
    read.process(state);
    resolveKeyframes.process(state);
    preUpdate.process(state);
    update.process(state);
    preRender.process(state);
    render.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key2) => {
    const step = steps2[key2];
    acc[key2] = (process3, keepAlive = false, immediate = false) => {
      if (!runNextFrame)
        wake();
      return step.schedule(process3, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = (process3) => {
    for (let i2 = 0; i2 < stepsOrder.length; i2++) {
      steps2[stepsOrder[i2]].cancel(process3);
    }
  };
  return { schedule, cancel, state, steps: steps2 };
}

// ../node_modules/motion-dom/dist/es/frameloop/frame.mjs
var { schedule: frame, cancel: cancelFrame, state: frameData, steps: frameSteps } = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : noop, true);

// ../node_modules/motion-dom/dist/es/frameloop/sync-time.mjs
var now;
function clearTime() {
  now = void 0;
}
var time = {
  now: () => {
    if (now === void 0) {
      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    }
    return now;
  },
  set: (newTime) => {
    now = newTime;
    queueMicrotask(clearTime);
  }
};

// ../node_modules/motion-dom/dist/es/stats/animation-count.mjs
var activeAnimations = {
  layout: 0,
  mainThread: 0,
  waapi: 0
};

// ../node_modules/motion-dom/dist/es/animation/utils/is-css-variable.mjs
var checkStringStartsWith = (token2) => (key2) => typeof key2 === "string" && key2.startsWith(token2);
var isCSSVariableName = checkStringStartsWith("--");
var startsAsVariableToken = checkStringStartsWith("var(--");
var isCSSVariableToken = (value) => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken)
    return false;
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
};
var singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

// ../node_modules/motion-dom/dist/es/value/types/numbers/index.mjs
var number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
var alpha = {
  ...number,
  transform: (v2) => clamp2(0, 1, v2)
};
var scale = {
  ...number,
  default: 1
};

// ../node_modules/motion-dom/dist/es/value/types/utils/sanitize.mjs
var sanitize = (v2) => Math.round(v2 * 1e5) / 1e5;

// ../node_modules/motion-dom/dist/es/value/types/utils/float-regex.mjs
var floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

// ../node_modules/motion-dom/dist/es/value/types/utils/is-nullish.mjs
function isNullish(v2) {
  return v2 == null;
}

// ../node_modules/motion-dom/dist/es/value/types/utils/single-color-regex.mjs
var singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

// ../node_modules/motion-dom/dist/es/value/types/color/utils.mjs
var isColorString = (type, testProp) => (v2) => {
  return Boolean(typeof v2 === "string" && singleColorRegex.test(v2) && v2.startsWith(type) || testProp && !isNullish(v2) && Object.prototype.hasOwnProperty.call(v2, testProp));
};
var splitColor = (aName, bName, cName) => (v2) => {
  if (typeof v2 !== "string")
    return v2;
  const [a2, b2, c4, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a2),
    [bName]: parseFloat(b2),
    [cName]: parseFloat(c4),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};

// ../node_modules/motion-dom/dist/es/value/types/color/rgba.mjs
var clampRgbUnit = (v2) => clamp2(0, 255, v2);
var rgbUnit = {
  ...number,
  transform: (v2) => Math.round(clampRgbUnit(v2))
};
var rgba2 = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red: red2, green: green2, blue: blue2, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red2) + ", " + rgbUnit.transform(green2) + ", " + rgbUnit.transform(blue2) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};

// ../node_modules/motion-dom/dist/es/value/types/color/hex.mjs
function parseHex(v2) {
  let r2 = "";
  let g2 = "";
  let b2 = "";
  let a2 = "";
  if (v2.length > 5) {
    r2 = v2.substring(1, 3);
    g2 = v2.substring(3, 5);
    b2 = v2.substring(5, 7);
    a2 = v2.substring(7, 9);
  } else {
    r2 = v2.substring(1, 2);
    g2 = v2.substring(2, 3);
    b2 = v2.substring(3, 4);
    a2 = v2.substring(4, 5);
    r2 += r2;
    g2 += g2;
    b2 += b2;
    a2 += a2;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g2, 16),
    blue: parseInt(b2, 16),
    alpha: a2 ? parseInt(a2, 16) / 255 : 1
  };
}
var hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba2.transform
};

// ../node_modules/motion-dom/dist/es/value/types/numbers/units.mjs
var createUnitType = (unit) => ({
  test: (v2) => typeof v2 === "string" && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = (() => ({
  ...percent,
  parse: (v2) => percent.parse(v2) / 100,
  transform: (v2) => percent.transform(v2 * 100)
}))();

// ../node_modules/motion-dom/dist/es/value/types/color/hsla.mjs
var hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};

// ../node_modules/motion-dom/dist/es/value/types/color/index.mjs
var color2 = {
  test: (v2) => rgba2.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba2.test(v2)) {
      return rgba2.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return typeof v2 === "string" ? v2 : v2.hasOwnProperty("red") ? rgba2.transform(v2) : hsla.transform(v2);
  }
};

// ../node_modules/motion-dom/dist/es/value/types/utils/color-regex.mjs
var colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

// ../node_modules/motion-dom/dist/es/value/types/complex/index.mjs
function test(v2) {
  var _a, _b;
  return isNaN(v2) && typeof v2 === "string" && (((_a = v2.match(floatRegex)) == null ? void 0 : _a.length) || 0) + (((_b = v2.match(colorRegex)) == null ? void 0 : _b.length) || 0) > 0;
}
var NUMBER_TOKEN = "number";
var COLOR_TOKEN = "color";
var VAR_TOKEN = "var";
var VAR_FUNCTION_TOKEN = "var(";
var SPLIT_TOKEN = "${}";
var complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types = [];
  let i2 = 0;
  const tokenised = originalValue.replace(complexRegex, (parsedValue) => {
    if (color2.test(parsedValue)) {
      indexes.color.push(i2);
      types.push(COLOR_TOKEN);
      values.push(color2.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i2);
      types.push(VAR_TOKEN);
      values.push(parsedValue);
    } else {
      indexes.number.push(i2);
      types.push(NUMBER_TOKEN);
      values.push(parseFloat(parsedValue));
    }
    ++i2;
    return SPLIT_TOKEN;
  });
  const split = tokenised.split(SPLIT_TOKEN);
  return { values, split, indexes, types };
}
function parseComplexValue(v2) {
  return analyseComplexValue(v2).values;
}
function createTransformer(source) {
  const { split, types } = analyseComplexValue(source);
  const numSections = split.length;
  return (v2) => {
    let output = "";
    for (let i2 = 0; i2 < numSections; i2++) {
      output += split[i2];
      if (v2[i2] !== void 0) {
        const type = types[i2];
        if (type === NUMBER_TOKEN) {
          output += sanitize(v2[i2]);
        } else if (type === COLOR_TOKEN) {
          output += color2.transform(v2[i2]);
        } else {
          output += v2[i2];
        }
      }
    }
    return output;
  };
}
var convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
function getAnimatableNone(v2) {
  const parsed = parseComplexValue(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
var complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone
};

// ../node_modules/motion-dom/dist/es/value/types/color/hsla-to-rgba.mjs
function hueToRgb(p2, q2, t) {
  if (t < 0)
    t += 1;
  if (t > 1)
    t -= 1;
  if (t < 1 / 6)
    return p2 + (q2 - p2) * 6 * t;
  if (t < 1 / 2)
    return q2;
  if (t < 2 / 3)
    return p2 + (q2 - p2) * (2 / 3 - t) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red2 = 0;
  let green2 = 0;
  let blue2 = 0;
  if (!saturation) {
    red2 = green2 = blue2 = lightness;
  } else {
    const q2 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q2;
    red2 = hueToRgb(p2, q2, hue + 1 / 3);
    green2 = hueToRgb(p2, q2, hue);
    blue2 = hueToRgb(p2, q2, hue - 1 / 3);
  }
  return {
    red: Math.round(red2 * 255),
    green: Math.round(green2 * 255),
    blue: Math.round(blue2 * 255),
    alpha: alpha2
  };
}

// ../node_modules/motion-dom/dist/es/utils/mix/immediate.mjs
function mixImmediate(a2, b2) {
  return (p2) => p2 > 0 ? b2 : a2;
}

// ../node_modules/motion-dom/dist/es/utils/mix/number.mjs
var mixNumber = (from2, to, progress2) => {
  return from2 + (to - from2) * progress2;
};

// ../node_modules/motion-dom/dist/es/utils/mix/color.mjs
var mixLinearColor = (from2, to, v2) => {
  const fromExpo = from2 * from2;
  const expo = v2 * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
};
var colorTypes = [hex, rgba2, hsla];
var getColorType = (v2) => colorTypes.find((type) => type.test(v2));
function asRGBA(color3) {
  const type = getColorType(color3);
  warning(Boolean(type), `'${color3}' is not an animatable color. Use the equivalent color code instead.`);
  if (!Boolean(type))
    return false;
  let model = type.parse(color3);
  if (type === hsla) {
    model = hslaToRgba(model);
  }
  return model;
}
var mixColor = (from2, to) => {
  const fromRGBA = asRGBA(from2);
  const toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA) {
    return mixImmediate(from2, to);
  }
  const blended = { ...fromRGBA };
  return (v2) => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v2);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v2);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v2);
    blended.alpha = mixNumber(fromRGBA.alpha, toRGBA.alpha, v2);
    return rgba2.transform(blended);
  };
};

// ../node_modules/motion-dom/dist/es/utils/mix/visibility.mjs
var invisibleValues = /* @__PURE__ */ new Set(["none", "hidden"]);
function mixVisibility(origin2, target) {
  if (invisibleValues.has(origin2)) {
    return (p2) => p2 <= 0 ? origin2 : target;
  } else {
    return (p2) => p2 >= 1 ? target : origin2;
  }
}

// ../node_modules/motion-dom/dist/es/utils/mix/complex.mjs
function mixNumber2(a2, b2) {
  return (p2) => mixNumber(a2, b2, p2);
}
function getMixer(a2) {
  if (typeof a2 === "number") {
    return mixNumber2;
  } else if (typeof a2 === "string") {
    return isCSSVariableToken(a2) ? mixImmediate : color2.test(a2) ? mixColor : mixComplex;
  } else if (Array.isArray(a2)) {
    return mixArray;
  } else if (typeof a2 === "object") {
    return color2.test(a2) ? mixColor : mixObject;
  }
  return mixImmediate;
}
function mixArray(a2, b2) {
  const output = [...a2];
  const numValues = output.length;
  const blendValue = a2.map((v2, i2) => getMixer(v2)(v2, b2[i2]));
  return (p2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output[i2] = blendValue[i2](p2);
    }
    return output;
  };
}
function mixObject(a2, b2) {
  const output = { ...a2, ...b2 };
  const blendValue = {};
  for (const key2 in output) {
    if (a2[key2] !== void 0 && b2[key2] !== void 0) {
      blendValue[key2] = getMixer(a2[key2])(a2[key2], b2[key2]);
    }
  }
  return (v2) => {
    for (const key2 in blendValue) {
      output[key2] = blendValue[key2](v2);
    }
    return output;
  };
}
function matchOrder(origin2, target) {
  const orderedOrigin = [];
  const pointers = { color: 0, var: 0, number: 0 };
  for (let i2 = 0; i2 < target.values.length; i2++) {
    const type = target.types[i2];
    const originIndex = origin2.indexes[type][pointers[type]];
    const originValue = origin2.values[originIndex] ?? 0;
    orderedOrigin[i2] = originValue;
    pointers[type]++;
  }
  return orderedOrigin;
}
var mixComplex = (origin2, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin2);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (invisibleValues.has(origin2) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
      return mixVisibility(origin2, target);
    }
    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    warning(true, `Complex values '${origin2}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return mixImmediate(origin2, target);
  }
};

// ../node_modules/motion-dom/dist/es/utils/mix/index.mjs
function mix2(from2, to, p2) {
  if (typeof from2 === "number" && typeof to === "number" && typeof p2 === "number") {
    return mixNumber(from2, to, p2);
  }
  const mixer = getMixer(from2);
  return mixer(from2, to);
}

// ../node_modules/motion-dom/dist/es/animation/drivers/frame.mjs
var frameloopDriver = (update) => {
  const passTimestamp = ({ timestamp }) => update(timestamp);
  return {
    start: (keepAlive = true) => frame.update(passTimestamp, keepAlive),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
};

// ../node_modules/motion-dom/dist/es/animation/waapi/utils/linear.mjs
var generateLinearEasing = (easing, duration, resolution = 10) => {
  let points = "";
  const numPoints = Math.max(Math.round(duration / resolution), 2);
  for (let i2 = 0; i2 < numPoints; i2++) {
    points += easing(i2 / (numPoints - 1)) + ", ";
  }
  return `linear(${points.substring(0, points.length - 2)})`;
};

// ../node_modules/motion-dom/dist/es/animation/generators/utils/calc-duration.mjs
var maxGeneratorDuration = 2e4;
function calcGeneratorDuration(generator) {
  let duration = 0;
  const timeStep = 50;
  let state = generator.next(duration);
  while (!state.done && duration < maxGeneratorDuration) {
    duration += timeStep;
    state = generator.next(duration);
  }
  return duration >= maxGeneratorDuration ? Infinity : duration;
}

// ../node_modules/motion-dom/dist/es/animation/generators/utils/create-generator-easing.mjs
function createGeneratorEasing(options, scale2 = 100, createGenerator) {
  const generator = createGenerator({ ...options, keyframes: [0, scale2] });
  const duration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
  return {
    type: "keyframes",
    ease: (progress2) => {
      return generator.next(duration * progress2).value / scale2;
    },
    duration: millisecondsToSeconds(duration)
  };
}

// ../node_modules/motion-dom/dist/es/animation/generators/utils/velocity.mjs
var velocitySampleDuration = 5;
function calcGeneratorVelocity(resolveValue, t, current) {
  const prevT = Math.max(t - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t - prevT);
}

// ../node_modules/motion-dom/dist/es/animation/generators/spring/defaults.mjs
var springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1,
  velocity: 0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 5e-3,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
};

// ../node_modules/motion-dom/dist/es/animation/generators/spring/find.mjs
var safeMin = 1e-3;
function findSpring({ duration = springDefaults.duration, bounce = springDefaults.bounce, velocity = springDefaults.velocity, mass = springDefaults.mass }) {
  let envelope;
  let derivative;
  warning(duration <= secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp2(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
  duration = clamp2(springDefaults.minDuration, springDefaults.maxDuration, millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a2 = exponentialDecay - velocity;
      const b2 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c4 = Math.exp(-delta);
      return safeMin - a2 / b2 * c4;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f2 = Math.exp(-delta);
      const g2 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f2) / g2;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a2 * b2;
    };
    derivative = (undampedFreq2) => {
      const a2 = Math.exp(-undampedFreq2 * duration);
      const b2 = (velocity - undampedFreq2) * (duration * duration);
      return a2 * b2;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

// ../node_modules/motion-dom/dist/es/animation/generators/spring/index.mjs
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key2) => options[key2] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: false,
    ...options
  };
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    if (options.visualDuration) {
      const visualDuration = options.visualDuration;
      const root = 2 * Math.PI / (visualDuration * 1.2);
      const stiffness = root * root;
      const damping = 2 * clamp2(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      };
      springOptions.isResolvedFromDuration = true;
    }
  }
  return springOptions;
}
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration !== "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let { restSpeed, restDelta } = options;
  const origin2 = options.keyframes[0];
  const target = options.keyframes[options.keyframes.length - 1];
  const state = { done: false, value: origin2 };
  const { stiffness, damping, mass, duration, velocity, isResolvedFromDuration } = getSpringOptions({
    ...options,
    velocity: -millisecondsToSeconds(options.velocity || 0)
  });
  const initialVelocity = velocity || 0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin2;
  const undampedAngularFreq = millisecondsToSeconds(Math.sqrt(stiffness / mass));
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
    };
  } else if (dampingRatio === 1) {
    resolveSpring = (t) => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
  } else {
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = (t) => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      const freqForT = Math.min(dampedAngularFreq * t, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: (t) => {
      const current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        let currentVelocity = t === 0 ? initialVelocity : 0;
        if (dampingRatio < 1) {
          currentVelocity = t === 0 ? secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    },
    toString: () => {
      const calculatedDuration = Math.min(calcGeneratorDuration(generator), maxGeneratorDuration);
      const easing = generateLinearEasing((progress2) => generator.next(calculatedDuration * progress2).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    },
    toTransition: () => {
    }
  };
  return generator;
}
spring.applyToOptions = (options) => {
  const generatorOptions = createGeneratorEasing(options, 100, spring);
  options.ease = generatorOptions.ease;
  options.duration = secondsToMilliseconds(generatorOptions.duration);
  options.type = "keyframes";
  return options;
};

// ../node_modules/motion-dom/dist/es/animation/generators/inertia.mjs
function inertia({ keyframes: keyframes2, velocity = 0, power = 0.8, timeConstant = 325, bounceDamping = 10, bounceStiffness = 500, modifyTarget, min: min2, max: max2, restDelta = 0.5, restSpeed }) {
  const origin2 = keyframes2[0];
  const state = {
    done: false,
    value: origin2
  };
  const isOutOfBounds = (v2) => min2 !== void 0 && v2 < min2 || max2 !== void 0 && v2 > max2;
  const nearestBoundary = (v2) => {
    if (min2 === void 0)
      return max2;
    if (max2 === void 0)
      return min2;
    return Math.abs(min2 - v2) < Math.abs(max2 - v2) ? min2 : max2;
  };
  let amplitude = power * velocity;
  const ideal = origin2 + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - origin2;
  const calcDelta = (t) => -amplitude * Math.exp(-t / timeConstant);
  const calcLatest = (t) => target + calcDelta(t);
  const applyFriction = (t) => {
    const delta = calcDelta(t);
    const latest = calcLatest(t);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  };
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = (t) => {
    if (!isOutOfBounds(state.value))
      return;
    timeReachedBoundary = t;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: (t) => {
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === void 0) {
        hasUpdatedFrame = true;
        applyFriction(t);
        checkCatchBoundary(t);
      }
      if (timeReachedBoundary !== void 0 && t >= timeReachedBoundary) {
        return spring$1.next(t - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t);
        return state;
      }
    }
  };
}

// ../node_modules/motion-dom/dist/es/utils/interpolate.mjs
function createMixers(output, ease2, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || MotionGlobalConfig.mix || mix2;
  const numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease2) {
      const easingFunction = Array.isArray(ease2) ? ease2[i2] || noop : ease2;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function interpolate(input, output, { clamp: isClamp = true, ease: ease2, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  if (inputLength === 1)
    return () => output[0];
  if (inputLength === 2 && output[0] === output[1])
    return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease2, mixer);
  const numMixers = mixers.length;
  const interpolator = (v2) => {
    if (isZeroDeltaRange && v2 < input[0])
      return output[0];
    let i2 = 0;
    if (numMixers > 1) {
      for (; i2 < input.length - 2; i2++) {
        if (v2 < input[i2 + 1])
          break;
      }
    }
    const progressInRange = progress(input[i2], input[i2 + 1], v2);
    return mixers[i2](progressInRange);
  };
  return isClamp ? (v2) => interpolator(clamp2(input[0], input[inputLength - 1], v2)) : interpolator;
}

// ../node_modules/motion-dom/dist/es/animation/keyframes/offsets/fill.mjs
function fillOffset(offset4, remaining) {
  const min2 = offset4[offset4.length - 1];
  for (let i2 = 1; i2 <= remaining; i2++) {
    const offsetProgress = progress(0, remaining, i2);
    offset4.push(mixNumber(min2, 1, offsetProgress));
  }
}

// ../node_modules/motion-dom/dist/es/animation/keyframes/offsets/default.mjs
function defaultOffset(arr) {
  const offset4 = [0];
  fillOffset(offset4, arr.length - 1);
  return offset4;
}

// ../node_modules/motion-dom/dist/es/animation/keyframes/offsets/time.mjs
function convertOffsetToTimes(offset4, duration) {
  return offset4.map((o2) => o2 * duration);
}

// ../node_modules/motion-dom/dist/es/animation/generators/keyframes.mjs
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({ duration = 300, keyframes: keyframeValues, times, ease: ease2 = "easeInOut" }) {
  const easingFunctions = isEasingArray(ease2) ? ease2.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease2);
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  const absoluteTimes = convertOffsetToTimes(
    // Only use the provided offsets if they're the correct length
    // TODO Maybe we should warn here if there's a length mismatch
    times && times.length === keyframeValues.length ? times : defaultOffset(keyframeValues),
    duration
  );
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: (t) => {
      state.value = mapTimeToKeyframe(t);
      state.done = t >= duration;
      return state;
    }
  };
}

// ../node_modules/motion-dom/dist/es/animation/keyframes/get-final.mjs
var isNotNull = (value) => value !== null;
function getFinalKeyframe(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe, speed = 1) {
  const resolvedKeyframes = keyframes2.filter(isNotNull);
  const useFirstKeyframe = speed < 0 || repeat && repeatType !== "loop" && repeat % 2 === 1;
  const index2 = useFirstKeyframe ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}

// ../node_modules/motion-dom/dist/es/animation/utils/replace-transition-type.mjs
var transitionTypeMap = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes,
  spring
};
function replaceTransitionType(transition) {
  if (typeof transition.type === "string") {
    transition.type = transitionTypeMap[transition.type];
  }
}

// ../node_modules/motion-dom/dist/es/animation/utils/WithPromise.mjs
var WithPromise = class {
  constructor() {
    this.updateFinished();
  }
  get finished() {
    return this._finished;
  }
  updateFinished() {
    this._finished = new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  notifyFinished() {
    this.resolve();
  }
  /**
   * Allows the animation to be awaited.
   *
   * @deprecated Use `finished` instead.
   */
  then(onResolve, onReject) {
    return this.finished.then(onResolve, onReject);
  }
};

// ../node_modules/motion-dom/dist/es/animation/JSAnimation.mjs
var percentToProgress = (percent2) => percent2 / 100;
var JSAnimation = class extends WithPromise {
  constructor(options) {
    super();
    this.state = "idle";
    this.startTime = null;
    this.isStopped = false;
    this.currentTime = 0;
    this.holdTime = null;
    this.playbackSpeed = 1;
    this.stop = (sync2 = true) => {
      var _a, _b;
      if (sync2) {
        const { motionValue: motionValue2 } = this.options;
        if (motionValue2 && motionValue2.updatedAt !== time.now()) {
          this.tick(time.now());
        }
      }
      this.isStopped = true;
      if (this.state === "idle")
        return;
      this.teardown();
      (_b = (_a = this.options).onStop) == null ? void 0 : _b.call(_a);
    };
    activeAnimations.mainThread++;
    this.options = options;
    this.initAnimation();
    this.play();
    if (options.autoplay === false)
      this.pause();
  }
  initAnimation() {
    const { options } = this;
    replaceTransitionType(options);
    const { type = keyframes, repeat = 0, repeatDelay = 0, repeatType, velocity = 0 } = options;
    let { keyframes: keyframes$1 } = options;
    const generatorFactory = type || keyframes;
    if (generatorFactory !== keyframes) {
      invariant(keyframes$1.length <= 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
    }
    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
      this.mixKeyframes = pipe(percentToProgress, mix2(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({ ...options, keyframes: keyframes$1 });
    if (repeatType === "mirror") {
      this.mirroredGenerator = generatorFactory({
        ...options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -velocity
      });
    }
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = calcGeneratorDuration(generator);
    }
    const { calculatedDuration } = generator;
    this.calculatedDuration = calculatedDuration;
    this.resolvedDuration = calculatedDuration + repeatDelay;
    this.totalDuration = this.resolvedDuration * (repeat + 1) - repeatDelay;
    this.generator = generator;
  }
  updateTime(timestamp) {
    const animationTime = Math.round(timestamp - this.startTime) * this.playbackSpeed;
    if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      this.currentTime = animationTime;
    }
  }
  tick(timestamp, sample = false) {
    const { generator, totalDuration, mixKeyframes, mirroredGenerator, resolvedDuration, calculatedDuration } = this;
    if (this.startTime === null)
      return generator.next(0);
    const { delay: delay2 = 0, keyframes: keyframes2, repeat, repeatType, repeatDelay, type, onUpdate, finalKeyframe } = this.options;
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    if (sample) {
      this.currentTime = timestamp;
    } else {
      this.updateTime(timestamp);
    }
    const timeWithoutDelay = this.currentTime - delay2 * (this.playbackSpeed >= 0 ? 1 : -1);
    const isInDelayPhase = this.playbackSpeed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      const progress2 = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      let currentIteration = Math.floor(progress2);
      let iterationProgress = progress2 % 1;
      if (!iterationProgress && progress2 >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp2(0, 1, iterationProgress) * resolvedDuration;
    }
    const state = isInDelayPhase ? { done: false, value: keyframes2[0] } : frameGenerator.next(elapsed);
    if (mixKeyframes) {
      state.value = mixKeyframes(state.value);
    }
    let { done } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.playbackSpeed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && type !== inertia) {
      state.value = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.finished.then(resolve, reject);
  }
  get duration() {
    return millisecondsToSeconds(this.calculatedDuration);
  }
  get time() {
    return millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    var _a;
    newTime = secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.playbackSpeed;
    }
    (_a = this.driver) == null ? void 0 : _a.start(false);
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    this.updateTime(time.now());
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    var _a, _b;
    if (this.isStopped)
      return;
    const { driver = frameloopDriver, startTime } = this.options;
    if (!this.driver) {
      this.driver = driver((timestamp) => this.tick(timestamp));
    }
    (_b = (_a = this.options).onPlay) == null ? void 0 : _b.call(_a);
    const now2 = this.driver.now();
    if (this.state === "finished") {
      this.updateFinished();
      this.startTime = now2;
    } else if (this.holdTime !== null) {
      this.startTime = now2 - this.holdTime;
    } else if (!this.startTime) {
      this.startTime = startTime ?? now2;
    }
    if (this.state === "finished" && this.speed < 0) {
      this.startTime += this.calculatedDuration;
    }
    this.holdTime = null;
    this.state = "running";
    this.driver.start();
  }
  pause() {
    this.state = "paused";
    this.updateTime(time.now());
    this.holdTime = this.currentTime;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    var _a, _b;
    this.notifyFinished();
    this.teardown();
    this.state = "finished";
    (_b = (_a = this.options).onComplete) == null ? void 0 : _b.call(_a);
  }
  cancel() {
    var _a, _b;
    this.holdTime = null;
    this.startTime = 0;
    this.tick(0);
    this.teardown();
    (_b = (_a = this.options).onCancel) == null ? void 0 : _b.call(_a);
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.startTime = this.holdTime = null;
    activeAnimations.mainThread--;
  }
  stopDriver() {
    if (!this.driver)
      return;
    this.driver.stop();
    this.driver = void 0;
  }
  sample(sampleTime) {
    this.startTime = 0;
    return this.tick(sampleTime, true);
  }
  attachTimeline(timeline) {
    var _a;
    if (this.options.allowFlatten) {
      this.options.type = "keyframes";
      this.options.ease = "linear";
      this.initAnimation();
    }
    (_a = this.driver) == null ? void 0 : _a.stop();
    return timeline.observe(this);
  }
};

// ../node_modules/motion-dom/dist/es/animation/keyframes/utils/fill-wildcards.mjs
function fillWildcards(keyframes2) {
  for (let i2 = 1; i2 < keyframes2.length; i2++) {
    keyframes2[i2] ?? (keyframes2[i2] = keyframes2[i2 - 1]);
  }
}

// ../node_modules/motion-dom/dist/es/render/dom/parse-transform.mjs
var radToDeg = (rad) => rad * 180 / Math.PI;
var rotate = (v2) => {
  const angle = radToDeg(Math.atan2(v2[1], v2[0]));
  return rebaseAngle(angle);
};
var matrix2dParsers = {
  x: 4,
  y: 5,
  translateX: 4,
  translateY: 5,
  scaleX: 0,
  scaleY: 3,
  scale: (v2) => (Math.abs(v2[0]) + Math.abs(v2[3])) / 2,
  rotate,
  rotateZ: rotate,
  skewX: (v2) => radToDeg(Math.atan(v2[1])),
  skewY: (v2) => radToDeg(Math.atan(v2[2])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[2])) / 2
};
var rebaseAngle = (angle) => {
  angle = angle % 360;
  if (angle < 0)
    angle += 360;
  return angle;
};
var rotateZ = rotate;
var scaleX = (v2) => Math.sqrt(v2[0] * v2[0] + v2[1] * v2[1]);
var scaleY = (v2) => Math.sqrt(v2[4] * v2[4] + v2[5] * v2[5]);
var matrix3dParsers = {
  x: 12,
  y: 13,
  z: 14,
  translateX: 12,
  translateY: 13,
  translateZ: 14,
  scaleX,
  scaleY,
  scale: (v2) => (scaleX(v2) + scaleY(v2)) / 2,
  rotateX: (v2) => rebaseAngle(radToDeg(Math.atan2(v2[6], v2[5]))),
  rotateY: (v2) => rebaseAngle(radToDeg(Math.atan2(-v2[2], v2[0]))),
  rotateZ,
  rotate: rotateZ,
  skewX: (v2) => radToDeg(Math.atan(v2[4])),
  skewY: (v2) => radToDeg(Math.atan(v2[1])),
  skew: (v2) => (Math.abs(v2[1]) + Math.abs(v2[4])) / 2
};
function defaultTransformValue(name) {
  return name.includes("scale") ? 1 : 0;
}
function parseValueFromTransform(transform2, name) {
  if (!transform2 || transform2 === "none") {
    return defaultTransformValue(name);
  }
  const matrix3dMatch = transform2.match(/^matrix3d\(([-\d.e\s,]+)\)$/u);
  let parsers;
  let match2;
  if (matrix3dMatch) {
    parsers = matrix3dParsers;
    match2 = matrix3dMatch;
  } else {
    const matrix2dMatch = transform2.match(/^matrix\(([-\d.e\s,]+)\)$/u);
    parsers = matrix2dParsers;
    match2 = matrix2dMatch;
  }
  if (!match2) {
    return defaultTransformValue(name);
  }
  const valueParser = parsers[name];
  const values = match2[1].split(",").map(convertTransformToNumber);
  return typeof valueParser === "function" ? valueParser(values) : values[valueParser];
}
var readTransformValue = (instance, name) => {
  const { transform: transform2 = "none" } = getComputedStyle(instance);
  return parseValueFromTransform(transform2, name);
};
function convertTransformToNumber(value) {
  return parseFloat(value.trim());
}

// ../node_modules/motion-dom/dist/es/render/utils/keys-transform.mjs
var transformPropOrder = [
  "transformPerspective",
  "x",
  "y",
  "z",
  "translateX",
  "translateY",
  "translateZ",
  "scale",
  "scaleX",
  "scaleY",
  "rotate",
  "rotateX",
  "rotateY",
  "rotateZ",
  "skew",
  "skewX",
  "skewY"
];
var transformProps = (() => new Set(transformPropOrder))();

// ../node_modules/motion-dom/dist/es/animation/keyframes/utils/unit-conversion.mjs
var isNumOrPxType = (v2) => v2 === number || v2 === px;
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformPropOrder.filter((key2) => !transformKeys.has(key2));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach((key2) => {
    const value = visualElement.getValue(key2);
    if (value !== void 0) {
      removedTransforms.push([key2, value.get()]);
      value.set(key2.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
var positionalValues = {
  // Dimensions
  width: ({ x: x2 }, { paddingLeft = "0", paddingRight = "0" }) => x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({ y: y2 }, { paddingTop = "0", paddingBottom = "0" }) => y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, { top }) => parseFloat(top),
  left: (_bbox, { left }) => parseFloat(left),
  bottom: ({ y: y2 }, { top }) => parseFloat(top) + (y2.max - y2.min),
  right: ({ x: x2 }, { left }) => parseFloat(left) + (x2.max - x2.min),
  // Transform
  x: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "x"),
  y: (_bbox, { transform: transform2 }) => parseValueFromTransform(transform2, "y")
};
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;

// ../node_modules/motion-dom/dist/es/animation/keyframes/KeyframesResolver.mjs
var toResolve = /* @__PURE__ */ new Set();
var isScheduled = false;
var anyNeedsMeasurement = false;
var isForced = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter((resolver) => resolver.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map((resolver) => resolver.element));
    const transformsToRestore = /* @__PURE__ */ new Map();
    elementsToMeasure.forEach((element) => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length)
        return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    resolversToMeasure.forEach((resolver) => resolver.measureInitialState());
    elementsToMeasure.forEach((element) => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key2, value]) => {
          var _a;
          (_a = element.getValue(key2)) == null ? void 0 : _a.set(value);
        });
      }
    });
    resolversToMeasure.forEach((resolver) => resolver.measureEndState());
    resolversToMeasure.forEach((resolver) => {
      if (resolver.suspendedScrollY !== void 0) {
        window.scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach((resolver) => resolver.complete(isForced));
  toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach((resolver) => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
function flushKeyframeResolvers() {
  isForced = true;
  readAllKeyframes();
  measureAllKeyframes();
  isForced = false;
}
var KeyframeResolver = class {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element, isAsync = false) {
    this.state = "pending";
    this.isAsync = false;
    this.needsMeasurement = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name;
    this.motionValue = motionValue2;
    this.element = element;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.state = "scheduled";
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame.read(readAllKeyframes);
        frame.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const { unresolvedKeyframes, name, element, motionValue: motionValue2 } = this;
    if (unresolvedKeyframes[0] === null) {
      const currentValue = motionValue2 == null ? void 0 : motionValue2.get();
      const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
      if (currentValue !== void 0) {
        unresolvedKeyframes[0] = currentValue;
      } else if (element && name) {
        const valueAsRead = element.readValue(name, finalKeyframe);
        if (valueAsRead !== void 0 && valueAsRead !== null) {
          unresolvedKeyframes[0] = valueAsRead;
        }
      }
      if (unresolvedKeyframes[0] === void 0) {
        unresolvedKeyframes[0] = finalKeyframe;
      }
      if (motionValue2 && currentValue === void 0) {
        motionValue2.set(unresolvedKeyframes[0]);
      }
    }
    fillWildcards(unresolvedKeyframes);
  }
  setFinalKeyframe() {
  }
  measureInitialState() {
  }
  renderEndStyles() {
  }
  measureEndState() {
  }
  complete(isForcedComplete = false) {
    this.state = "complete";
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, isForcedComplete);
    toResolve.delete(this);
  }
  cancel() {
    if (this.state === "scheduled") {
      toResolve.delete(this);
      this.state = "pending";
    }
  }
  resume() {
    if (this.state === "pending")
      this.scheduleResolve();
  }
};

// ../node_modules/motion-dom/dist/es/render/dom/is-css-var.mjs
var isCSSVar = (name) => name.startsWith("--");

// ../node_modules/motion-dom/dist/es/render/dom/style-set.mjs
function setStyle(element, name, value) {
  isCSSVar(name) ? element.style.setProperty(name, value) : element.style[name] = value;
}

// ../node_modules/motion-dom/dist/es/utils/supports/scroll-timeline.mjs
var supportsScrollTimeline = memo(() => window.ScrollTimeline !== void 0);

// ../node_modules/motion-dom/dist/es/utils/supports/flags.mjs
var supportsFlags = {};

// ../node_modules/motion-dom/dist/es/utils/supports/memo.mjs
function memoSupports(callback, supportsFlag) {
  const memoized = memo(callback);
  return () => supportsFlags[supportsFlag] ?? memoized();
}

// ../node_modules/motion-dom/dist/es/utils/supports/linear-easing.mjs
var supportsLinearEasing = memoSupports(() => {
  try {
    document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" });
  } catch (e) {
    return false;
  }
  return true;
}, "linearEasing");

// ../node_modules/motion-dom/dist/es/animation/waapi/easing/cubic-bezier.mjs
var cubicBezierAsString = ([a2, b2, c4, d]) => `cubic-bezier(${a2}, ${b2}, ${c4}, ${d})`;

// ../node_modules/motion-dom/dist/es/animation/waapi/easing/supported.mjs
var supportedWaapiEasing = {
  linear: "linear",
  ease: "ease",
  easeIn: "ease-in",
  easeOut: "ease-out",
  easeInOut: "ease-in-out",
  circIn: cubicBezierAsString([0, 0.65, 0.55, 1]),
  circOut: cubicBezierAsString([0.55, 0, 1, 0.45]),
  backIn: cubicBezierAsString([0.31, 0.01, 0.66, -0.59]),
  backOut: cubicBezierAsString([0.33, 1.53, 0.69, 0.99])
};

// ../node_modules/motion-dom/dist/es/animation/waapi/easing/map-easing.mjs
function mapEasingToNativeEasing(easing, duration) {
  if (!easing) {
    return void 0;
  } else if (typeof easing === "function") {
    return supportsLinearEasing() ? generateLinearEasing(easing, duration) : "ease-out";
  } else if (isBezierDefinition(easing)) {
    return cubicBezierAsString(easing);
  } else if (Array.isArray(easing)) {
    return easing.map((segmentEasing) => mapEasingToNativeEasing(segmentEasing, duration) || supportedWaapiEasing.easeOut);
  } else {
    return supportedWaapiEasing[easing];
  }
}

// ../node_modules/motion-dom/dist/es/animation/waapi/start-waapi-animation.mjs
function startWaapiAnimation(element, valueName, keyframes2, { delay: delay2 = 0, duration = 300, repeat = 0, repeatType = "loop", ease: ease2 = "easeOut", times } = {}, pseudoElement = void 0) {
  const keyframeOptions = {
    [valueName]: keyframes2
  };
  if (times)
    keyframeOptions.offset = times;
  const easing = mapEasingToNativeEasing(ease2, duration);
  if (Array.isArray(easing))
    keyframeOptions.easing = easing;
  if (statsBuffer.value) {
    activeAnimations.waapi++;
  }
  const options = {
    delay: delay2,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  };
  if (pseudoElement)
    options.pseudoElement = pseudoElement;
  const animation2 = element.animate(keyframeOptions, options);
  if (statsBuffer.value) {
    animation2.finished.finally(() => {
      activeAnimations.waapi--;
    });
  }
  return animation2;
}

// ../node_modules/motion-dom/dist/es/animation/generators/utils/is-generator.mjs
function isGenerator(type) {
  return typeof type === "function" && "applyToOptions" in type;
}

// ../node_modules/motion-dom/dist/es/animation/waapi/utils/apply-generator.mjs
function applyGeneratorOptions({ type, ...options }) {
  if (isGenerator(type) && supportsLinearEasing()) {
    return type.applyToOptions(options);
  } else {
    options.duration ?? (options.duration = 300);
    options.ease ?? (options.ease = "easeOut");
  }
  return options;
}

// ../node_modules/motion-dom/dist/es/animation/NativeAnimation.mjs
var NativeAnimation = class extends WithPromise {
  constructor(options) {
    super();
    this.finishedTime = null;
    this.isStopped = false;
    if (!options)
      return;
    const { element, name, keyframes: keyframes2, pseudoElement, allowFlatten = false, finalKeyframe, onComplete } = options;
    this.isPseudoElement = Boolean(pseudoElement);
    this.allowFlatten = allowFlatten;
    this.options = options;
    invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "motion"?`);
    const transition = applyGeneratorOptions(options);
    this.animation = startWaapiAnimation(element, name, keyframes2, transition, pseudoElement);
    if (transition.autoplay === false) {
      this.animation.pause();
    }
    this.animation.onfinish = () => {
      this.finishedTime = this.time;
      if (!pseudoElement) {
        const keyframe2 = getFinalKeyframe(keyframes2, this.options, finalKeyframe, this.speed);
        if (this.updateMotionValue) {
          this.updateMotionValue(keyframe2);
        } else {
          setStyle(element, name, keyframe2);
        }
        this.animation.cancel();
      }
      onComplete == null ? void 0 : onComplete();
      this.notifyFinished();
    };
  }
  play() {
    if (this.isStopped)
      return;
    this.animation.play();
    if (this.state === "finished") {
      this.updateFinished();
    }
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    var _a, _b;
    (_b = (_a = this.animation).finish) == null ? void 0 : _b.call(_a);
  }
  cancel() {
    try {
      this.animation.cancel();
    } catch (e) {
    }
  }
  stop() {
    if (this.isStopped)
      return;
    this.isStopped = true;
    const { state } = this;
    if (state === "idle" || state === "finished") {
      return;
    }
    if (this.updateMotionValue) {
      this.updateMotionValue();
    } else {
      this.commitStyles();
    }
    if (!this.isPseudoElement)
      this.cancel();
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * In this method, we commit styles back to the DOM before cancelling
   * the animation.
   *
   * This is designed to be overridden by NativeAnimationExtended, which
   * will create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to also correctly calculate velocity for any subsequent animation
   * while deferring the commit until the next animation frame.
   */
  commitStyles() {
    var _a, _b;
    if (!this.isPseudoElement) {
      (_b = (_a = this.animation).commitStyles) == null ? void 0 : _b.call(_a);
    }
  }
  get duration() {
    var _a, _b;
    const duration = ((_b = (_a = this.animation.effect) == null ? void 0 : _a.getComputedTiming) == null ? void 0 : _b.call(_a).duration) || 0;
    return millisecondsToSeconds(Number(duration));
  }
  get time() {
    return millisecondsToSeconds(Number(this.animation.currentTime) || 0);
  }
  set time(newTime) {
    this.finishedTime = null;
    this.animation.currentTime = secondsToMilliseconds(newTime);
  }
  /**
   * The playback speed of the animation.
   * 1 = normal speed, 2 = double speed, 0.5 = half speed.
   */
  get speed() {
    return this.animation.playbackRate;
  }
  set speed(newSpeed) {
    if (newSpeed < 0)
      this.finishedTime = null;
    this.animation.playbackRate = newSpeed;
  }
  get state() {
    return this.finishedTime !== null ? "finished" : this.animation.playState;
  }
  get startTime() {
    return Number(this.animation.startTime);
  }
  set startTime(newStartTime) {
    this.animation.startTime = newStartTime;
  }
  /**
   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.
   */
  attachTimeline({ timeline, observe }) {
    var _a;
    if (this.allowFlatten) {
      (_a = this.animation.effect) == null ? void 0 : _a.updateTiming({ easing: "linear" });
    }
    this.animation.onfinish = null;
    if (timeline && supportsScrollTimeline()) {
      this.animation.timeline = timeline;
      return noop;
    } else {
      return observe(this);
    }
  }
};

// ../node_modules/motion-dom/dist/es/animation/waapi/utils/unsupported-easing.mjs
var unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key2) {
  return key2 in unsupportedEasingFunctions;
}
function replaceStringEasing(transition) {
  if (typeof transition.ease === "string" && isUnsupportedEase(transition.ease)) {
    transition.ease = unsupportedEasingFunctions[transition.ease];
  }
}

// ../node_modules/motion-dom/dist/es/animation/NativeAnimationExtended.mjs
var sampleDelta = 10;
var NativeAnimationExtended = class extends NativeAnimation {
  constructor(options) {
    replaceStringEasing(options);
    replaceTransitionType(options);
    super(options);
    if (options.startTime) {
      this.startTime = options.startTime;
    }
    this.options = options;
  }
  /**
   * WAAPI doesn't natively have any interruption capabilities.
   *
   * Rather than read commited styles back out of the DOM, we can
   * create a renderless JS animation and sample it twice to calculate
   * its current value, "previous" value, and therefore allow
   * Motion to calculate velocity for any subsequent animation.
   */
  updateMotionValue(value) {
    const { motionValue: motionValue2, onUpdate, onComplete, element, ...options } = this.options;
    if (!motionValue2)
      return;
    if (value !== void 0) {
      motionValue2.set(value);
      return;
    }
    const sampleAnimation = new JSAnimation({
      ...options,
      autoplay: false
    });
    const sampleTime = secondsToMilliseconds(this.finishedTime ?? this.time);
    motionValue2.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    sampleAnimation.stop();
  }
};

// ../node_modules/motion-dom/dist/es/animation/utils/is-animatable.mjs
var isAnimatable = (value, name) => {
  if (name === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  (complex.test(value) || value === "0") && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};

// ../node_modules/motion-dom/dist/es/animation/utils/can-animate.mjs
function hasKeyframesChanged(keyframes2) {
  const current = keyframes2[0];
  if (keyframes2.length === 1)
    return true;
  for (let i2 = 0; i2 < keyframes2.length; i2++) {
    if (keyframes2[i2] !== current)
      return true;
  }
}
function canAnimate(keyframes2, name, type, velocity) {
  const originKeyframe = keyframes2[0];
  if (originKeyframe === null)
    return false;
  if (name === "display" || name === "visibility")
    return true;
  const targetKeyframe = keyframes2[keyframes2.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes2) || (type === "spring" || isGenerator(type)) && velocity;
}

// ../node_modules/motion-dom/dist/es/utils/is-html-element.mjs
function isHTMLElement(element) {
  return isObject(element) && "offsetHeight" in element;
}

// ../node_modules/motion-dom/dist/es/animation/waapi/supports/waapi.mjs
var acceleratedValues = /* @__PURE__ */ new Set([
  "opacity",
  "clipPath",
  "filter",
  "transform"
  // TODO: Could be re-enabled now we have support for linear() easing
  // "background-color"
]);
var supportsWaapi = memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));
function supportsBrowserAnimation(options) {
  var _a;
  const { motionValue: motionValue2, name, repeatDelay, repeatType, damping, type } = options;
  if (!isHTMLElement((_a = motionValue2 == null ? void 0 : motionValue2.owner) == null ? void 0 : _a.current)) {
    return false;
  }
  const { onUpdate, transformTemplate } = motionValue2.owner.getProps();
  return supportsWaapi() && name && acceleratedValues.has(name) && (name !== "transform" || !transformTemplate) && /**
   * If we're outputting values to onUpdate then we can't use WAAPI as there's
   * no way to read the value from WAAPI every frame.
   */
  !onUpdate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
}

// ../node_modules/motion-dom/dist/es/animation/AsyncMotionValueAnimation.mjs
var MAX_RESOLVE_DELAY = 40;
var AsyncMotionValueAnimation = class extends WithPromise {
  constructor({ autoplay = true, delay: delay2 = 0, type = "keyframes", repeat = 0, repeatDelay = 0, repeatType = "loop", keyframes: keyframes2, name, motionValue: motionValue2, element, ...options }) {
    var _a;
    super();
    this.stop = () => {
      var _a2, _b;
      if (this._animation) {
        this._animation.stop();
        (_a2 = this.stopTimeline) == null ? void 0 : _a2.call(this);
      }
      (_b = this.keyframeResolver) == null ? void 0 : _b.cancel();
    };
    this.createdAt = time.now();
    const optionsWithDefaults = {
      autoplay,
      delay: delay2,
      type,
      repeat,
      repeatDelay,
      repeatType,
      name,
      motionValue: motionValue2,
      element,
      ...options
    };
    const KeyframeResolver$1 = (element == null ? void 0 : element.KeyframeResolver) || KeyframeResolver;
    this.keyframeResolver = new KeyframeResolver$1(keyframes2, (resolvedKeyframes, finalKeyframe, forced) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe, optionsWithDefaults, !forced), name, motionValue2, element);
    (_a = this.keyframeResolver) == null ? void 0 : _a.scheduleResolve();
  }
  onKeyframesResolved(keyframes2, finalKeyframe, options, sync2) {
    this.keyframeResolver = void 0;
    const { name, type, velocity, delay: delay2, isHandoff, onUpdate } = options;
    this.resolvedAt = time.now();
    if (!canAnimate(keyframes2, name, type, velocity)) {
      if (MotionGlobalConfig.instantAnimations || !delay2) {
        onUpdate == null ? void 0 : onUpdate(getFinalKeyframe(keyframes2, options, finalKeyframe));
      }
      keyframes2[0] = keyframes2[keyframes2.length - 1];
      options.duration = 0;
      options.repeat = 0;
    }
    const startTime = sync2 ? !this.resolvedAt ? this.createdAt : this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt : void 0;
    const resolvedOptions = {
      startTime,
      finalKeyframe,
      ...options,
      keyframes: keyframes2
    };
    const animation2 = !isHandoff && supportsBrowserAnimation(resolvedOptions) ? new NativeAnimationExtended({
      ...resolvedOptions,
      element: resolvedOptions.motionValue.owner.current
    }) : new JSAnimation(resolvedOptions);
    animation2.finished.then(() => this.notifyFinished()).catch(noop);
    if (this.pendingTimeline) {
      this.stopTimeline = animation2.attachTimeline(this.pendingTimeline);
      this.pendingTimeline = void 0;
    }
    this._animation = animation2;
  }
  get finished() {
    if (!this._animation) {
      return this._finished;
    } else {
      return this.animation.finished;
    }
  }
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
  get animation() {
    var _a;
    if (!this._animation) {
      (_a = this.keyframeResolver) == null ? void 0 : _a.resume();
      flushKeyframeResolvers();
    }
    return this._animation;
  }
  get duration() {
    return this.animation.duration;
  }
  get time() {
    return this.animation.time;
  }
  set time(newTime) {
    this.animation.time = newTime;
  }
  get speed() {
    return this.animation.speed;
  }
  get state() {
    return this.animation.state;
  }
  set speed(newSpeed) {
    this.animation.speed = newSpeed;
  }
  get startTime() {
    return this.animation.startTime;
  }
  attachTimeline(timeline) {
    if (this._animation) {
      this.stopTimeline = this.animation.attachTimeline(timeline);
    } else {
      this.pendingTimeline = timeline;
    }
    return () => this.stop();
  }
  play() {
    this.animation.play();
  }
  pause() {
    this.animation.pause();
  }
  complete() {
    this.animation.complete();
  }
  cancel() {
    var _a;
    if (this._animation) {
      this.animation.cancel();
    }
    (_a = this.keyframeResolver) == null ? void 0 : _a.cancel();
  }
};

// ../node_modules/motion-dom/dist/es/animation/GroupAnimation.mjs
var GroupAnimation = class {
  constructor(animations2) {
    this.stop = () => this.runAll("stop");
    this.animations = animations2.filter(Boolean);
  }
  get finished() {
    return Promise.all(this.animations.map((animation2) => animation2.finished));
  }
  /**
   * TODO: Filter out cancelled or stopped animations before returning
   */
  getAll(propName) {
    return this.animations[0][propName];
  }
  setAll(propName, newValue) {
    for (let i2 = 0; i2 < this.animations.length; i2++) {
      this.animations[i2][propName] = newValue;
    }
  }
  attachTimeline(timeline) {
    const subscriptions = this.animations.map((animation2) => animation2.attachTimeline(timeline));
    return () => {
      subscriptions.forEach((cancel, i2) => {
        cancel && cancel();
        this.animations[i2].stop();
      });
    };
  }
  get time() {
    return this.getAll("time");
  }
  set time(time3) {
    this.setAll("time", time3);
  }
  get speed() {
    return this.getAll("speed");
  }
  set speed(speed) {
    this.setAll("speed", speed);
  }
  get state() {
    return this.getAll("state");
  }
  get startTime() {
    return this.getAll("startTime");
  }
  get duration() {
    let max2 = 0;
    for (let i2 = 0; i2 < this.animations.length; i2++) {
      max2 = Math.max(max2, this.animations[i2].duration);
    }
    return max2;
  }
  runAll(methodName) {
    this.animations.forEach((controls) => controls[methodName]());
  }
  play() {
    this.runAll("play");
  }
  pause() {
    this.runAll("pause");
  }
  cancel() {
    this.runAll("cancel");
  }
  complete() {
    this.runAll("complete");
  }
};

// ../node_modules/motion-dom/dist/es/animation/GroupAnimationWithThen.mjs
var GroupAnimationWithThen = class extends GroupAnimation {
  then(onResolve, _onReject) {
    return this.finished.finally(onResolve).then(() => {
    });
  }
};

// ../node_modules/motion-dom/dist/es/animation/utils/active-animations.mjs
var animationMaps = /* @__PURE__ */ new WeakMap();
var animationMapKey = (name, pseudoElement = "") => `${name}:${pseudoElement}`;
function getAnimationMap(element) {
  const map = animationMaps.get(element) || /* @__PURE__ */ new Map();
  animationMaps.set(element, map);
  return map;
}

// ../node_modules/motion-dom/dist/es/animation/utils/css-variables-conversion.mjs
var splitCSSVariableRegex = (
  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
  /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u
);
function parseCSSVariable(current) {
  const match2 = splitCSSVariableRegex.exec(current);
  if (!match2)
    return [,];
  const [, token1, token2, fallback] = match2;
  return [`--${token1 ?? token2}`, fallback];
}
var maxDepth = 4;
function getVariableValue(current, element, depth = 1) {
  invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
  const [token2, fallback] = parseCSSVariable(current);
  if (!token2)
    return;
  const resolved = window.getComputedStyle(element).getPropertyValue(token2);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}

// ../node_modules/motion-dom/dist/es/animation/utils/get-value-transition.mjs
function getValueTransition(transition, key2) {
  return (transition == null ? void 0 : transition[key2]) ?? (transition == null ? void 0 : transition["default"]) ?? transition;
}

// ../node_modules/motion-dom/dist/es/render/utils/keys-position.mjs
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  ...transformPropOrder
]);

// ../node_modules/motion-dom/dist/es/value/types/auto.mjs
var auto = {
  test: (v2) => v2 === "auto",
  parse: (v2) => v2
};

// ../node_modules/motion-dom/dist/es/value/types/test.mjs
var testValueType = (v2) => (type) => type.test(v2);

// ../node_modules/motion-dom/dist/es/value/types/dimensions.mjs
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var findDimensionValueType = (v2) => dimensionValueTypes.find(testValueType(v2));

// ../node_modules/motion-dom/dist/es/animation/keyframes/utils/is-none.mjs
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}

// ../node_modules/motion-dom/dist/es/value/types/complex/filter.mjs
var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  const [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
var functionRegex = /\b([a-z-]*)\(.*?\)/gu;
var filter2 = {
  ...complex,
  getAnimatableNone: (v2) => {
    const functions = v2.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
  }
};

// ../node_modules/motion-dom/dist/es/value/types/int.mjs
var int = {
  ...number,
  transform: Math.round
};

// ../node_modules/motion-dom/dist/es/value/types/maps/transform.mjs
var transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
};

// ../node_modules/motion-dom/dist/es/value/types/maps/number.mjs
var numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px,
  ...transformValueTypes,
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

// ../node_modules/motion-dom/dist/es/value/types/maps/defaults.mjs
var defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color: color2,
  backgroundColor: color2,
  outlineColor: color2,
  fill: color2,
  stroke: color2,
  // Border props
  borderColor: color2,
  borderTopColor: color2,
  borderRightColor: color2,
  borderBottomColor: color2,
  borderLeftColor: color2,
  filter: filter2,
  WebkitFilter: filter2
};
var getDefaultValueType = (key2) => defaultValueTypes[key2];

// ../node_modules/motion-dom/dist/es/value/types/utils/animatable-none.mjs
function getAnimatableNone2(key2, value) {
  let defaultValueType = getDefaultValueType(key2);
  if (defaultValueType !== filter2)
    defaultValueType = complex;
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : void 0;
}

// ../node_modules/motion-dom/dist/es/animation/keyframes/utils/make-none-animatable.mjs
var invalidTemplates = /* @__PURE__ */ new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i2 = 0;
  let animatableTemplate = void 0;
  while (i2 < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe2 = unresolvedKeyframes[i2];
    if (typeof keyframe2 === "string" && !invalidTemplates.has(keyframe2) && analyseComplexValue(keyframe2).values.length) {
      animatableTemplate = unresolvedKeyframes[i2];
    }
    i2++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone2(name, animatableTemplate);
    }
  }
}

// ../node_modules/motion-dom/dist/es/animation/keyframes/DOMKeyframesResolver.mjs
var DOMKeyframesResolver = class extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue2, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue2, element, true);
  }
  readKeyframes() {
    const { unresolvedKeyframes, element, name } = this;
    if (!element || !element.current)
      return;
    super.readKeyframes();
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      let keyframe2 = unresolvedKeyframes[i2];
      if (typeof keyframe2 === "string") {
        keyframe2 = keyframe2.trim();
        if (isCSSVariableToken(keyframe2)) {
          const resolved = getVariableValue(keyframe2, element.current);
          if (resolved !== void 0) {
            unresolvedKeyframes[i2] = resolved;
          }
          if (i2 === unresolvedKeyframes.length - 1) {
            this.finalKeyframe = keyframe2;
          }
        }
      }
    }
    this.resolveNoneKeyframes();
    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin2, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin2);
    const targetType = findDimensionValueType(target);
    if (originType === targetType)
      return;
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
        const value = unresolvedKeyframes[i2];
        if (typeof value === "string") {
          unresolvedKeyframes[i2] = parseFloat(value);
        }
      }
    } else if (positionalValues[name]) {
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const { unresolvedKeyframes, name } = this;
    const noneKeyframeIndexes = [];
    for (let i2 = 0; i2 < unresolvedKeyframes.length; i2++) {
      if (unresolvedKeyframes[i2] === null || isNone(unresolvedKeyframes[i2])) {
        noneKeyframeIndexes.push(i2);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
    }
  }
  measureInitialState() {
    const { element, unresolvedKeyframes, name } = this;
    if (!element || !element.current)
      return;
    if (name === "height") {
      this.suspendedScrollY = window.pageYOffset;
    }
    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    unresolvedKeyframes[0] = this.measuredOrigin;
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== void 0) {
      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    var _a;
    const { element, name, unresolvedKeyframes } = this;
    if (!element || !element.current)
      return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    if (finalKeyframe !== null && this.finalKeyframe === void 0) {
      this.finalKeyframe = finalKeyframe;
    }
    if ((_a = this.removedTransforms) == null ? void 0 : _a.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
};

// ../node_modules/motion-dom/dist/es/animation/waapi/utils/px-values.mjs
var pxValues = /* @__PURE__ */ new Set([
  // Border props
  "borderWidth",
  "borderTopWidth",
  "borderRightWidth",
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRadius",
  "radius",
  "borderTopLeftRadius",
  "borderTopRightRadius",
  "borderBottomRightRadius",
  "borderBottomLeftRadius",
  // Positioning props
  "width",
  "maxWidth",
  "height",
  "maxHeight",
  "top",
  "right",
  "bottom",
  "left",
  // Spacing props
  "padding",
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "margin",
  "marginTop",
  "marginRight",
  "marginBottom",
  "marginLeft",
  // Misc
  "backgroundPositionX",
  "backgroundPositionY"
]);

// ../node_modules/motion-dom/dist/es/animation/keyframes/utils/apply-px-defaults.mjs
function applyPxDefaults(keyframes2, name) {
  for (let i2 = 0; i2 < keyframes2.length; i2++) {
    if (typeof keyframes2[i2] === "number" && pxValues.has(name)) {
      keyframes2[i2] = keyframes2[i2] + "px";
    }
  }
}

// ../node_modules/motion-dom/dist/es/animation/waapi/supports/partial-keyframes.mjs
var supportsPartialKeyframes = memo(() => {
  try {
    document.createElement("div").animate({ opacity: [1] });
  } catch (e) {
    return false;
  }
  return true;
});

// ../node_modules/motion-dom/dist/es/utils/resolve-elements.mjs
function resolveElements(elementOrSelector, scope, selectorCache) {
  if (elementOrSelector instanceof EventTarget) {
    return [elementOrSelector];
  } else if (typeof elementOrSelector === "string") {
    let root = document;
    if (scope) {
      root = scope.current;
    }
    const elements = (selectorCache == null ? void 0 : selectorCache[elementOrSelector]) ?? root.querySelectorAll(elementOrSelector);
    return elements ? Array.from(elements) : [];
  }
  return Array.from(elementOrSelector);
}

// ../node_modules/motion-dom/dist/es/value/index.mjs
var MAX_VELOCITY_DELTA = 30;
var isFloat = (value) => {
  return !isNaN(parseFloat(value));
};
var collectMotionValues = {
  current: void 0
};
var MotionValue = class {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   */
  constructor(init, options = {}) {
    this.canTrackVelocity = null;
    this.events = {};
    this.updateAndNotify = (v2, render = true) => {
      var _a, _b;
      const currentTime = time.now();
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v2);
      if (this.current !== this.prev) {
        (_a = this.events.change) == null ? void 0 : _a.notify(this.current);
        if (this.dependents) {
          for (const dependent of this.dependents) {
            dependent.dirty();
          }
        }
      }
      if (render) {
        (_b = this.events.renderRequest) == null ? void 0 : _b.notify(this.current);
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current !== void 0) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    if (true) {
      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
    }
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v2, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v2, render);
    } else {
      this.passiveEffect(v2, this.updateAndNotify);
    }
  }
  setWithVelocity(prev2, current, delta) {
    this.set(current);
    this.prev = void 0;
    this.prevFrameValue = prev2;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v2, endAnimation = true) {
    this.updateAndNotify(v2);
    this.prev = v2;
    this.prevUpdatedAt = this.prevFrameValue = void 0;
    endAnimation && this.stop();
    if (this.stopPassiveEffect)
      this.stopPassiveEffect();
  }
  dirty() {
    var _a;
    (_a = this.events.change) == null ? void 0 : _a.notify(this.current);
  }
  addDependent(dependent) {
    if (!this.dependents) {
      this.dependents = /* @__PURE__ */ new Set();
    }
    this.dependents.add(dependent);
  }
  removeDependent(dependent) {
    if (this.dependents) {
      this.dependents.delete(dependent);
    }
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    if (collectMotionValues.current) {
      collectMotionValues.current.push(this);
    }
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   */
  start(startAnimation) {
    this.stop();
    return new Promise((resolve) => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    var _a, _b;
    (_a = this.dependents) == null ? void 0 : _a.clear();
    (_b = this.events.destroy) == null ? void 0 : _b.notify();
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
};
function motionValue(init, options) {
  return new MotionValue(init, options);
}

// ../node_modules/motion-dom/dist/es/value/types/utils/get-as-type.mjs
var getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};

// ../node_modules/motion-dom/dist/es/frameloop/microtask.mjs
var { schedule: microtask, cancel: cancelMicrotask } = createRenderBatcher(queueMicrotask, false);

// ../node_modules/motion-dom/dist/es/gestures/drag/state/is-active.mjs
var isDragging = {
  x: false,
  y: false
};
function isDragActive() {
  return isDragging.x || isDragging.y;
}

// ../node_modules/motion-dom/dist/es/gestures/drag/state/set-active.mjs
function setDragLock(axis) {
  if (axis === "x" || axis === "y") {
    if (isDragging[axis]) {
      return null;
    } else {
      isDragging[axis] = true;
      return () => {
        isDragging[axis] = false;
      };
    }
  } else {
    if (isDragging.x || isDragging.y) {
      return null;
    } else {
      isDragging.x = isDragging.y = true;
      return () => {
        isDragging.x = isDragging.y = false;
      };
    }
  }
}

// ../node_modules/motion-dom/dist/es/gestures/utils/setup.mjs
function setupGesture(elementOrSelector, options) {
  const elements = resolveElements(elementOrSelector);
  const gestureAbortController = new AbortController();
  const eventOptions = {
    passive: true,
    ...options,
    signal: gestureAbortController.signal
  };
  const cancel = () => gestureAbortController.abort();
  return [elements, eventOptions, cancel];
}

// ../node_modules/motion-dom/dist/es/gestures/hover.mjs
function isValidHover(event) {
  return !(event.pointerType === "touch" || isDragActive());
}
function hover(elementOrSelector, onHoverStart, options = {}) {
  const [elements, eventOptions, cancel] = setupGesture(elementOrSelector, options);
  const onPointerEnter = (enterEvent) => {
    if (!isValidHover(enterEvent))
      return;
    const { target } = enterEvent;
    const onHoverEnd = onHoverStart(target, enterEvent);
    if (typeof onHoverEnd !== "function" || !target)
      return;
    const onPointerLeave = (leaveEvent) => {
      if (!isValidHover(leaveEvent))
        return;
      onHoverEnd(leaveEvent);
      target.removeEventListener("pointerleave", onPointerLeave);
    };
    target.addEventListener("pointerleave", onPointerLeave, eventOptions);
  };
  elements.forEach((element) => {
    element.addEventListener("pointerenter", onPointerEnter, eventOptions);
  });
  return cancel;
}

// ../node_modules/motion-dom/dist/es/gestures/utils/is-node-or-child.mjs
var isNodeOrChild = (parent, child) => {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};

// ../node_modules/motion-dom/dist/es/gestures/utils/is-primary-pointer.mjs
var isPrimaryPointer = (event) => {
  if (event.pointerType === "mouse") {
    return typeof event.button !== "number" || event.button <= 0;
  } else {
    return event.isPrimary !== false;
  }
};

// ../node_modules/motion-dom/dist/es/gestures/press/utils/is-keyboard-accessible.mjs
var focusableElements = /* @__PURE__ */ new Set([
  "BUTTON",
  "INPUT",
  "SELECT",
  "TEXTAREA",
  "A"
]);
function isElementKeyboardAccessible(element) {
  return focusableElements.has(element.tagName) || element.tabIndex !== -1;
}

// ../node_modules/motion-dom/dist/es/gestures/press/utils/state.mjs
var isPressing = /* @__PURE__ */ new WeakSet();

// ../node_modules/motion-dom/dist/es/gestures/press/utils/keyboard.mjs
function filterEvents(callback) {
  return (event) => {
    if (event.key !== "Enter")
      return;
    callback(event);
  };
}
function firePointerEvent(target, type) {
  target.dispatchEvent(new PointerEvent("pointer" + type, { isPrimary: true, bubbles: true }));
}
var enableKeyboardPress = (focusEvent, eventOptions) => {
  const element = focusEvent.currentTarget;
  if (!element)
    return;
  const handleKeydown = filterEvents(() => {
    if (isPressing.has(element))
      return;
    firePointerEvent(element, "down");
    const handleKeyup = filterEvents(() => {
      firePointerEvent(element, "up");
    });
    const handleBlur = () => firePointerEvent(element, "cancel");
    element.addEventListener("keyup", handleKeyup, eventOptions);
    element.addEventListener("blur", handleBlur, eventOptions);
  });
  element.addEventListener("keydown", handleKeydown, eventOptions);
  element.addEventListener("blur", () => element.removeEventListener("keydown", handleKeydown), eventOptions);
};

// ../node_modules/motion-dom/dist/es/gestures/press/index.mjs
function isValidPressEvent(event) {
  return isPrimaryPointer(event) && !isDragActive();
}
function press(targetOrSelector, onPressStart, options = {}) {
  const [targets, eventOptions, cancelEvents] = setupGesture(targetOrSelector, options);
  const startPress = (startEvent) => {
    const target = startEvent.currentTarget;
    if (!isValidPressEvent(startEvent))
      return;
    isPressing.add(target);
    const onPressEnd = onPressStart(target, startEvent);
    const onPointerEnd = (endEvent, success) => {
      window.removeEventListener("pointerup", onPointerUp);
      window.removeEventListener("pointercancel", onPointerCancel);
      if (isPressing.has(target)) {
        isPressing.delete(target);
      }
      if (!isValidPressEvent(endEvent)) {
        return;
      }
      if (typeof onPressEnd === "function") {
        onPressEnd(endEvent, { success });
      }
    };
    const onPointerUp = (upEvent) => {
      onPointerEnd(upEvent, target === window || target === document || options.useGlobalTarget || isNodeOrChild(target, upEvent.target));
    };
    const onPointerCancel = (cancelEvent) => {
      onPointerEnd(cancelEvent, false);
    };
    window.addEventListener("pointerup", onPointerUp, eventOptions);
    window.addEventListener("pointercancel", onPointerCancel, eventOptions);
  };
  targets.forEach((target) => {
    const pointerDownTarget = options.useGlobalTarget ? window : target;
    pointerDownTarget.addEventListener("pointerdown", startPress, eventOptions);
    if (isHTMLElement(target)) {
      target.addEventListener("focus", (event) => enableKeyboardPress(event, eventOptions));
      if (!isElementKeyboardAccessible(target) && !target.hasAttribute("tabindex")) {
        target.tabIndex = 0;
      }
    }
  });
  return cancelEvents;
}

// ../node_modules/motion-dom/dist/es/render/dom/style-computed.mjs
function getComputedStyle2(element, name) {
  const computedStyle = window.getComputedStyle(element);
  return isCSSVar(name) ? computedStyle.getPropertyValue(name) : computedStyle[name];
}

// ../node_modules/motion-dom/dist/es/utils/is-svg-element.mjs
function isSVGElement(element) {
  return isObject(element) && "ownerSVGElement" in element;
}

// ../node_modules/motion-dom/dist/es/utils/is-svg-svg-element.mjs
function isSVGSVGElement(element) {
  return isSVGElement(element) && element.tagName === "svg";
}

// ../node_modules/motion-dom/dist/es/utils/transform.mjs
function transform(...args) {
  const useImmediate = !Array.isArray(args[0]);
  const argOffset = useImmediate ? 0 : -1;
  const inputValue = args[0 + argOffset];
  const inputRange = args[1 + argOffset];
  const outputRange = args[2 + argOffset];
  const options = args[3 + argOffset];
  const interpolator = interpolate(inputRange, outputRange, options);
  return useImmediate ? interpolator(inputValue) : interpolator;
}

// ../node_modules/motion-dom/dist/es/value/utils/is-motion-value.mjs
var isMotionValue = (value) => Boolean(value && value.getVelocity);

// ../node_modules/motion-dom/dist/es/value/types/utils/find.mjs
var valueTypes = [...dimensionValueTypes, color2, complex];
var findValueType = (v2) => valueTypes.find(testValueType(v2));

// ../node_modules/motion-dom/dist/es/frameloop/index-legacy.mjs
var cancelSync = stepsOrder.reduce((acc, key2) => {
  acc[key2] = (process3) => cancelFrame(process3);
  return acc;
}, {});

// ../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
var React = __toESM(require_react(), 1);
var import_react7 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
var import_react6 = __toESM(require_react(), 1);
var MotionConfigContext = (0, import_react6.createContext)({
  transformPagePoint: (p2) => p2,
  isStatic: false,
  reducedMotion: "never"
});

// ../node_modules/framer-motion/dist/es/components/AnimatePresence/PopChild.mjs
var PopChildMeasure = class extends React.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const parent = element.offsetParent;
      const parentWidth = isHTMLElement(parent) ? parent.offsetWidth || 0 : 0;
      const size5 = this.props.sizeRef.current;
      size5.height = element.offsetHeight || 0;
      size5.width = element.offsetWidth || 0;
      size5.top = element.offsetTop;
      size5.left = element.offsetLeft;
      size5.right = parentWidth - size5.width - size5.left;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {
  }
  render() {
    return this.props.children;
  }
};
function PopChild({ children, isPresent, anchorX }) {
  const id3 = (0, import_react7.useId)();
  const ref = (0, import_react7.useRef)(null);
  const size5 = (0, import_react7.useRef)({
    width: 0,
    height: 0,
    top: 0,
    left: 0,
    right: 0
  });
  const { nonce } = (0, import_react7.useContext)(MotionConfigContext);
  (0, import_react7.useInsertionEffect)(() => {
    const { width, height, top, left, right } = size5.current;
    if (isPresent || !ref.current || !width || !height)
      return;
    const x2 = anchorX === "left" ? `left: ${left}` : `right: ${right}`;
    ref.current.dataset.motionPopId = id3;
    const style = document.createElement("style");
    if (nonce)
      style.nonce = nonce;
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id3}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            ${x2}px !important;
            top: ${top}px !important;
          }
        `);
    }
    return () => {
      if (document.head.contains(style)) {
        document.head.removeChild(style);
      }
    };
  }, [isPresent]);
  return (0, import_jsx_runtime.jsx)(PopChildMeasure, { isPresent, childRef: ref, sizeRef: size5, children: React.cloneElement(children, { ref }) });
}

// ../node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
var PresenceChild = ({ children, initial, isPresent, onExitComplete, custom, presenceAffectsLayout, mode, anchorX }) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id3 = (0, import_react8.useId)();
  let isReusedContext = true;
  let context = (0, import_react8.useMemo)(() => {
    isReusedContext = false;
    return {
      id: id3,
      initial,
      isPresent,
      custom,
      onExitComplete: (childId) => {
        presenceChildren.set(childId, true);
        for (const isComplete of presenceChildren.values()) {
          if (!isComplete)
            return;
        }
        onExitComplete && onExitComplete();
      },
      register: (childId) => {
        presenceChildren.set(childId, false);
        return () => presenceChildren.delete(childId);
      }
    };
  }, [isPresent, presenceChildren, onExitComplete]);
  if (presenceAffectsLayout && isReusedContext) {
    context = { ...context };
  }
  (0, import_react8.useMemo)(() => {
    presenceChildren.forEach((_2, key2) => presenceChildren.set(key2, false));
  }, [isPresent]);
  React2.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = (0, import_jsx_runtime2.jsx)(PopChild, { isPresent, anchorX, children });
  }
  return (0, import_jsx_runtime2.jsx)(PresenceContext.Provider, { value: context, children });
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}

// ../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
var import_react9 = __toESM(require_react(), 1);
function usePresence(subscribe2 = true) {
  const context = (0, import_react9.useContext)(PresenceContext);
  if (context === null)
    return [true, null];
  const { isPresent, onExitComplete, register } = context;
  const id3 = (0, import_react9.useId)();
  (0, import_react9.useEffect)(() => {
    if (subscribe2) {
      return register(id3);
    }
  }, [subscribe2]);
  const safeToRemove = (0, import_react9.useCallback)(() => subscribe2 && onExitComplete && onExitComplete(id3), [id3, onExitComplete, subscribe2]);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}

// ../node_modules/framer-motion/dist/es/components/AnimatePresence/utils.mjs
var import_react10 = __toESM(require_react(), 1);
var getChildKey = (child) => child.key || "";
function onlyElements(children) {
  const filtered = [];
  import_react10.Children.forEach(children, (child) => {
    if ((0, import_react10.isValidElement)(child))
      filtered.push(child);
  });
  return filtered;
}

// ../node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var AnimatePresence = ({ children, custom, initial = true, onExitComplete, presenceAffectsLayout = true, mode = "sync", propagate = false, anchorX = "left" }) => {
  const [isParentPresent, safeToRemove] = usePresence(propagate);
  const presentChildren = (0, import_react11.useMemo)(() => onlyElements(children), [children]);
  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
  const isInitialRender = (0, import_react11.useRef)(true);
  const pendingPresentChildren = (0, import_react11.useRef)(presentChildren);
  const exitComplete = useConstant(() => /* @__PURE__ */ new Map());
  const [diffedChildren, setDiffedChildren] = (0, import_react11.useState)(presentChildren);
  const [renderedChildren, setRenderedChildren] = (0, import_react11.useState)(presentChildren);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    pendingPresentChildren.current = presentChildren;
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const key2 = getChildKey(renderedChildren[i2]);
      if (!presentKeys.includes(key2)) {
        if (exitComplete.get(key2) !== true) {
          exitComplete.set(key2, false);
        }
      } else {
        exitComplete.delete(key2);
      }
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    for (let i2 = 0; i2 < renderedChildren.length; i2++) {
      const child = renderedChildren[i2];
      const key2 = getChildKey(child);
      if (!presentKeys.includes(key2)) {
        nextChildren.splice(i2, 0, child);
        exitingChildren.push(child);
      }
    }
    if (mode === "wait" && exitingChildren.length) {
      nextChildren = exitingChildren;
    }
    setRenderedChildren(onlyElements(nextChildren));
    setDiffedChildren(presentChildren);
    return null;
  }
  if (mode === "wait" && renderedChildren.length > 1) {
    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  }
  const { forceRender } = (0, import_react11.useContext)(LayoutGroupContext);
  return (0, import_jsx_runtime3.jsx)(import_jsx_runtime3.Fragment, { children: renderedChildren.map((child) => {
    const key2 = getChildKey(child);
    const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key2);
    const onExit = () => {
      if (exitComplete.has(key2)) {
        exitComplete.set(key2, true);
      } else {
        return;
      }
      let isEveryExitComplete = true;
      exitComplete.forEach((isExitComplete) => {
        if (!isExitComplete)
          isEveryExitComplete = false;
      });
      if (isEveryExitComplete) {
        forceRender == null ? void 0 : forceRender();
        setRenderedChildren(pendingPresentChildren.current);
        propagate && (safeToRemove == null ? void 0 : safeToRemove());
        onExitComplete && onExitComplete();
      }
    };
    return (0, import_jsx_runtime3.jsx)(PresenceChild, { isPresent, initial: !isInitialRender.current || initial ? void 0 : false, custom, presenceAffectsLayout, mode, onExitComplete: isPresent ? void 0 : onExit, anchorX, children: child }, key2);
  }) });
};

// ../node_modules/framer-motion/dist/es/render/components/create-proxy.mjs
function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy === "undefined") {
    return componentFactory;
  }
  const componentCache = /* @__PURE__ */ new Map();
  const deprecatedFactoryFunction = (...args) => {
    if (true) {
      warnOnce(false, "motion() is deprecated. Use motion.create() instead.");
    }
    return componentFactory(...args);
  };
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key2) => {
      if (key2 === "create")
        return componentFactory;
      if (!componentCache.has(key2)) {
        componentCache.set(key2, componentFactory(key2));
      }
      return componentCache.get(key2);
    }
  });
}

// ../node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
function isAnimationControls(v2) {
  return v2 !== null && typeof v2 === "object" && typeof v2.start === "function";
}

// ../node_modules/framer-motion/dist/es/render/utils/resolve-variants.mjs
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement == null ? void 0 : visualElement.values.forEach((value, key2) => {
    state[0][key2] = value.get();
    state[1][key2] = value.getVelocity();
  });
  return state;
}
function resolveVariantFromProps(props, definition, custom, visualElement) {
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== void 0 ? custom : props.custom, current, velocity);
  }
  return definition;
}

// ../node_modules/framer-motion/dist/es/render/utils/resolve-dynamic-variants.mjs
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== void 0 ? custom : props.custom, visualElement);
}

// ../node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
var isKeyframesTarget = (v2) => {
  return Array.isArray(v2);
};

// ../node_modules/framer-motion/dist/es/render/utils/setters.mjs
function setMotionValue(visualElement, key2, value) {
  if (visualElement.hasValue(key2)) {
    visualElement.getValue(key2).set(value);
  } else {
    visualElement.addValue(key2, motionValue(value));
  }
}
function resolveFinalValueInKeyframes(v2) {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let { transitionEnd = {}, transition = {}, ...target } = resolved || {};
  target = { ...target, ...transitionEnd };
  for (const key2 in target) {
    const value = resolveFinalValueInKeyframes(target[key2]);
    setMotionValue(visualElement, key2, value);
  }
}

// ../node_modules/framer-motion/dist/es/value/use-will-change/is.mjs
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}

// ../node_modules/framer-motion/dist/es/value/use-will-change/add-will-change.mjs
function addValueToWillChange(visualElement, key2) {
  const willChange = visualElement.getValue("willChange");
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key2);
  } else if (!willChange && MotionGlobalConfig.WillChange) {
    const newWillChange = new MotionGlobalConfig.WillChange("auto");
    visualElement.addValue("willChange", newWillChange);
    newWillChange.add(key2);
  }
}

// ../node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
var camelToDash = (str) => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();

// ../node_modules/framer-motion/dist/es/animation/optimized-appear/data-id.mjs
var optimizedAppearDataId = "framerAppearId";
var optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);

// ../node_modules/framer-motion/dist/es/animation/optimized-appear/get-appear-id.mjs
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}

// ../node_modules/framer-motion/dist/es/animation/animators/waapi/utils/get-final-keyframe.mjs
var isNotNull2 = (value) => value !== null;
function getFinalKeyframe2(keyframes2, { repeat, repeatType = "loop" }, finalKeyframe) {
  const resolvedKeyframes = keyframes2.filter(isNotNull2);
  const index2 = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index2 || finalKeyframe === void 0 ? resolvedKeyframes[index2] : finalKeyframe;
}

// ../node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
var underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
var criticallyDampedSpring = (target) => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
var keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
var ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
var getDefaultTransition = (valueKey, { keyframes: keyframes2 }) => {
  if (keyframes2.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes2[1]) : underDampedSpring;
  }
  return ease;
};

// ../node_modules/framer-motion/dist/es/animation/utils/is-transition-defined.mjs
function isTransitionDefined({ when, delay: _delay, delayChildren, staggerChildren, staggerDirection, repeat, repeatType, repeatDelay, from: from2, elapsed, ...transition }) {
  return !!Object.keys(transition).length;
}

// ../node_modules/framer-motion/dist/es/animation/interfaces/motion-value.mjs
var animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => (onComplete) => {
  const valueTransition = getValueTransition(transition, name) || {};
  const delay2 = valueTransition.delay || transition.delay || 0;
  let { elapsed = 0 } = transition;
  elapsed = elapsed - secondsToMilliseconds(delay2);
  const options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: (v2) => {
      value.set(v2);
      valueTransition.onUpdate && valueTransition.onUpdate(v2);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? void 0 : element
  };
  if (!isTransitionDefined(valueTransition)) {
    Object.assign(options, getDefaultTransition(name, options));
  }
  options.duration && (options.duration = secondsToMilliseconds(options.duration));
  options.repeatDelay && (options.repeatDelay = secondsToMilliseconds(options.repeatDelay));
  if (options.from !== void 0) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    options.duration = 0;
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  if (MotionGlobalConfig.instantAnimations || MotionGlobalConfig.skipAnimations) {
    shouldSkip = true;
    options.duration = 0;
    options.delay = 0;
  }
  options.allowFlatten = !valueTransition.type && !valueTransition.ease;
  if (shouldSkip && !isHandoff && value.get() !== void 0) {
    const finalKeyframe = getFinalKeyframe2(options.keyframes, valueTransition);
    if (finalKeyframe !== void 0) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      return;
    }
  }
  return valueTransition.isSync ? new JSAnimation(options) : new AsyncMotionValueAnimation(options);
};

// ../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-target.mjs
function shouldBlockAnimation({ protectedKeys, needsAnimating }, key2) {
  const shouldBlock = protectedKeys.hasOwnProperty(key2) && needsAnimating[key2] !== true;
  needsAnimating[key2] = false;
  return shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, { delay: delay2 = 0, transitionOverride, type } = {}) {
  let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = targetAndTransition;
  if (transitionOverride)
    transition = transitionOverride;
  const animations2 = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key2 in target) {
    const value = visualElement.getValue(key2, visualElement.latestValues[key2] ?? null);
    const valueTarget = target[key2];
    if (valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key2)) {
      continue;
    }
    const valueTransition = {
      delay: delay2,
      ...getValueTransition(transition || {}, key2)
    };
    const currentValue = value.get();
    if (currentValue !== void 0 && !value.isAnimating && !Array.isArray(valueTarget) && valueTarget === currentValue && !valueTransition.velocity) {
      continue;
    }
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key2, frame);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange(visualElement, key2);
    value.start(animateMotionValue(key2, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key2) ? { type: false } : valueTransition, visualElement, isHandoff));
    const animation2 = value.animation;
    if (animation2) {
      animations2.push(animation2);
    }
  }
  if (transitionEnd) {
    Promise.all(animations2).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations2;
}

// ../node_modules/framer-motion/dist/es/animation/interfaces/visual-element-variant.mjs
function animateVariant(visualElement, variant, options = {}) {
  var _a;
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a = visualElement.presenceContext) == null ? void 0 : _a.custom : void 0);
  let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const { delayChildren = 0, staggerChildren, staggerDirection } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  const { when } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations2 = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i2 = 0) => i2 * staggerChildren : (i2 = 0) => maxStaggerDuration - i2 * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i2) => {
    child.notify("AnimationStart", variant);
    animations2.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i2)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a2, b2) {
  return a2.sortNodePosition(b2);
}

// ../node_modules/framer-motion/dist/es/animation/interfaces/visual-element.mjs
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation2;
  if (Array.isArray(definition)) {
    const animations2 = definition.map((variant) => animateVariant(visualElement, variant, options));
    animation2 = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation2 = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation2 = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation2.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}

// ../node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
function shallowCompare(next2, prev2) {
  if (!Array.isArray(prev2))
    return false;
  const prevLength = prev2.length;
  if (prevLength !== next2.length)
    return false;
  for (let i2 = 0; i2 < prevLength; i2++) {
    if (prev2[i2] !== next2[i2])
      return false;
  }
  return true;
}

// ../node_modules/framer-motion/dist/es/render/utils/is-variant-label.mjs
function isVariantLabel(v2) {
  return typeof v2 === "string" || Array.isArray(v2);
}

// ../node_modules/framer-motion/dist/es/render/utils/variant-props.mjs
var variantPriorityOrder = [
  "animate",
  "whileInView",
  "whileFocus",
  "whileHover",
  "whileTap",
  "whileDrag",
  "exit"
];
var variantProps = ["initial", ...variantPriorityOrder];

// ../node_modules/framer-motion/dist/es/render/utils/get-variant-context.mjs
var numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement)
    return void 0;
  if (!visualElement.isControllingVariants) {
    const context2 = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    if (visualElement.props.initial !== void 0) {
      context2.initial = visualElement.props.initial;
    }
    return context2;
  }
  const context = {};
  for (let i2 = 0; i2 < numVariantProps; i2++) {
    const name = variantProps[i2];
    const prop = visualElement.props[name];
    if (isVariantLabel(prop) || prop === false) {
      context[name] = prop;
    }
  }
  return context;
}

// ../node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
var reversePriorityOrder = [...variantPriorityOrder].reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return (animations2) => Promise.all(animations2.map(({ animation: animation2, options }) => animateVisualElement(visualElement, animation2, options)));
}
function createAnimationState(visualElement) {
  let animate2 = animateList(visualElement);
  let state = createState();
  let isInitialRender = true;
  const buildResolvedTypeValues = (type) => (acc, definition) => {
    var _a;
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a = visualElement.presenceContext) == null ? void 0 : _a.custom : void 0);
    if (resolved) {
      const { transition, transitionEnd, ...target } = resolved;
      acc = { ...acc, ...target, ...transitionEnd };
    }
    return acc;
  };
  function setAnimateFunction(makeAnimator) {
    animate2 = makeAnimator(visualElement);
  }
  function animateChanges(changedActiveType) {
    const { props } = visualElement;
    const context = getVariantContext(visualElement.parent) || {};
    const animations2 = [];
    const removedKeys = /* @__PURE__ */ new Set();
    let encounteredKeys = {};
    let removedVariantIndex = Infinity;
    for (let i2 = 0; i2 < numAnimationTypes; i2++) {
      const type = reversePriorityOrder[i2];
      const typeState = state[type];
      const prop = props[type] !== void 0 ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i2;
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = { ...encounteredKeys };
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        continue;
      }
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i2 > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      const definitionList = Array.isArray(prop) ? prop : [prop];
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      if (activeDelta === false)
        resolvedValues = {};
      const { prevResolvedValues = {} } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = (key2) => {
        shouldAnimateType = true;
        if (removedKeys.has(key2)) {
          handledRemovedValues = true;
          removedKeys.delete(key2);
        }
        typeState.needsAnimating[key2] = true;
        const motionValue2 = visualElement.getValue(key2);
        if (motionValue2)
          motionValue2.liveStyle = false;
      };
      for (const key2 in allKeys) {
        const next2 = resolvedValues[key2];
        const prev2 = prevResolvedValues[key2];
        if (encounteredKeys.hasOwnProperty(key2))
          continue;
        let valueHasChanged = false;
        if (isKeyframesTarget(next2) && isKeyframesTarget(prev2)) {
          valueHasChanged = !shallowCompare(next2, prev2);
        } else {
          valueHasChanged = next2 !== prev2;
        }
        if (valueHasChanged) {
          if (next2 !== void 0 && next2 !== null) {
            markToAnimate(key2);
          } else {
            removedKeys.add(key2);
          }
        } else if (next2 !== void 0 && removedKeys.has(key2)) {
          markToAnimate(key2);
        } else {
          typeState.protectedKeys[key2] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = { ...encounteredKeys, ...resolvedValues };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      const willAnimateViaParent = isInherited && variantDidChange;
      const needsAnimating = !willAnimateViaParent || handledRemovedValues;
      if (shouldAnimateType && needsAnimating) {
        animations2.push(...definitionList.map((animation2) => ({
          animation: animation2,
          options: { type }
        })));
      }
    }
    if (removedKeys.size) {
      const fallbackAnimation = {};
      if (typeof props.initial !== "boolean") {
        const initialTransition = resolveVariant(visualElement, Array.isArray(props.initial) ? props.initial[0] : props.initial);
        if (initialTransition && initialTransition.transition) {
          fallbackAnimation.transition = initialTransition.transition;
        }
      }
      removedKeys.forEach((key2) => {
        const fallbackTarget = visualElement.getBaseTarget(key2);
        const motionValue2 = visualElement.getValue(key2);
        if (motionValue2)
          motionValue2.liveStyle = true;
        fallbackAnimation[key2] = fallbackTarget ?? null;
      });
      animations2.push({ animation: fallbackAnimation });
    }
    let shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate2(animations2) : Promise.resolve();
  }
  function setActive(type, isActive) {
    var _a;
    if (state[type].isActive === isActive)
      return Promise.resolve();
    (_a = visualElement.variantChildren) == null ? void 0 : _a.forEach((child) => {
      var _a2;
      return (_a2 = child.animationState) == null ? void 0 : _a2.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations2 = animateChanges(type);
    for (const key2 in state) {
      state[key2].protectedKeys = {};
    }
    return animations2;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
      isInitialRender = true;
    }
  };
}
function checkVariantsDidChange(prev2, next2) {
  if (typeof next2 === "string") {
    return next2 !== prev2;
  } else if (Array.isArray(next2)) {
    return !shallowCompare(next2, prev2);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}

// ../node_modules/framer-motion/dist/es/motion/features/Feature.mjs
var Feature = class {
  constructor(node2) {
    this.isMounted = false;
    this.node = node2;
  }
  update() {
  }
};

// ../node_modules/framer-motion/dist/es/motion/features/animation/index.mjs
var AnimationFeature = class extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node2) {
    super(node2);
    node2.animationState || (node2.animationState = createAnimationState(node2));
  }
  updateAnimationControlsSubscription() {
    const { animate: animate2 } = this.node.getProps();
    if (isAnimationControls(animate2)) {
      this.unmountControls = animate2.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const { animate: animate2 } = this.node.getProps();
    const { animate: prevAnimate } = this.node.prevProps || {};
    if (animate2 !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    var _a;
    this.node.animationState.reset();
    (_a = this.unmountControls) == null ? void 0 : _a.call(this);
  }
};

// ../node_modules/framer-motion/dist/es/motion/features/animation/exit.mjs
var id = 0;
var ExitAnimationFeature = class extends Feature {
  constructor() {
    super(...arguments);
    this.id = id++;
  }
  update() {
    if (!this.node.presenceContext)
      return;
    const { isPresent, onExitComplete } = this.node.presenceContext;
    const { isPresent: prevIsPresent } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => {
        onExitComplete(this.id);
      });
    }
  }
  mount() {
    const { register, onExitComplete } = this.node.presenceContext || {};
    if (onExitComplete) {
      onExitComplete(this.id);
    }
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {
  }
};

// ../node_modules/framer-motion/dist/es/motion/features/animations.mjs
var animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};

// ../node_modules/framer-motion/dist/es/events/add-dom-event.mjs
function addDomEvent(target, eventName, handler, options = { passive: true }) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}

// ../node_modules/framer-motion/dist/es/events/event-info.mjs
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
var addPointerInfo = (handler) => {
  return (event) => isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};

// ../node_modules/framer-motion/dist/es/events/add-pointer-event.mjs
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}

// ../node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
function convertBoundingBoxToBox({ top, left, right, bottom }) {
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox({ x: x2, y: y2 }) {
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  const topLeft = transformPoint2({ x: point.left, y: point.top });
  const bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}

// ../node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
var SCALE_PRECISION = 1e-4;
var SCALE_MIN = 1 - SCALE_PRECISION;
var SCALE_MAX = 1 + SCALE_PRECISION;
var TRANSLATE_PRECISION = 0.01;
var TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
var TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin2 = 0.5) {
  delta.origin = origin2;
  delta.originPoint = mixNumber(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0;
  }
}
function calcBoxDelta(delta, source, target, origin2) {
  calcAxisDelta(delta.x, source.x, target.x, origin2 ? origin2.originX : void 0);
  calcAxisDelta(delta.y, source.y, target.y, origin2 ? origin2.originY : void 0);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout2, parent) {
  target.min = layout2.min - parent.min;
  target.max = target.min + calcLength(layout2);
}
function calcRelativePosition(target, layout2, parent) {
  calcRelativeAxisPosition(target.x, layout2.x, parent.x);
  calcRelativeAxisPosition(target.y, layout2.y, parent.y);
}

// ../node_modules/framer-motion/dist/es/projection/geometry/models.mjs
var createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
var createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
var createAxis = () => ({ min: 0, max: 0 });
var createBox = () => ({
  x: createAxis(),
  y: createAxis()
});

// ../node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}

// ../node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale({ scale: scale2, scaleX: scaleX2, scaleY: scaleY2 }) {
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX2) || !isIdentityScale(scaleY2);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}

// ../node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
function scalePoint(point, scale2, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate = 0, scale2 = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, { x: x2, y: y2 }) {
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
var TREE_SCALE_SNAP_MIN = 0.999999999999;
var TREE_SCALE_SNAP_MAX = 1.0000000000001;
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  let node2;
  let delta;
  for (let i2 = 0; i2 < treeLength; i2++) {
    node2 = treePath[i2];
    delta = node2.projectionDelta;
    const { visualElement } = node2.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
      transformBox(box, {
        x: -node2.scroll.offset.x,
        y: -node2.scroll.offset.y
      });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node2.latestValues)) {
      transformBox(box, node2.latestValues);
    }
  }
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1;
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
function transformBox(box, transform2) {
  transformAxis(box.x, transform2.x, transform2.scaleX, transform2.scale, transform2.originX);
  transformAxis(box.y, transform2.y, transform2.scaleY, transform2.scale, transform2.originY);
}

// ../node_modules/framer-motion/dist/es/projection/utils/measure.mjs
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const { scroll: scroll2 } = rootProjectionNode2;
  if (scroll2) {
    translateAxis(viewportBox.x, scroll2.offset.x);
    translateAxis(viewportBox.y, scroll2.offset.y);
  }
  return viewportBox;
}

// ../node_modules/framer-motion/dist/es/utils/get-context-window.mjs
var getContextWindow = ({ current }) => {
  return current ? current.ownerDocument.defaultView : null;
};

// ../node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
function isRefObject(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

// ../node_modules/framer-motion/dist/es/utils/distance.mjs
var distance = (a2, b2) => Math.abs(a2 - b2);
function distance2D(a2, b2) {
  const xDelta = distance(a2.x, b2.x);
  const yDelta = distance(a2.y, b2.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}

// ../node_modules/framer-motion/dist/es/gestures/pan/PanSession.mjs
var PanSession = class {
  constructor(event, handlers, { transformPagePoint, contextWindow, dragSnapToOrigin = false } = {}) {
    this.startEvent = null;
    this.lastMoveEvent = null;
    this.lastMoveEventInfo = null;
    this.handlers = {};
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const info2 = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      const isDistancePastThreshold = distance2D(info2.offset, { x: 0, y: 0 }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold)
        return;
      const { point: point2 } = info2;
      const { timestamp: timestamp2 } = frameData;
      this.history.push({ ...point2, timestamp: timestamp2 });
      const { onStart, onMove } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info2);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info2);
    };
    this.handlePointerMove = (event2, info2) => {
      this.lastMoveEvent = event2;
      this.lastMoveEventInfo = transformPoint(info2, this.transformPagePoint);
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event2, info2) => {
      this.end();
      const { onEnd, onSessionEnd, resumeAnimation } = this.handlers;
      if (this.dragSnapToOrigin)
        resumeAnimation && resumeAnimation();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo))
        return;
      const panInfo = getPanInfo(event2.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info2, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event2, panInfo);
      }
      onSessionEnd && onSessionEnd(event2, panInfo);
    };
    if (!isPrimaryPointer(event))
      return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const { point } = initialInfo;
    const { timestamp } = frameData;
    this.history = [{ ...point, timestamp }];
    const { onSessionStart } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
};
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a2, b2) {
  return { x: a2.x - b2.x, y: a2.y - b2.y };
}
function getPanInfo({ point }, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  let i2 = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i2 >= 0) {
    timestampedPoint = history[i2];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i2--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  const time3 = millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time3 === 0) {
    return { x: 0, y: 0 };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time3,
    y: (lastPoint.y - timestampedPoint.y) / time3
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}

// ../node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
function applyConstraints(point, { min: min2, max: max2 }, elastic) {
  if (min2 !== void 0 && point < min2) {
    point = elastic ? mixNumber(min2, point, elastic.min) : Math.max(point, min2);
  } else if (max2 !== void 0 && point > max2) {
    point = elastic ? mixNumber(max2, point, elastic.max) : Math.min(point, max2);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min2, max2) {
  return {
    min: min2 !== void 0 ? axis.min + min2 : void 0,
    max: max2 !== void 0 ? axis.max + max2 - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, { top, left, bottom, right }) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min2 = constraintsAxis.min - layoutAxis.min;
  let max2 = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min2, max2] = [max2, min2];
  }
  return { min: min2, max: max2 };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin(source, target) {
  let origin2 = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin2 = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin2 = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp2(0, 1, origin2);
}
function rebaseAxisConstraints(layout2, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout2.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout2.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}

// ../node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
var elementDragControls = /* @__PURE__ */ new WeakMap();
var VisualElementDragControls = class {
  constructor(visualElement) {
    this.openDragLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = { x: 0, y: 0 };
    this.constraints = false;
    this.hasMutatedConstraints = false;
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, { snapToCursor = false } = {}) {
    const { presenceContext } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false)
      return;
    const onSessionStart = (event) => {
      const { dragSnapToOrigin: dragSnapToOrigin2 } = this.getProps();
      dragSnapToOrigin2 ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event).point);
      }
    };
    const onStart = (event, info) => {
      const { drag: drag2, dragPropagation, onDragStart } = this.getProps();
      if (drag2 && !dragPropagation) {
        if (this.openDragLock)
          this.openDragLock();
        this.openDragLock = setDragLock(drag2);
        if (!this.openDragLock)
          return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = void 0;
      }
      eachAxis((axis) => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        if (percent.test(current)) {
          const { projection } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length2 = calcLength(measuredAxis);
              current = length2 * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info));
      }
      addValueToWillChange(this.visualElement, "transform");
      const { animationState } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      const { dragPropagation, dragDirectionLock, onDirectionLock, onDrag } = this.getProps();
      if (!dragPropagation && !this.openDragLock)
        return;
      const { offset: offset4 } = info;
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset4);
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      this.updateAxis("x", info.point, offset4);
      this.updateAxis("y", info.point, offset4);
      this.visualElement.render();
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    const resumeAnimation = () => eachAxis((axis) => {
      var _a;
      return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.play());
    });
    const { dragSnapToOrigin } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    const isDragging2 = this.isDragging;
    this.cancel();
    if (!isDragging2)
      return;
    const { velocity } = info;
    this.startAnimation(velocity);
    const { onDragEnd } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const { projection, animationState } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = void 0;
    const { dragPropagation } = this.getProps();
    if (!dragPropagation && this.openDragLock) {
      this.openDragLock();
      this.openDragLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset4) {
    const { drag: drag2 } = this.getProps();
    if (!offset4 || !shouldDrag(axis, drag2, this.currentDirection))
      return;
    const axisValue = this.getAxisMotionValue(axis);
    let next2 = this.originPoint[axis] + offset4[axis];
    if (this.constraints && this.constraints[axis]) {
      next2 = applyConstraints(next2, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next2);
  }
  resolveConstraints() {
    var _a;
    const { dragConstraints, dragElastic } = this.getProps();
    const layout2 = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) == null ? void 0 : _a.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout2) {
        this.constraints = calcRelativeConstraints(layout2.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    if (prevConstraints !== this.constraints && layout2 && this.constraints && !this.hasMutatedConstraints) {
      eachAxis((axis) => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout2.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const { dragConstraints: constraints, onMeasureDragConstraints } = this.getProps();
    if (!constraints || !isRefObject(constraints))
      return false;
    const constraintsElement = constraints.current;
    invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const { projection } = this.visualElement;
    if (!projection || !projection.layout)
      return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const { drag: drag2, dragMomentum, dragElastic, dragTransition, dragSnapToOrigin, onDragTransitionEnd } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin)
        transition = { min: 0, max: 0 };
      const bounceStiffness = dragElastic ? 200 : 1e6;
      const bounceDamping = dragElastic ? 40 : 1e7;
      const inertia2 = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      return this.startAxisValueAnimation(axis, inertia2);
    });
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    addValueToWillChange(this.visualElement, axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
  }
  stopAnimation() {
    eachAxis((axis) => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis((axis) => {
      var _a;
      return (_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.pause();
    });
  }
  getAnimationState(axis) {
    var _a;
    return (_a = this.getAxisMotionValue(axis).animation) == null ? void 0 : _a.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : void 0) || 0);
  }
  snapToCursor(point) {
    eachAxis((axis) => {
      const { drag: drag2 } = this.getProps();
      if (!shouldDrag(axis, drag2, this.currentDirection))
        return;
      const { projection } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const { min: min2, max: max2 } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mixNumber(min2, max2, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current)
      return;
    const { drag: drag2, dragConstraints } = this.getProps();
    const { projection } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints)
      return;
    this.stopAnimation();
    const boxProgress = { x: 0, y: 0 };
    eachAxis((axis) => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({ min: latest, max: latest }, this.constraints[axis]);
      }
    });
    const { transformTemplate } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    eachAxis((axis) => {
      if (!shouldDrag(axis, drag2, null))
        return;
      const axisValue = this.getAxisMotionValue(axis);
      const { min: min2, max: max2 } = this.constraints[axis];
      axisValue.set(mixNumber(min2, max2, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current)
      return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    const stopPointerListener = addPointerEvent(element, "pointerdown", (event) => {
      const { drag: drag2, dragListener = true } = this.getProps();
      drag2 && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const { dragConstraints } = this.getProps();
      if (isRefObject(dragConstraints) && dragConstraints.current) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const { projection } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    frame.read(measureDragConstraints);
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({ delta, hasLayoutChanged }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis((axis) => {
          const motionValue2 = this.getAxisMotionValue(axis);
          if (!motionValue2)
            return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue2.set(motionValue2.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const { drag: drag2 = false, dragDirectionLock = false, dragPropagation = false, dragConstraints = false, dragElastic = defaultElastic, dragMomentum = true } = props;
    return {
      ...props,
      drag: drag2,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
};
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset4, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset4.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset4.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}

// ../node_modules/framer-motion/dist/es/gestures/drag/index.mjs
var DragGesture = class extends Feature {
  constructor(node2) {
    super(node2);
    this.removeGroupControls = noop;
    this.removeListeners = noop;
    this.controls = new VisualElementDragControls(node2);
  }
  mount() {
    const { dragControls } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || noop;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
};

// ../node_modules/framer-motion/dist/es/gestures/pan/index.mjs
var asyncHandler = (handler) => (event, info) => {
  if (handler) {
    frame.postRender(() => handler(event, info));
  }
};
var PanGesture = class extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = noop;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const { onPanSessionStart, onPanStart, onPan, onPanEnd } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", (event) => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
};

// ../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react13 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
var import_react12 = __toESM(require_react(), 1);
var SwitchLayoutGroupContext = (0, import_react12.createContext)({});

// ../node_modules/framer-motion/dist/es/projection/node/state.mjs
var globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};

// ../node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
var correctBorderRadius = {
  correct: (latest, node2) => {
    if (!node2.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    const x2 = pixelsToPercent(latest, node2.target.x);
    const y2 = pixelsToPercent(latest, node2.target.y);
    return `${x2}% ${y2}%`;
  }
};

// ../node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
var correctBoxShadow = {
  correct: (latest, { treeScale, projectionDelta }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    const template = complex.createTransformer(latest);
    const offset4 = typeof shadow[0] !== "number" ? 1 : 0;
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset4] /= xScale;
    shadow[1 + offset4] /= yScale;
    const averageScale = mixNumber(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset4] === "number")
      shadow[2 + offset4] /= averageScale;
    if (typeof shadow[3 + offset4] === "number")
      shadow[3 + offset4] /= averageScale;
    return template(shadow);
  }
};

// ../node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
var scaleCorrectors = {};
function addScaleCorrector(correctors) {
  for (const key2 in correctors) {
    scaleCorrectors[key2] = correctors[key2];
    if (isCSSVariableName(key2)) {
      scaleCorrectors[key2].isCSSVariable = true;
    }
  }
}

// ../node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var MeasureLayoutWithContext = class extends import_react13.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const { visualElement, layoutGroup, switchLayoutGroup, layoutId } = this.props;
    const { projection } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group)
        layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const { layoutDependency, visualElement, drag: drag2, isPresent } = this.props;
    const { projection } = visualElement;
    if (!projection)
      return null;
    projection.isPresent = isPresent;
    if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0 || prevProps.isPresent !== isPresent) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const { projection } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const { visualElement, layoutGroup, switchLayoutGroup: promoteContext } = this.props;
    const { projection } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group)
        layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister)
        promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const { safeToRemove } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
};
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = (0, import_react13.useContext)(LayoutGroupContext);
  return (0, import_jsx_runtime4.jsx)(MeasureLayoutWithContext, { ...props, layoutGroup, switchLayoutGroup: (0, import_react13.useContext)(SwitchLayoutGroupContext), isPresent, safeToRemove });
}
var defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: [
      "borderTopLeftRadius",
      "borderTopRightRadius",
      "borderBottomLeftRadius",
      "borderBottomRightRadius"
    ]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};

// ../node_modules/framer-motion/dist/es/animation/animate/single-value.mjs
function animateSingleValue(value, keyframes2, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes2, options));
  return motionValue$1.animation;
}

// ../node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
var compareByDepth = (a2, b2) => a2.depth - b2.depth;

// ../node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
var FlatTree = class {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
};

// ../node_modules/framer-motion/dist/es/utils/delay.mjs
function delay(callback, timeout) {
  const start = time.now();
  const checkElapsed = ({ timestamp }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.setup(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}

// ../node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
function resolveMotionValue(value) {
  return isMotionValue(value) ? value.get() : value;
}

// ../node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
var asNumber = (value) => typeof value === "string" ? parseFloat(value) : value;
var isPx = (value) => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress2, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber(0, lead.opacity ?? 1, easeCrossfadeIn(progress2));
    target.opacityExit = mixNumber(follow.opacity ?? 1, 0, easeCrossfadeOut(progress2));
  } else if (isOnlyMember) {
    target.opacity = mixNumber(follow.opacity ?? 1, lead.opacity ?? 1, progress2);
  }
  for (let i2 = 0; i2 < numBorders; i2++) {
    const borderLabel = `border${borders[i2]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber(asNumber(followRadius), asNumber(leadRadius), progress2), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber(follow.rotate || 0, lead.rotate || 0, progress2);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== void 0 ? values[radiusName] : values.borderRadius;
}
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, noop);
function compress(min2, max2, easing) {
  return (p2) => {
    if (p2 < min2)
      return 0;
    if (p2 > max2)
      return 1;
    return easing(progress(min2, max2, p2));
  };
}

// ../node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}

// ../node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate = 0, scale2 = 1, origin2 = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  let originPoint = mixNumber(originAxis.min, originAxis.max, origin2);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms, [key2, scaleKey, originKey], origin2, sourceAxis) {
  removeAxisDelta(axis, transforms[key2], transforms[scaleKey], transforms[originKey], transforms.scale, origin2, sourceAxis);
}
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : void 0, sourceBox ? sourceBox.x : void 0);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : void 0, sourceBox ? sourceBox.y : void 0);
}

// ../node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a2, b2) {
  return a2.min === b2.min && a2.max === b2.max;
}
function boxEquals(a2, b2) {
  return axisEquals(a2.x, b2.x) && axisEquals(a2.y, b2.y);
}
function axisEqualsRounded(a2, b2) {
  return Math.round(a2.min) === Math.round(b2.min) && Math.round(a2.max) === Math.round(b2.max);
}
function boxEqualsRounded(a2, b2) {
  return axisEqualsRounded(a2.x, b2.x) && axisEqualsRounded(a2.y, b2.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a2, b2) {
  return a2.translate === b2.translate && a2.scale === b2.scale && a2.originPoint === b2.originPoint;
}

// ../node_modules/framer-motion/dist/es/projection/shared/stack.mjs
var NodeStack = class {
  constructor() {
    this.members = [];
  }
  add(node2) {
    addUniqueItem(this.members, node2);
    node2.scheduleRender();
  }
  remove(node2) {
    removeItem(this.members, node2);
    if (node2 === this.prevLead) {
      this.prevLead = void 0;
    }
    if (node2 === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node2) {
    const indexOfNode = this.members.findIndex((member) => node2 === member);
    if (indexOfNode === 0)
      return false;
    let prevLead;
    for (let i2 = indexOfNode; i2 >= 0; i2--) {
      const member = this.members[i2];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node2, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node2 === prevLead)
      return;
    this.prevLead = prevLead;
    this.lead = node2;
    node2.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node2.scheduleRender();
      node2.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node2.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node2.snapshot = prevLead.snapshot;
        node2.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node2.root && node2.root.isUpdating) {
        node2.isLayoutDirty = true;
      }
      const { crossfade } = node2.options;
      if (crossfade === false) {
        prevLead.hide();
      }
    }
  }
  exitAnimationComplete() {
    this.members.forEach((node2) => {
      const { options, resumingFrom } = node2;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach((node2) => {
      node2.instance && node2.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = void 0;
    }
  }
};

// ../node_modules/framer-motion/dist/es/projection/styles/transform.mjs
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform2 = "";
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = (latestTransform == null ? void 0 : latestTransform.z) || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform2 = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform2 += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const { transformPerspective, rotate: rotate4, rotateX, rotateY, skewX, skewY } = latestTransform;
    if (transformPerspective)
      transform2 = `perspective(${transformPerspective}px) ${transform2}`;
    if (rotate4)
      transform2 += `rotate(${rotate4}deg) `;
    if (rotateX)
      transform2 += `rotateX(${rotateX}deg) `;
    if (rotateY)
      transform2 += `rotateY(${rotateY}deg) `;
    if (skewX)
      transform2 += `skewX(${skewX}deg) `;
    if (skewY)
      transform2 += `skewY(${skewY}deg) `;
  }
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform2 += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform2 || "none";
}

// ../node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
var metrics = {
  nodes: 0,
  calculatedTargetDeltas: 0,
  calculatedProjections: 0
};
var transformAxes = ["", "X", "Y", "Z"];
var hiddenVisibility = { visibility: "hidden" };
var animationTarget = 1e3;
var id2 = 0;
function resetDistortingTransform(key2, visualElement, values, sharedAnimationValues) {
  const { latestValues } = visualElement;
  if (latestValues[key2]) {
    values[key2] = latestValues[key2];
    visualElement.setStaticValue(key2, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key2] = 0;
    }
  }
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode)
    return;
  const { visualElement } = projectionNode.options;
  if (!visualElement)
    return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const { layout: layout2, layoutId } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout2 || layoutId));
  }
  const { parent } = projectionNode;
  if (parent && !parent.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent);
  }
}
function createProjectionNode({ attachResizeListener, defaultParent, measureScroll, checkIsScrollRoot, resetTransform }) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent == null ? void 0 : defaultParent()) {
      this.id = id2++;
      this.animationId = 0;
      this.children = /* @__PURE__ */ new Set();
      this.options = {};
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      this.isLayoutDirty = false;
      this.isProjectionDirty = false;
      this.isSharedProjectionDirty = false;
      this.isTransformDirty = false;
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      this.isUpdating = false;
      this.isSVG = false;
      this.needsReset = false;
      this.shouldResetTransform = false;
      this.hasCheckedOptimisedAppear = false;
      this.treeScale = { x: 1, y: 1 };
      this.eventHandlers = /* @__PURE__ */ new Map();
      this.hasTreeAnimated = false;
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        if (statsBuffer.value) {
          metrics.nodes = metrics.calculatedTargetDeltas = metrics.calculatedProjections = 0;
        }
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        if (statsBuffer.addProjectionMetrics) {
          statsBuffer.addProjectionMetrics(metrics);
        }
      };
      this.resolvedRelativeTargetAt = 0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      this.sharedNodes = /* @__PURE__ */ new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        this.path[i2].shouldResetTransform = true;
      }
      if (this.root === this)
        this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance) {
      if (this.instance)
        return;
      this.isSVG = isSVGElement(instance) && !isSVGSVGElement(instance);
      this.instance = instance;
      const { layoutId, layout: layout2, visualElement } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (this.root.hasTreeAnimated && (layout2 || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      if (this.options.animate !== false && visualElement && (layoutId || layout2)) {
        this.addEventListener("didUpdate", ({ delta, hasLayoutChanged, hasRelativeLayoutChanged, layout: newLayout }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = void 0;
            this.relativeTarget = void 0;
            return;
          }
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const { onLayoutAnimationStart, onLayoutAnimationComplete } = visualElement.getProps();
          const hasTargetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout);
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeLayoutChanged;
          if (this.options.layoutRoot || this.resumeFrom || hasOnlyRelativeTargetChanged || hasLayoutChanged && (hasTargetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = void 0;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = void 0;
      this.eventHandlers.clear();
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked())
        return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const { visualElement } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty)
        return;
      this.isLayoutDirty = true;
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        node2.shouldResetTransform = true;
        node2.updateScroll("snapshot");
        if (node2.options.layoutRoot) {
          node2.willUpdate(false);
        }
      }
      const { layoutId, layout: layout2 } = this.options;
      if (layoutId === void 0 && !layout2)
        return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      this.nodes.forEach(resetTransformStyle);
      this.nodes.forEach(updateLayout);
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      const now2 = time.now();
      frameData.delta = clamp2(0, 1e3 / 60, now2 - frameData.timestamp);
      frameData.timestamp = now2;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance)
        return;
      this.snapshot = this.measure();
      if (this.snapshot && !calcLength(this.snapshot.measuredBox.x) && !calcLength(this.snapshot.measuredBox.y)) {
        this.snapshot = void 0;
      }
    }
    updateLayout() {
      if (!this.instance)
        return;
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i2 = 0; i2 < this.path.length; i2++) {
          const node2 = this.path[i2];
          node2.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = void 0;
      this.notifyListeners("measure", this.layout.layoutBox);
      const { visualElement } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : void 0);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement && this.instance) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform)
        return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : void 0;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && this.instance && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var _a;
      const { visualElement } = this.options;
      if (!visualElement)
        return createBox();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = ((_a = this.scroll) == null ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        const { scroll: scroll2 } = this.root;
        if (scroll2) {
          translateAxis(box.x, scroll2.offset.x);
          translateAxis(box.y, scroll2.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      var _a;
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      if ((_a = this.scroll) == null ? void 0 : _a.wasRoot) {
        return boxWithoutScroll;
      }
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        const { scroll: scroll2, options } = node2;
        if (node2 !== this.root && scroll2 && options.layoutScroll) {
          if (scroll2.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll2.offset.x);
          translateAxis(boxWithoutScroll.y, scroll2.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!transformOnly && node2.options.layoutScroll && node2.scroll && node2 !== node2.root) {
          transformBox(withTransforms, {
            x: -node2.scroll.offset.x,
            y: -node2.scroll.offset.y
          });
        }
        if (!hasTransform(node2.latestValues))
          continue;
        transformBox(withTransforms, node2.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i2 = 0; i2 < this.path.length; i2++) {
        const node2 = this.path[i2];
        if (!node2.instance)
          continue;
        if (!hasTransform(node2.latestValues))
          continue;
        hasScale(node2.latestValues) && node2.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node2.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node2.latestValues, node2.snapshot ? node2.snapshot.layoutBox : void 0, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== void 0 ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = void 0;
      this.layout = void 0;
      this.snapshot = void 0;
      this.prevTransformTemplateValue = void 0;
      this.targetDelta = void 0;
      this.target = void 0;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent)
        return;
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a;
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) == null ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      if (!this.layout || !(layout2 || layoutId))
        return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (!this.relativeTarget && !this.targetDelta)
        return;
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = void 0;
        }
      }
      if (statsBuffer.value) {
        metrics.calculatedTargetDeltas++;
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return void 0;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      if (this.isProjectionDirty || ((_a = this.parent) == null ? void 0 : _a.isProjectionDirty)) {
        canSkip = false;
      }
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip)
        return;
      const { layout: layout2, layoutId } = this.options;
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = void 0;
      }
      if (!this.layout || !(layout2 || layoutId))
        return;
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const { target } = lead;
      if (!target) {
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      if (statsBuffer.value) {
        metrics.calculatedProjections++;
      }
    }
    hide() {
      this.isVisible = false;
    }
    show() {
      this.isVisible = true;
    }
    scheduleRender(notifyAll = true) {
      var _a;
      (_a = this.options.visualElement) == null ? void 0 : _a.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = void 0;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = { ...this.latestValues };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = void 0;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : void 0;
      const layoutSource = this.layout ? this.layout.source : void 0;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = (latest) => {
        const progress2 = latest / 1e3;
        mixAxisDelta(targetDelta.x, delta.x, progress2);
        mixAxisDelta(targetDelta.y, delta.y, progress2);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress2);
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget)
            prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress2, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress2;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);
    }
    startAnimation(options) {
      var _a, _b, _c;
      this.notifyListeners("animationStart");
      (_a = this.currentAnimation) == null ? void 0 : _a.stop(false);
      (_c = (_b = this.resumingFrom) == null ? void 0 : _b.currentAnimation) == null ? void 0 : _c.stop(false);
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = void 0;
      }
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        activeAnimations.layout++;
        this.motionValue || (this.motionValue = motionValue(0));
        this.currentAnimation = animateSingleValue(this.motionValue, [0, 1e3], {
          ...options,
          isSync: true,
          onUpdate: (latest) => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onStop: () => {
            activeAnimations.layout--;
          },
          onComplete: () => {
            activeAnimations.layout--;
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = void 0;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = void 0;
        this.resumingFrom.preserveOpacity = void 0;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop(false);
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let { targetWithTransforms, target, layout: layout2, latestValues } = lead;
      if (!targetWithTransforms || !target || !layout2)
        return;
      if (this !== lead && this.layout && layout2 && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout2.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      transformBox(targetWithTransforms, latestValues);
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node2) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node2);
      const config = node2.options.initialPromotionConfig;
      node2.promote({
        transition: config ? config.transition : void 0,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node2) : void 0
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? ((_a = this.getStack()) == null ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const { layoutId } = this.options;
      return layoutId ? (_a = this.getStack()) == null ? void 0 : _a.prevLead : void 0;
    }
    getStack() {
      const { layoutId } = this.options;
      if (layoutId)
        return this.root.sharedNodes.get(layoutId);
    }
    promote({ needsReset, transition, preserveFollowOpacity } = {}) {
      const stack = this.getStack();
      if (stack)
        stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = void 0;
        this.needsReset = true;
      }
      if (transition)
        this.setOptions({ transition });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const { visualElement } = this.options;
      if (!visualElement)
        return;
      let hasDistortingTransform = false;
      const { latestValues } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      if (!hasDistortingTransform)
        return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      for (let i2 = 0; i2 < transformAxes.length; i2++) {
        resetDistortingTransform(`rotate${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i2]}`, visualElement, resetValues, this.animationValues);
      }
      visualElement.render();
      for (const key2 in resetValues) {
        visualElement.setStaticValue(key2, resetValues[key2]);
        if (this.animationValues) {
          this.animationValues[key2] = resetValues[key2];
        }
      }
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      if (!this.instance || this.isSVG)
        return void 0;
      if (!this.isVisible) {
        return hiddenVisibility;
      }
      const styles = {
        visibility: ""
      };
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const { x: x2, y: y2 } = this.projectionDelta;
      styles.transformOrigin = `${x2.origin * 100}% ${y2.origin * 100}% 0`;
      if (lead.animationValues) {
        styles.opacity = lead === this ? valuesToRender.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        styles.opacity = lead === this ? valuesToRender.opacity !== void 0 ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== void 0 ? valuesToRender.opacityExit : 0;
      }
      for (const key2 in scaleCorrectors) {
        if (valuesToRender[key2] === void 0)
          continue;
        const { correct, applyTo, isCSSVariable } = scaleCorrectors[key2];
        const corrected = styles.transform === "none" ? valuesToRender[key2] : correct(valuesToRender[key2], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i2 = 0; i2 < num; i2++) {
            styles[applyTo[i2]] = corrected;
          }
        } else {
          if (isCSSVariable) {
            this.options.visualElement.renderState.vars[key2] = corrected;
          } else {
            styles[key2] = corrected;
          }
        }
      }
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp == null ? void 0 : styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = void 0;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach((node2) => {
        var _a;
        return (_a = node2.currentAnimation) == null ? void 0 : _a.stop(false);
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node2) {
  node2.updateLayout();
}
function notifyLayoutUpdate(node2) {
  var _a;
  const snapshot = ((_a = node2.resumeFrom) == null ? void 0 : _a.snapshot) || node2.snapshot;
  if (node2.isLead() && node2.layout && snapshot && node2.hasListeners("didUpdate")) {
    const { layoutBox: layout2, measuredBox: measuredLayout } = node2.layout;
    const { animationType } = node2.options;
    const isShared = snapshot.source !== node2.layout.source;
    if (animationType === "size") {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout2[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout2)) {
      eachAxis((axis) => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length2 = calcLength(layout2[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
        if (node2.relativeTarget && !node2.currentAnimation) {
          node2.isProjectionDirty = true;
          node2.relativeTarget[axis].max = node2.relativeTarget[axis].min + length2;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout2, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node2.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout2, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeLayoutChanged = false;
    if (!node2.resumeFrom) {
      const relativeParent = node2.getClosestProjectingParent();
      if (relativeParent && !relativeParent.resumeFrom) {
        const { snapshot: parentSnapshot, layout: parentLayout } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout2, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeLayoutChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node2.relativeTarget = relativeLayout;
            node2.relativeTargetOrigin = relativeSnapshot;
            node2.relativeParent = relativeParent;
          }
        }
      }
    }
    node2.notifyListeners("didUpdate", {
      layout: layout2,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeLayoutChanged
    });
  } else if (node2.isLead()) {
    const { onExitComplete } = node2.options;
    onExitComplete && onExitComplete();
  }
  node2.options.transition = void 0;
}
function propagateDirtyNodes(node2) {
  if (statsBuffer.value) {
    metrics.nodes++;
  }
  if (!node2.parent)
    return;
  if (!node2.isProjecting()) {
    node2.isProjectionDirty = node2.parent.isProjectionDirty;
  }
  node2.isSharedProjectionDirty || (node2.isSharedProjectionDirty = Boolean(node2.isProjectionDirty || node2.parent.isProjectionDirty || node2.parent.isSharedProjectionDirty));
  node2.isTransformDirty || (node2.isTransformDirty = node2.parent.isTransformDirty);
}
function cleanDirtyNodes(node2) {
  node2.isProjectionDirty = node2.isSharedProjectionDirty = node2.isTransformDirty = false;
}
function clearSnapshot(node2) {
  node2.clearSnapshot();
}
function clearMeasurements(node2) {
  node2.clearMeasurements();
}
function clearIsLayoutDirty(node2) {
  node2.isLayoutDirty = false;
}
function resetTransformStyle(node2) {
  const { visualElement } = node2.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node2.resetTransform();
}
function finishAnimation(node2) {
  node2.finishAnimation();
  node2.targetDelta = node2.relativeTarget = node2.target = void 0;
  node2.isProjectionDirty = true;
}
function resolveTargetDelta(node2) {
  node2.resolveTargetDelta();
}
function calcProjection(node2) {
  node2.calcProjection();
}
function resetSkewAndRotation(node2) {
  node2.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mixNumber(delta.translate, 0, p2);
  output.scale = mixNumber(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from2, to, p2) {
  output.min = mixNumber(from2.min, to.min, p2);
  output.max = mixNumber(from2.max, to.max, p2);
}
function mixBox(output, from2, to, p2) {
  mixAxis(output.x, from2.x, to.x, p2);
  mixAxis(output.y, from2.y, to.y, p2);
}
function hasOpacityCrossfade(node2) {
  return node2.animationValues && node2.animationValues.opacityExit !== void 0;
}
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
var userAgentContains = (string) => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
var roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : noop;
function roundAxis(axis) {
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout2) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout2), 0.2);
}
function checkNodeWasScrollRoot(node2) {
  var _a;
  return node2 !== node2.root && ((_a = node2.scroll) == null ? void 0 : _a.wasRoot);
}

// ../node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
var DocumentProjectionNode = createProjectionNode({
  attachResizeListener: (ref, notify2) => addDomEvent(ref, "resize", notify2),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});

// ../node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
var rootProjectionNode = {
  current: void 0
};
var HTMLProjectionNode = createProjectionNode({
  measureScroll: (instance) => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: (instance) => Boolean(window.getComputedStyle(instance).position === "fixed")
});

// ../node_modules/framer-motion/dist/es/motion/features/drag.mjs
var drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};

// ../node_modules/framer-motion/dist/es/gestures/hover.mjs
function handleHoverEvent(node2, event, lifecycle) {
  const { props } = node2;
  if (node2.animationState && props.whileHover) {
    node2.animationState.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = "onHover" + lifecycle;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
var HoverGesture = class extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = hover(current, (_element, startEvent) => {
      handleHoverEvent(this.node, startEvent, "Start");
      return (endEvent) => handleHoverEvent(this.node, endEvent, "End");
    });
  }
  unmount() {
  }
};

// ../node_modules/framer-motion/dist/es/gestures/focus.mjs
var FocusGesture = class extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState)
      return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {
  }
};

// ../node_modules/framer-motion/dist/es/gestures/press.mjs
function handlePressEvent(node2, event, lifecycle) {
  const { props } = node2;
  if (node2.current instanceof HTMLButtonElement && node2.current.disabled) {
    return;
  }
  if (node2.animationState && props.whileTap) {
    node2.animationState.setActive("whileTap", lifecycle === "Start");
  }
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
var PressGesture = class extends Feature {
  mount() {
    const { current } = this.node;
    if (!current)
      return;
    this.unmount = press(current, (_element, startEvent) => {
      handlePressEvent(this.node, startEvent, "Start");
      return (endEvent, { success }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
    }, { useGlobalTarget: this.node.props.globalTapTarget });
  }
  unmount() {
  }
};

// ../node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
var observerCallbacks = /* @__PURE__ */ new WeakMap();
var observers = /* @__PURE__ */ new WeakMap();
var fireObserverCallback = (entry) => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
var fireAllObserverCallbacks = (entries) => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({ root, ...options }) {
  const lookupRoot = root || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key2 = JSON.stringify(options);
  if (!rootObservers[key2]) {
    rootObservers[key2] = new IntersectionObserver(fireAllObserverCallbacks, { root, ...options });
  }
  return rootObservers[key2];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}

// ../node_modules/framer-motion/dist/es/motion/features/viewport/index.mjs
var thresholdNames = {
  some: 0,
  all: 1
};
var InViewFeature = class extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const { viewport = {} } = this.node.getProps();
    const { root, margin: rootMargin, amount = "some", once } = viewport;
    const options = {
      root: root ? root.current : void 0,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = (entry) => {
      const { isIntersecting } = entry;
      if (this.isInView === isIntersecting)
        return;
      this.isInView = isIntersecting;
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      const { onViewportEnter, onViewportLeave } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined")
      return;
    const { props, prevProps } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {
  }
};
function hasViewportOptionChanged({ viewport = {} }, { viewport: prevViewport = {} } = {}) {
  return (name) => viewport[name] !== prevViewport[name];
}

// ../node_modules/framer-motion/dist/es/motion/features/gestures.mjs
var gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};

// ../node_modules/framer-motion/dist/es/motion/features/layout.mjs
var layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};

// ../node_modules/framer-motion/dist/es/motion/index.mjs
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react19 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/context/LazyContext.mjs
var import_react14 = __toESM(require_react(), 1);
var LazyContext = (0, import_react14.createContext)({ strict: false });

// ../node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
var import_react15 = __toESM(require_react(), 1);
var MotionContext = (0, import_react15.createContext)({});

// ../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
var import_react16 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/render/utils/is-controlling-variants.mjs
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some((name) => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}

// ../node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const { initial, animate: animate2 } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate2) ? animate2 : void 0
    };
  }
  return props.inherit !== false ? context : {};
}

// ../node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
function useCreateMotionContext(props) {
  const { initial, animate: animate2 } = getCurrentTreeVariants(props, (0, import_react16.useContext)(MotionContext));
  return (0, import_react16.useMemo)(() => ({ initial, animate: animate2 }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate2)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}

// ../node_modules/framer-motion/dist/es/motion/features/definitions.mjs
var featureProps = {
  animation: [
    "animate",
    "variants",
    "whileHover",
    "whileTap",
    "exit",
    "whileInView",
    "whileFocus",
    "whileDrag"
  ],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
var featureDefinitions = {};
for (const key2 in featureProps) {
  featureDefinitions[key2] = {
    isEnabled: (props) => featureProps[key2].some((name) => !!props[name])
  };
}

// ../node_modules/framer-motion/dist/es/motion/features/load-features.mjs
function loadFeatures(features) {
  for (const key2 in features) {
    featureDefinitions[key2] = {
      ...featureDefinitions[key2],
      ...features[key2]
    };
  }
}

// ../node_modules/framer-motion/dist/es/motion/utils/symbol.mjs
var motionComponentSymbol = Symbol.for("motionComponentSymbol");

// ../node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
var import_react17 = __toESM(require_react(), 1);
function useMotionRef(visualState, visualElement, externalRef) {
  return (0, import_react17.useCallback)(
    (instance) => {
      if (instance) {
        visualState.onMount && visualState.onMount(instance);
      }
      if (visualElement) {
        if (instance) {
          visualElement.mount(instance);
        } else {
          visualElement.unmount();
        }
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement]
  );
}

// ../node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
var import_react18 = __toESM(require_react(), 1);
function useVisualElement(Component4, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  var _a, _b;
  const { visualElement: parent } = (0, import_react18.useContext)(MotionContext);
  const lazyContext = (0, import_react18.useContext)(LazyContext);
  const presenceContext = (0, import_react18.useContext)(PresenceContext);
  const reducedMotionConfig = (0, import_react18.useContext)(MotionConfigContext).reducedMotion;
  const visualElementRef = (0, import_react18.useRef)(null);
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component4, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  const initialLayoutGroupConfig = (0, import_react18.useContext)(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode2(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  const isMounted = (0, import_react18.useRef)(false);
  (0, import_react18.useInsertionEffect)(() => {
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = (0, import_react18.useRef)(Boolean(optimisedAppearId) && !((_a = window.MotionHandoffIsComplete) == null ? void 0 : _a.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) == null ? void 0 : _b.call(window, optimisedAppearId)));
  useIsomorphicLayoutEffect(() => {
    if (!visualElement)
      return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    microtask.render(visualElement.render);
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  (0, import_react18.useEffect)(() => {
    if (!visualElement)
      return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      queueMicrotask(() => {
        var _a2;
        (_a2 = window.MotionHandoffMarkAsComplete) == null ? void 0 : _a2.call(window, optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
  });
  return visualElement;
}
function createProjectionNode2(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const { layoutId, layout: layout2, drag: drag2, dragConstraints, layoutScroll, layoutRoot, layoutCrossfade } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? void 0 : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout: layout2,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout2 === "string" ? layout2 : "both",
    initialPromotionConfig,
    crossfade: layoutCrossfade,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (!visualElement)
    return void 0;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}

// ../node_modules/framer-motion/dist/es/motion/index.mjs
function createRendererMotionComponent({ preloadedFeatures, createVisualElement, useRender, useVisualState: useVisualState2, Component: Component4 }) {
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    let MeasureLayout2;
    const configAndProps = {
      ...(0, import_react19.useContext)(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const { isStatic } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState2(props, isStatic);
    if (!isStatic && isBrowser) {
      useStrictMode(configAndProps, preloadedFeatures);
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout2 = layoutProjection.MeasureLayout;
      context.visualElement = useVisualElement(Component4, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    return (0, import_jsx_runtime5.jsxs)(MotionContext.Provider, { value: context, children: [MeasureLayout2 && context.visualElement ? (0, import_jsx_runtime5.jsx)(MeasureLayout2, { visualElement: context.visualElement, ...configAndProps }) : null, useRender(Component4, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)] });
  }
  MotionComponent.displayName = `motion.${typeof Component4 === "string" ? Component4 : `create(${Component4.displayName ?? Component4.name ?? ""})`}`;
  const ForwardRefMotionComponent = (0, import_react19.forwardRef)(MotionComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component4;
  return ForwardRefMotionComponent;
}
function useLayoutId({ layoutId }) {
  const layoutGroupId = (0, import_react19.useContext)(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  const isStrict = (0, import_react19.useContext)(LazyContext).strict;
  if (preloadedFeatures && isStrict) {
    const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    configAndProps.ignoreStrict ? warning(false, strictMessage) : invariant(false, strictMessage);
  }
}
function getProjectionFunctionality(props) {
  const { drag: drag2, layout: layout2 } = featureDefinitions;
  if (!drag2 && !layout2)
    return {};
  const combined = { ...drag2, ...layout2 };
  return {
    MeasureLayout: (drag2 == null ? void 0 : drag2.isEnabled(props)) || (layout2 == null ? void 0 : layout2.isEnabled(props)) ? combined.MeasureLayout : void 0,
    ProjectionNode: combined.ProjectionNode
  };
}

// ../node_modules/framer-motion/dist/es/render/dom/use-render.mjs
var import_react22 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/render/html/use-props.mjs
var import_react20 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
function isForcedMotionValue(key2, { layout: layout2, layoutId }) {
  return transformProps.has(key2) || key2.startsWith("origin") || (layout2 || layoutId !== void 0) && (!!scaleCorrectors[key2] || key2 === "opacity");
}

// ../node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
var numTransforms = transformPropOrder.length;
function buildTransform2(latestValues, transform2, transformTemplate) {
  let transformString = "";
  let transformIsDefault = true;
  for (let i2 = 0; i2 < numTransforms; i2++) {
    const key2 = transformPropOrder[i2];
    const value = latestValues[key2];
    if (value === void 0)
      continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key2.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key2]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key2] || key2;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform2[key2] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  if (transformTemplate) {
    transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}

// ../node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const { style, vars, transformOrigin } = state;
  let hasTransform2 = false;
  let hasTransformOrigin = false;
  for (const key2 in latestValues) {
    const value = latestValues[key2];
    if (transformProps.has(key2)) {
      hasTransform2 = true;
      continue;
    } else if (isCSSVariableName(key2)) {
      vars[key2] = value;
      continue;
    } else {
      const valueAsType = getValueAsType(value, numberValueTypes[key2]);
      if (key2.startsWith("origin")) {
        hasTransformOrigin = true;
        transformOrigin[key2] = valueAsType;
      } else {
        style[key2] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform2 || transformTemplate) {
      style.transform = buildTransform2(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      style.transform = "none";
    }
  }
  if (hasTransformOrigin) {
    const { originX = "50%", originY = "50%", originZ = 0 } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}

// ../node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
var createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});

// ../node_modules/framer-motion/dist/es/render/html/use-props.mjs
function copyRawValuesOnly(target, source, props) {
  for (const key2 in source) {
    if (!isMotionValue(source[key2]) && !isForcedMotionValue(key2, props)) {
      target[key2] = source[key2];
    }
  }
}
function useInitialMotionValues({ transformTemplate }, visualState) {
  return (0, import_react20.useMemo)(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style = {};
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState));
  return style;
}
function useHTMLProps(props, visualState) {
  const htmlProps = {};
  const style = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    htmlProps.draggable = false;
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === void 0 && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}

// ../node_modules/framer-motion/dist/es/render/svg/use-props.mjs
var import_react21 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing = 1, offset4 = 0, useDashCase = true) {
  attrs.pathLength = 1;
  const keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset4);
  const pathLength = px.transform(length2);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}

// ../node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag2, transformTemplate, styleProp) {
  buildHTMLStyles(state, latest, transformTemplate);
  if (isSVGTag2) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const { attrs, style } = state;
  if (attrs.transform) {
    style.transform = attrs.transform;
    delete attrs.transform;
  }
  if (style.transform || attrs.transformOrigin) {
    style.transformOrigin = attrs.transformOrigin ?? "50% 50%";
    delete attrs.transformOrigin;
  }
  if (style.transform) {
    style.transformBox = (styleProp == null ? void 0 : styleProp.transformBox) ?? "fill-box";
    delete attrs.transformBox;
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (attrScale !== void 0)
    attrs.scale = attrScale;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}

// ../node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
var createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});

// ../node_modules/framer-motion/dist/es/render/svg/utils/is-svg-tag.mjs
var isSVGTag = (tag) => typeof tag === "string" && tag.toLowerCase() === "svg";

// ../node_modules/framer-motion/dist/es/render/svg/use-props.mjs
function useSVGProps(props, visualState, _isStatic, Component4) {
  const visualProps = (0, import_react21.useMemo)(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component4), props.transformTemplate, props.style);
    return {
      ...state.attrs,
      style: { ...state.style }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = { ...rawStyles, ...visualProps.style };
  }
  return visualProps;
}

// ../node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
var validMotionProps = /* @__PURE__ */ new Set([
  "animate",
  "exit",
  "variants",
  "initial",
  "style",
  "values",
  "variants",
  "transition",
  "transformTemplate",
  "custom",
  "inherit",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "_dragX",
  "_dragY",
  "onHoverStart",
  "onHoverEnd",
  "onViewportEnter",
  "onViewportLeave",
  "globalTapTarget",
  "ignoreStrict",
  "viewport"
]);
function isValidMotionProp(key2) {
  return key2.startsWith("while") || key2.startsWith("drag") && key2 !== "draggable" || key2.startsWith("layout") || key2.startsWith("onTap") || key2.startsWith("onPan") || key2.startsWith("onLayout") || validMotionProps.has(key2);
}

// ../node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
var shouldForward = (key2) => !isValidMotionProp(key2);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = (key2) => key2.startsWith("on") ? !isValidMotionProp(key2) : isValidProp(key2);
}
try {
  loadExternalIsValidProp((init_emotion_is_prop_valid_esm(), __toCommonJS(emotion_is_prop_valid_esm_exports)).default);
} catch {
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key2 in props) {
    if (key2 === "values" && typeof props.values === "object")
      continue;
    if (shouldForward(key2) || forwardMotionProps === true && isValidMotionProp(key2) || !isDom && !isValidMotionProp(key2) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key2.startsWith("onDrag")) {
      filteredProps[key2] = props[key2];
    }
  }
  return filteredProps;
}

// ../node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "switch",
  "symbol",
  "svg",
  "text",
  "tspan",
  "use",
  "view"
];

// ../node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
function isSVGComponent(Component4) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component4 !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component4.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component4) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/u.test(Component4)
  ) {
    return true;
  }
  return false;
}

// ../node_modules/framer-motion/dist/es/render/dom/use-render.mjs
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component4, props, ref, { latestValues }, isStatic) => {
    const useVisualProps = isSVGComponent(Component4) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component4);
    const filteredProps = filterProps(props, typeof Component4 === "string", forwardMotionProps);
    const elementProps = Component4 !== import_react22.Fragment ? { ...filteredProps, ...visualProps, ref } : {};
    const { children } = props;
    const renderedChildren = (0, import_react22.useMemo)(() => isMotionValue(children) ? children.get() : children, [children]);
    return (0, import_react22.createElement)(Component4, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}

// ../node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
var import_react23 = __toESM(require_react(), 1);
function makeState({ scrapeMotionValuesFromProps: scrapeMotionValuesFromProps3, createRenderState }, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  return state;
}
var makeUseVisualState = (config) => (props, isStatic) => {
  const context = (0, import_react23.useContext)(MotionContext);
  const presenceContext = (0, import_react23.useContext)(PresenceContext);
  const make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key2 in motionValues) {
    values[key2] = resolveMotionValue(motionValues[key2]);
  }
  let { initial, animate: animate2 } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === void 0)
      initial = context.initial;
    if (animate2 === void 0)
      animate2 = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate2 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i2 = 0; i2 < list.length; i2++) {
      const resolved = resolveVariantFromProps(props, list[i2]);
      if (resolved) {
        const { transitionEnd, transition, ...target } = resolved;
        for (const key2 in target) {
          let valueTarget = target[key2];
          if (Array.isArray(valueTarget)) {
            const index2 = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index2];
          }
          if (valueTarget !== null) {
            values[key2] = valueTarget;
          }
        }
        for (const key2 in transitionEnd) {
          values[key2] = transitionEnd[key2];
        }
      }
    }
  }
  return values;
}

// ../node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  var _a;
  const { style } = props;
  const newValues = {};
  for (const key2 in style) {
    if (isMotionValue(style[key2]) || prevProps.style && isMotionValue(prevProps.style[key2]) || isForcedMotionValue(key2, props) || ((_a = visualElement == null ? void 0 : visualElement.getValue(key2)) == null ? void 0 : _a.liveStyle) !== void 0) {
      newValues[key2] = style[key2];
    }
  }
  return newValues;
}

// ../node_modules/framer-motion/dist/es/render/html/config-motion.mjs
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  })
};

// ../node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps2(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps(props, prevProps, visualElement);
  for (const key2 in props) {
    if (isMotionValue(props[key2]) || isMotionValue(prevProps[key2])) {
      const targetKey = transformPropOrder.indexOf(key2) !== -1 ? "attr" + key2.charAt(0).toUpperCase() + key2.substring(1) : key2;
      newValues[targetKey] = props[key2];
    }
  }
  return newValues;
}

// ../node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState
  })
};

// ../node_modules/framer-motion/dist/es/render/components/create-factory.mjs
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return function createMotionComponent2(Component4, { forwardMotionProps } = { forwardMotionProps: false }) {
    const baseConfig = isSVGComponent(Component4) ? svgMotionConfig : htmlMotionConfig;
    const config = {
      ...baseConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component: Component4
    };
    return createRendererMotionComponent(config);
  };
}

// ../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
var import_react24 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/utils/reduced-motion/state.mjs
var prefersReducedMotion = { current: null };
var hasReducedMotionListener = { current: false };

// ../node_modules/framer-motion/dist/es/utils/reduced-motion/index.mjs
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}

// ../node_modules/framer-motion/dist/es/render/store.mjs
var visualElementStore = /* @__PURE__ */ new WeakMap();

// ../node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
function updateMotionValuesFromProps(element, next2, prev2) {
  for (const key2 in next2) {
    const nextValue = next2[key2];
    const prevValue = prev2[key2];
    if (isMotionValue(nextValue)) {
      element.addValue(key2, nextValue);
    } else if (isMotionValue(prevValue)) {
      element.addValue(key2, motionValue(nextValue, { owner: element }));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key2)) {
        const existingValue = element.getValue(key2);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key2);
        element.addValue(key2, motionValue(latestValue !== void 0 ? latestValue : nextValue, { owner: element }));
      }
    }
  }
  for (const key2 in prev2) {
    if (next2[key2] === void 0)
      element.removeValue(key2);
  }
  return next2;
}

// ../node_modules/framer-motion/dist/es/render/VisualElement.mjs
var propEventHandlers = [
  "AnimationStart",
  "AnimationComplete",
  "Update",
  "BeforeLayoutMeasure",
  "LayoutMeasure",
  "LayoutAnimationStart",
  "LayoutAnimationComplete"
];
var VisualElement = class {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({ parent, props, presenceContext, reducedMotionConfig, blockInitialAnimation, visualState }, options = {}) {
    this.current = null;
    this.children = /* @__PURE__ */ new Set();
    this.isVariantNode = false;
    this.isControllingVariants = false;
    this.shouldReduceMotion = null;
    this.values = /* @__PURE__ */ new Map();
    this.KeyframeResolver = KeyframeResolver;
    this.features = {};
    this.valueSubscriptions = /* @__PURE__ */ new Map();
    this.prevMotionValues = {};
    this.events = {};
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current)
        return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0;
    this.scheduleRender = () => {
      const now2 = time.now();
      if (this.renderScheduledAt < now2) {
        this.renderScheduledAt = now2;
        frame.render(this.render, false, true);
      }
    };
    const { latestValues, renderState } = visualState;
    this.latestValues = latestValues;
    this.baseTarget = { ...latestValues };
    this.initialValues = props.initial ? { ...latestValues } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = /* @__PURE__ */ new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    const { willChange, ...initialMotionValues } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key2 in initialMotionValues) {
      const value = initialMotionValues[key2];
      if (latestValues[key2] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key2], false);
      }
    }
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key2) => this.bindToMotionValue(key2, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (true) {
      warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
    }
    if (this.parent)
      this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach((remove) => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key2 in this.events) {
      this.events[key2].clear();
    }
    for (const key2 in this.features) {
      const feature = this.features[key2];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  bindToMotionValue(key2, value) {
    if (this.valueSubscriptions.has(key2)) {
      this.valueSubscriptions.get(key2)();
    }
    const valueIsTransform = transformProps.has(key2);
    if (valueIsTransform && this.onBindTransform) {
      this.onBindTransform();
    }
    const removeOnChange = value.on("change", (latestValue) => {
      this.latestValues[key2] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    let removeSyncCheck;
    if (window.MotionCheckAppearSync) {
      removeSyncCheck = window.MotionCheckAppearSync(this, key2, value);
    }
    this.valueSubscriptions.set(key2, () => {
      removeOnChange();
      removeOnRenderRequest();
      if (removeSyncCheck)
        removeSyncCheck();
      if (value.owner)
        value.stop();
    });
  }
  sortNodePosition(other) {
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key2 = "animation";
    for (key2 in featureDefinitions) {
      const featureDefinition = featureDefinitions[key2];
      if (!featureDefinition)
        continue;
      const { isEnabled, Feature: FeatureConstructor } = featureDefinition;
      if (!this.features[key2] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key2] = new FeatureConstructor(this);
      }
      if (this.features[key2]) {
        const feature = this.features[key2];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key2) {
    return this.latestValues[key2];
  }
  setStaticValue(key2, value) {
    this.latestValues[key2] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    for (let i2 = 0; i2 < propEventHandlers.length; i2++) {
      const key2 = propEventHandlers[i2];
      if (this.propEventSubscriptions[key2]) {
        this.propEventSubscriptions[key2]();
        delete this.propEventSubscriptions[key2];
      }
      const listenerName = "on" + key2;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key2] = this.on(key2, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : void 0;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key2, value) {
    const existingValue = this.values.get(key2);
    if (value !== existingValue) {
      if (existingValue)
        this.removeValue(key2);
      this.bindToMotionValue(key2, value);
      this.values.set(key2, value);
      this.latestValues[key2] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key2) {
    this.values.delete(key2);
    const unsubscribe = this.valueSubscriptions.get(key2);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key2);
    }
    delete this.latestValues[key2];
    this.removeValueFromRenderState(key2, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key2) {
    return this.values.has(key2);
  }
  getValue(key2, defaultValue) {
    if (this.props.values && this.props.values[key2]) {
      return this.props.values[key2];
    }
    let value = this.values.get(key2);
    if (value === void 0 && defaultValue !== void 0) {
      value = motionValue(defaultValue === null ? void 0 : defaultValue, { owner: this });
      this.addValue(key2, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key2, target) {
    let value = this.latestValues[key2] !== void 0 || !this.current ? this.latestValues[key2] : this.getBaseTargetFromProps(this.props, key2) ?? this.readValueFromInstance(this.current, key2, this.options);
    if (value !== void 0 && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone2(key2, target);
      }
      this.setBaseTarget(key2, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key2, value) {
    this.baseTarget[key2] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key2) {
    var _a;
    const { initial } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) == null ? void 0 : _a.custom);
      if (variant) {
        valueFromInitial = variant[key2];
      }
    }
    if (initial && valueFromInitial !== void 0) {
      return valueFromInitial;
    }
    const target = this.getBaseTargetFromProps(this.props, key2);
    if (target !== void 0 && !isMotionValue(target))
      return target;
    return this.initialValues[key2] !== void 0 && valueFromInitial === void 0 ? void 0 : this.baseTarget[key2];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
};

// ../node_modules/framer-motion/dist/es/render/dom/DOMVisualElement.mjs
var DOMVisualElement = class extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a2, b2) {
    return a2.compareDocumentPosition(b2) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key2) {
    return props.style ? props.style[key2] : void 0;
  }
  removeValueFromRenderState(key2, { vars, style }) {
    delete vars[key2];
    delete style[key2];
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const { children } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", (latest) => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      });
    }
  }
};

// ../node_modules/framer-motion/dist/es/render/html/utils/render.mjs
function renderHTML(element, { style, vars }, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  for (const key2 in vars) {
    element.style.setProperty(key2, vars[key2]);
  }
}

// ../node_modules/framer-motion/dist/es/render/html/HTMLVisualElement.mjs
function getComputedStyle3(element) {
  return window.getComputedStyle(element);
}
var HTMLVisualElement = class extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key2) {
    var _a;
    if (transformProps.has(key2)) {
      return ((_a = this.projection) == null ? void 0 : _a.isProjecting) ? defaultTransformValue(key2) : readTransformValue(instance, key2);
    } else {
      const computedStyle = getComputedStyle3(instance);
      const value = (isCSSVariableName(key2) ? computedStyle.getPropertyValue(key2) : computedStyle[key2]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, { transformPagePoint }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
};

// ../node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength",
  "startOffset",
  "textLength",
  "lengthAdjust"
]);

// ../node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (const key2 in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key2) ? camelToDash(key2) : key2, renderState.attrs[key2]);
  }
}

// ../node_modules/framer-motion/dist/es/render/svg/SVGVisualElement.mjs
var SVGVisualElement = class extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props, key2) {
    return props[key2];
  }
  readValueFromInstance(instance, key2) {
    if (transformProps.has(key2)) {
      const defaultType = getDefaultValueType(key2);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key2 = !camelCaseAttributes.has(key2) ? camelToDash(key2) : key2;
    return instance.getAttribute(key2);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps2(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate, props.style);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
};

// ../node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
var createDomVisualElement = (Component4, options) => {
  return isSVGComponent(Component4) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
    allowProjection: Component4 !== import_react24.Fragment
  });
};

// ../node_modules/framer-motion/dist/es/render/components/motion/create.mjs
var createMotionComponent = createMotionComponentFactory({
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
}, createDomVisualElement);

// ../node_modules/framer-motion/dist/es/render/components/motion/proxy.mjs
var motion = createDOMMotionComponentProxy(createMotionComponent);

// ../node_modules/framer-motion/dist/es/components/LayoutGroup/index.mjs
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react28 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/context/DeprecatedLayoutGroupContext.mjs
var import_react25 = __toESM(require_react(), 1);
var DeprecatedLayoutGroupContext = (0, import_react25.createContext)(null);

// ../node_modules/framer-motion/dist/es/utils/use-force-update.mjs
var import_react27 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs
var import_react26 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/components/LazyMotion/index.mjs
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react29 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/components/MotionConfig/index.mjs
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/render/components/m/create.mjs
var createMinimalMotionComponent = createMotionComponentFactory();

// ../node_modules/framer-motion/dist/es/render/components/m/proxy.mjs
var m2 = createDOMMotionComponentProxy(createMinimalMotionComponent);

// ../node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs
var import_react31 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/render/dom/features-animation.mjs
var domAnimation = {
  renderer: createDomVisualElement,
  ...animations,
  ...gestureAnimations
};

// ../node_modules/framer-motion/dist/es/render/dom/features-max.mjs
var domMax = {
  ...domAnimation,
  ...drag,
  ...layout
};

// ../node_modules/framer-motion/dist/es/render/dom/features-min.mjs
var domMin = {
  renderer: createDomVisualElement,
  ...animations
};

// ../node_modules/framer-motion/dist/es/utils/use-motion-value-event.mjs
var import_react32 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/value/use-scroll.mjs
var import_react33 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/value/use-motion-value.mjs
var import_react34 = __toESM(require_react(), 1);
function useMotionValue(initial) {
  const value = useConstant(() => motionValue(initial));
  const { isStatic } = (0, import_react34.useContext)(MotionConfigContext);
  if (isStatic) {
    const [, setLatest] = (0, import_react34.useState)(initial);
    (0, import_react34.useEffect)(() => value.on("change", setLatest), []);
  }
  return value;
}

// ../node_modules/framer-motion/dist/es/value/use-combine-values.mjs
function useCombineMotionValues(values, combineValues) {
  const value = useMotionValue(combineValues());
  const updateValue = () => value.set(combineValues());
  updateValue();
  useIsomorphicLayoutEffect(() => {
    const scheduleUpdate = () => frame.preRender(updateValue, false, true);
    const subscriptions = values.map((v2) => v2.on("change", scheduleUpdate));
    return () => {
      subscriptions.forEach((unsubscribe) => unsubscribe());
      cancelFrame(updateValue);
    };
  });
  return value;
}

// ../node_modules/framer-motion/dist/es/value/use-spring.mjs
var import_react35 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/value/use-computed.mjs
function useComputed(compute) {
  collectMotionValues.current = [];
  compute();
  const value = useCombineMotionValues(collectMotionValues.current, compute);
  collectMotionValues.current = void 0;
  return value;
}

// ../node_modules/framer-motion/dist/es/value/use-transform.mjs
function useTransform(input, inputRangeOrTransformer, outputRange, options) {
  if (typeof input === "function") {
    return useComputed(input);
  }
  const transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);
  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));
}
function useListTransform(values, transformer) {
  const latest = useConstant(() => []);
  return useCombineMotionValues(values, () => {
    latest.length = 0;
    const numValues = values.length;
    for (let i2 = 0; i2 < numValues; i2++) {
      latest[i2] = values[i2].get();
    }
    return transformer(latest);
  });
}

// ../node_modules/framer-motion/dist/es/utils/use-animation-frame.mjs
var import_react36 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/utils/reduced-motion/use-reduced-motion.mjs
var import_react37 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/utils/reduced-motion/use-reduced-motion-config.mjs
var import_react38 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/animation/utils/is-dom-keyframes.mjs
function isDOMKeyframes(keyframes2) {
  return typeof keyframes2 === "object" && !Array.isArray(keyframes2);
}

// ../node_modules/framer-motion/dist/es/animation/animate/resolve-subjects.mjs
function resolveSubjects(subject, keyframes2, scope, selectorCache) {
  if (typeof subject === "string" && isDOMKeyframes(keyframes2)) {
    return resolveElements(subject, scope, selectorCache);
  } else if (subject instanceof NodeList) {
    return Array.from(subject);
  } else if (Array.isArray(subject)) {
    return subject;
  } else {
    return [subject];
  }
}

// ../node_modules/framer-motion/dist/es/animation/sequence/utils/calc-repeat-duration.mjs
function calculateRepeatDuration(duration, repeat, _repeatDelay) {
  return duration * (repeat + 1);
}

// ../node_modules/framer-motion/dist/es/animation/sequence/utils/calc-time.mjs
function calcNextTime(current, next2, prev2, labels) {
  if (typeof next2 === "number") {
    return next2;
  } else if (next2.startsWith("-") || next2.startsWith("+")) {
    return Math.max(0, current + parseFloat(next2));
  } else if (next2 === "<") {
    return prev2;
  } else {
    return labels.get(next2) ?? current;
  }
}

// ../node_modules/framer-motion/dist/es/animation/sequence/utils/edit.mjs
function eraseKeyframes(sequence, startTime, endTime) {
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const keyframe2 = sequence[i2];
    if (keyframe2.at > startTime && keyframe2.at < endTime) {
      removeItem(sequence, keyframe2);
      i2--;
    }
  }
}
function addKeyframes(sequence, keyframes2, easing, offset4, startTime, endTime) {
  eraseKeyframes(sequence, startTime, endTime);
  for (let i2 = 0; i2 < keyframes2.length; i2++) {
    sequence.push({
      value: keyframes2[i2],
      at: mixNumber(startTime, endTime, offset4[i2]),
      easing: getEasingForSegment(easing, i2)
    });
  }
}

// ../node_modules/framer-motion/dist/es/animation/sequence/utils/normalize-times.mjs
function normalizeTimes(times, repeat) {
  for (let i2 = 0; i2 < times.length; i2++) {
    times[i2] = times[i2] / (repeat + 1);
  }
}

// ../node_modules/framer-motion/dist/es/animation/sequence/utils/sort.mjs
function compareByTime(a2, b2) {
  if (a2.at === b2.at) {
    if (a2.value === null)
      return 1;
    if (b2.value === null)
      return -1;
    return 0;
  } else {
    return a2.at - b2.at;
  }
}

// ../node_modules/framer-motion/dist/es/animation/sequence/create.mjs
var defaultSegmentEasing = "easeInOut";
var MAX_REPEAT = 20;
function createAnimationsFromSequence(sequence, { defaultTransition = {}, ...sequenceTransition } = {}, scope, generators) {
  const defaultDuration = defaultTransition.duration || 0.3;
  const animationDefinitions = /* @__PURE__ */ new Map();
  const sequences = /* @__PURE__ */ new Map();
  const elementCache = {};
  const timeLabels = /* @__PURE__ */ new Map();
  let prevTime = 0;
  let currentTime = 0;
  let totalDuration = 0;
  for (let i2 = 0; i2 < sequence.length; i2++) {
    const segment = sequence[i2];
    if (typeof segment === "string") {
      timeLabels.set(segment, currentTime);
      continue;
    } else if (!Array.isArray(segment)) {
      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
      continue;
    }
    let [subject, keyframes2, transition = {}] = segment;
    if (transition.at !== void 0) {
      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);
    }
    let maxDuration = 0;
    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
      const valueKeyframesAsList = keyframesAsList(valueKeyframes);
      const { delay: delay2 = 0, times = defaultOffset(valueKeyframesAsList), type = "keyframes", repeat, repeatType, repeatDelay = 0, ...remainingTransition } = valueTransition;
      let { ease: ease2 = defaultTransition.ease || "easeOut", duration } = valueTransition;
      const calculatedDelay = typeof delay2 === "function" ? delay2(elementIndex, numSubjects) : delay2;
      const numKeyframes = valueKeyframesAsList.length;
      const createGenerator = isGenerator(type) ? type : generators == null ? void 0 : generators[type];
      if (numKeyframes <= 2 && createGenerator) {
        let absoluteDelta = 100;
        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
          absoluteDelta = Math.abs(delta);
        }
        const springTransition = { ...remainingTransition };
        if (duration !== void 0) {
          springTransition.duration = secondsToMilliseconds(duration);
        }
        const springEasing = createGeneratorEasing(springTransition, absoluteDelta, createGenerator);
        ease2 = springEasing.ease;
        duration = springEasing.duration;
      }
      duration ?? (duration = defaultDuration);
      const startTime = currentTime + calculatedDelay;
      if (times.length === 1 && times[0] === 0) {
        times[1] = 1;
      }
      const remainder = times.length - valueKeyframesAsList.length;
      remainder > 0 && fillOffset(times, remainder);
      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);
      if (repeat) {
        invariant(repeat < MAX_REPEAT, "Repeat count too high, must be less than 20");
        duration = calculateRepeatDuration(duration, repeat);
        const originalKeyframes = [...valueKeyframesAsList];
        const originalTimes = [...times];
        ease2 = Array.isArray(ease2) ? [...ease2] : [ease2];
        const originalEase = [...ease2];
        for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
          valueKeyframesAsList.push(...originalKeyframes);
          for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {
            times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));
            ease2.push(keyframeIndex === 0 ? "linear" : getEasingForSegment(originalEase, keyframeIndex - 1));
          }
        }
        normalizeTimes(times, repeat);
      }
      const targetTime = startTime + duration;
      addKeyframes(valueSequence, valueKeyframesAsList, ease2, times, startTime, targetTime);
      maxDuration = Math.max(calculatedDelay + duration, maxDuration);
      totalDuration = Math.max(targetTime, totalDuration);
    };
    if (isMotionValue(subject)) {
      const subjectSequence = getSubjectSequence(subject, sequences);
      resolveValueSequence(keyframes2, transition, getValueSequence("default", subjectSequence));
    } else {
      const subjects = resolveSubjects(subject, keyframes2, scope, elementCache);
      const numSubjects = subjects.length;
      for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {
        keyframes2 = keyframes2;
        transition = transition;
        const thisSubject = subjects[subjectIndex];
        const subjectSequence = getSubjectSequence(thisSubject, sequences);
        for (const key2 in keyframes2) {
          resolveValueSequence(keyframes2[key2], getValueTransition2(transition, key2), getValueSequence(key2, subjectSequence), subjectIndex, numSubjects);
        }
      }
    }
    prevTime = currentTime;
    currentTime += maxDuration;
  }
  sequences.forEach((valueSequences, element) => {
    for (const key2 in valueSequences) {
      const valueSequence = valueSequences[key2];
      valueSequence.sort(compareByTime);
      const keyframes2 = [];
      const valueOffset = [];
      const valueEasing = [];
      for (let i2 = 0; i2 < valueSequence.length; i2++) {
        const { at: at2, value, easing } = valueSequence[i2];
        keyframes2.push(value);
        valueOffset.push(progress(0, totalDuration, at2));
        valueEasing.push(easing || "easeOut");
      }
      if (valueOffset[0] !== 0) {
        valueOffset.unshift(0);
        keyframes2.unshift(keyframes2[0]);
        valueEasing.unshift(defaultSegmentEasing);
      }
      if (valueOffset[valueOffset.length - 1] !== 1) {
        valueOffset.push(1);
        keyframes2.push(null);
      }
      if (!animationDefinitions.has(element)) {
        animationDefinitions.set(element, {
          keyframes: {},
          transition: {}
        });
      }
      const definition = animationDefinitions.get(element);
      definition.keyframes[key2] = keyframes2;
      definition.transition[key2] = {
        ...defaultTransition,
        duration: totalDuration,
        ease: valueEasing,
        times: valueOffset,
        ...sequenceTransition
      };
    }
  });
  return animationDefinitions;
}
function getSubjectSequence(subject, sequences) {
  !sequences.has(subject) && sequences.set(subject, {});
  return sequences.get(subject);
}
function getValueSequence(name, sequences) {
  if (!sequences[name])
    sequences[name] = [];
  return sequences[name];
}
function keyframesAsList(keyframes2) {
  return Array.isArray(keyframes2) ? keyframes2 : [keyframes2];
}
function getValueTransition2(transition, key2) {
  return transition && transition[key2] ? {
    ...transition,
    ...transition[key2]
  } : { ...transition };
}
var isNumber = (keyframe2) => typeof keyframe2 === "number";
var isNumberKeyframesArray = (keyframes2) => keyframes2.every(isNumber);

// ../node_modules/framer-motion/dist/es/render/object/ObjectVisualElement.mjs
function isObjectKey(key2, object) {
  return key2 in object;
}
var ObjectVisualElement = class extends VisualElement {
  constructor() {
    super(...arguments);
    this.type = "object";
  }
  readValueFromInstance(instance, key2) {
    if (isObjectKey(key2, instance)) {
      const value = instance[key2];
      if (typeof value === "string" || typeof value === "number") {
        return value;
      }
    }
    return void 0;
  }
  getBaseTargetFromProps() {
    return void 0;
  }
  removeValueFromRenderState(key2, renderState) {
    delete renderState.output[key2];
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  build(renderState, latestValues) {
    Object.assign(renderState.output, latestValues);
  }
  renderInstance(instance, { output }) {
    Object.assign(instance, output);
  }
  sortInstanceNodePosition() {
    return 0;
  }
};

// ../node_modules/framer-motion/dist/es/animation/utils/create-visual-element.mjs
function createDOMVisualElement(element) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  };
  const node2 = isSVGElement(element) && !isSVGSVGElement(element) ? new SVGVisualElement(options) : new HTMLVisualElement(options);
  node2.mount(element);
  visualElementStore.set(element, node2);
}
function createObjectVisualElement(subject) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  };
  const node2 = new ObjectVisualElement(options);
  node2.mount(subject);
  visualElementStore.set(subject, node2);
}

// ../node_modules/framer-motion/dist/es/animation/animate/subject.mjs
function isSingleValue(subject, keyframes2) {
  return isMotionValue(subject) || typeof subject === "number" || typeof subject === "string" && !isDOMKeyframes(keyframes2);
}
function animateSubject(subject, keyframes2, options, scope) {
  const animations2 = [];
  if (isSingleValue(subject, keyframes2)) {
    animations2.push(animateSingleValue(subject, isDOMKeyframes(keyframes2) ? keyframes2.default || keyframes2 : keyframes2, options ? options.default || options : options));
  } else {
    const subjects = resolveSubjects(subject, keyframes2, scope);
    const numSubjects = subjects.length;
    invariant(Boolean(numSubjects), "No valid elements provided.");
    for (let i2 = 0; i2 < numSubjects; i2++) {
      const thisSubject = subjects[i2];
      const createVisualElement = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;
      if (!visualElementStore.has(thisSubject)) {
        createVisualElement(thisSubject);
      }
      const visualElement = visualElementStore.get(thisSubject);
      const transition = { ...options };
      if ("delay" in transition && typeof transition.delay === "function") {
        transition.delay = transition.delay(i2, numSubjects);
      }
      animations2.push(...animateTarget(visualElement, { ...keyframes2, transition }, {}));
    }
  }
  return animations2;
}

// ../node_modules/framer-motion/dist/es/animation/animate/sequence.mjs
function animateSequence(sequence, options, scope) {
  const animations2 = [];
  const animationDefinitions = createAnimationsFromSequence(sequence, options, scope, { spring });
  animationDefinitions.forEach(({ keyframes: keyframes2, transition }, subject) => {
    animations2.push(...animateSubject(subject, keyframes2, transition));
  });
  return animations2;
}

// ../node_modules/framer-motion/dist/es/animation/animate/index.mjs
function isSequence(value) {
  return Array.isArray(value) && value.some(Array.isArray);
}
function createScopedAnimate(scope) {
  function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {
    let animations2 = [];
    if (isSequence(subjectOrSequence)) {
      animations2 = animateSequence(subjectOrSequence, optionsOrKeyframes, scope);
    } else {
      animations2 = animateSubject(subjectOrSequence, optionsOrKeyframes, options, scope);
    }
    const animation2 = new GroupAnimationWithThen(animations2);
    if (scope) {
      scope.animations.push(animation2);
    }
    return animation2;
  }
  return scopedAnimate;
}
var animate = createScopedAnimate();

// ../node_modules/framer-motion/dist/es/animation/animators/waapi/animate-elements.mjs
function animateElements(elementOrSelector, keyframes2, options, scope) {
  const elements = resolveElements(elementOrSelector, scope);
  const numElements = elements.length;
  invariant(Boolean(numElements), "No valid element provided.");
  const animationDefinitions = [];
  for (let i2 = 0; i2 < numElements; i2++) {
    const element = elements[i2];
    const elementTransition = { ...options };
    if (typeof elementTransition.delay === "function") {
      elementTransition.delay = elementTransition.delay(i2, numElements);
    }
    for (const valueName in keyframes2) {
      let valueKeyframes = keyframes2[valueName];
      if (!Array.isArray(valueKeyframes)) {
        valueKeyframes = [valueKeyframes];
      }
      const valueOptions = {
        ...getValueTransition(elementTransition, valueName)
      };
      valueOptions.duration && (valueOptions.duration = secondsToMilliseconds(valueOptions.duration));
      valueOptions.delay && (valueOptions.delay = secondsToMilliseconds(valueOptions.delay));
      const map = getAnimationMap(element);
      const key2 = animationMapKey(valueName, valueOptions.pseudoElement || "");
      const currentAnimation = map.get(key2);
      currentAnimation && currentAnimation.stop();
      animationDefinitions.push({
        map,
        key: key2,
        unresolvedKeyframes: valueKeyframes,
        options: {
          ...valueOptions,
          element,
          name: valueName,
          allowFlatten: !elementTransition.type && !elementTransition.ease
        }
      });
    }
  }
  for (let i2 = 0; i2 < animationDefinitions.length; i2++) {
    const { unresolvedKeyframes, options: animationOptions } = animationDefinitions[i2];
    const { element, name, pseudoElement } = animationOptions;
    if (!pseudoElement && unresolvedKeyframes[0] === null) {
      unresolvedKeyframes[0] = getComputedStyle2(element, name);
    }
    fillWildcards(unresolvedKeyframes);
    applyPxDefaults(unresolvedKeyframes, name);
    if (!pseudoElement && unresolvedKeyframes.length < 2) {
      unresolvedKeyframes.unshift(getComputedStyle2(element, name));
    }
    animationOptions.keyframes = unresolvedKeyframes;
  }
  const animations2 = [];
  for (let i2 = 0; i2 < animationDefinitions.length; i2++) {
    const { map, key: key2, options: animationOptions } = animationDefinitions[i2];
    const animation2 = new NativeAnimation(animationOptions);
    map.set(key2, animation2);
    animation2.finished.finally(() => map.delete(key2));
    animations2.push(animation2);
  }
  return animations2;
}

// ../node_modules/framer-motion/dist/es/animation/animators/waapi/animate-style.mjs
var createScopedWaapiAnimate = (scope) => {
  function scopedAnimate(elementOrSelector, keyframes2, options) {
    return new GroupAnimationWithThen(animateElements(elementOrSelector, keyframes2, options, scope));
  }
  return scopedAnimate;
};
var animateMini = createScopedWaapiAnimate();

// ../node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence-data.mjs
var import_react39 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/events/use-dom-event.mjs
var import_react40 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/projection/use-reset-projection.mjs
var import_react41 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/utils/use-cycle.mjs
var import_react42 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/utils/use-in-view.mjs
var import_react43 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/utils/use-instant-transition.mjs
var import_react44 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/animation/hooks/use-animated-state.mjs
var import_react45 = __toESM(require_react(), 1);
var createObject = () => ({});
var useVisualState = makeUseVisualState({
  scrapeMotionValuesFromProps: createObject,
  createRenderState: createObject
});

// ../node_modules/framer-motion/dist/es/components/AnimateSharedLayout.mjs
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var React3 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/value/use-inverted-scale.mjs
var import_react46 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/components/Reorder/Group.mjs
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react48 = __toESM(require_react(), 1);

// ../node_modules/framer-motion/dist/es/context/ReorderContext.mjs
var import_react47 = __toESM(require_react(), 1);
var ReorderContext = (0, import_react47.createContext)(null);

// ../node_modules/framer-motion/dist/es/components/Reorder/utils/check-reorder.mjs
function checkReorder(order, value, offset4, velocity) {
  if (!velocity)
    return order;
  const index2 = order.findIndex((item2) => item2.value === value);
  if (index2 === -1)
    return order;
  const nextOffset = velocity > 0 ? 1 : -1;
  const nextItem = order[index2 + nextOffset];
  if (!nextItem)
    return order;
  const item = order[index2];
  const nextLayout = nextItem.layout;
  const nextItemCenter = mixNumber(nextLayout.min, nextLayout.max, 0.5);
  if (nextOffset === 1 && item.layout.max + offset4 > nextItemCenter || nextOffset === -1 && item.layout.min + offset4 < nextItemCenter) {
    return moveItem(order, index2, index2 + nextOffset);
  }
  return order;
}

// ../node_modules/framer-motion/dist/es/components/Reorder/Group.mjs
function ReorderGroupComponent({ children, as = "ul", axis = "y", onReorder, values, ...props }, externalRef) {
  const Component4 = useConstant(() => motion[as]);
  const order = [];
  const isReordering = (0, import_react48.useRef)(false);
  invariant(Boolean(values), "Reorder.Group must be provided a values prop");
  const context = {
    axis,
    registerItem: (value, layout2) => {
      const idx = order.findIndex((entry) => value === entry.value);
      if (idx !== -1) {
        order[idx].layout = layout2[axis];
      } else {
        order.push({ value, layout: layout2[axis] });
      }
      order.sort(compareMin);
    },
    updateOrder: (item, offset4, velocity) => {
      if (isReordering.current)
        return;
      const newOrder = checkReorder(order, item, offset4, velocity);
      if (order !== newOrder) {
        isReordering.current = true;
        onReorder(newOrder.map(getValue).filter((value) => values.indexOf(value) !== -1));
      }
    }
  };
  (0, import_react48.useEffect)(() => {
    isReordering.current = false;
  });
  return (0, import_jsx_runtime10.jsx)(Component4, { ...props, ref: externalRef, ignoreStrict: true, children: (0, import_jsx_runtime10.jsx)(ReorderContext.Provider, { value: context, children }) });
}
var ReorderGroup = (0, import_react48.forwardRef)(ReorderGroupComponent);
function getValue(item) {
  return item.value;
}
function compareMin(a2, b2) {
  return a2.layout.min - b2.layout.min;
}

// ../node_modules/framer-motion/dist/es/components/Reorder/Item.mjs
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react49 = __toESM(require_react(), 1);
function useDefaultMotionValue(value, defaultValue = 0) {
  return isMotionValue(value) ? value : useMotionValue(defaultValue);
}
function ReorderItemComponent({ children, style = {}, value, as = "li", onDrag, layout: layout2 = true, ...props }, externalRef) {
  const Component4 = useConstant(() => motion[as]);
  const context = (0, import_react49.useContext)(ReorderContext);
  const point = {
    x: useDefaultMotionValue(style.x),
    y: useDefaultMotionValue(style.y)
  };
  const zIndex = useTransform([point.x, point.y], ([latestX, latestY]) => latestX || latestY ? 1 : "unset");
  invariant(Boolean(context), "Reorder.Item must be a child of Reorder.Group");
  const { axis, registerItem, updateOrder } = context;
  return (0, import_jsx_runtime11.jsx)(Component4, { drag: axis, ...props, dragSnapToOrigin: true, style: { ...style, x: point.x, y: point.y, zIndex }, layout: layout2, onDrag: (event, gesturePoint) => {
    const { velocity } = gesturePoint;
    velocity[axis] && updateOrder(value, point[axis].get(), velocity[axis]);
    onDrag && onDrag(event, gesturePoint);
  }, onLayoutMeasure: (measured) => registerItem(value, measured), ref: externalRef, ignoreStrict: true, children });
}
var ReorderItem = (0, import_react49.forwardRef)(ReorderItemComponent);

// ../node_modules/@juggle/resize-observer/lib/utils/resizeObservers.js
var resizeObservers = [];

// ../node_modules/@juggle/resize-observer/lib/algorithms/hasActiveObservations.js
var hasActiveObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.activeTargets.length > 0;
  });
};

// ../node_modules/@juggle/resize-observer/lib/algorithms/hasSkippedObservations.js
var hasSkippedObservations = function() {
  return resizeObservers.some(function(ro) {
    return ro.skippedTargets.length > 0;
  });
};

// ../node_modules/@juggle/resize-observer/lib/algorithms/deliverResizeLoopError.js
var msg = "ResizeObserver loop completed with undelivered notifications.";
var deliverResizeLoopError = function() {
  var event;
  if (typeof ErrorEvent === "function") {
    event = new ErrorEvent("error", {
      message: msg
    });
  } else {
    event = document.createEvent("Event");
    event.initEvent("error", false, false);
    event.message = msg;
  }
  window.dispatchEvent(event);
};

// ../node_modules/@juggle/resize-observer/lib/ResizeObserverBoxOptions.js
var ResizeObserverBoxOptions;
(function(ResizeObserverBoxOptions2) {
  ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
  ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
  ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
})(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));

// ../node_modules/@juggle/resize-observer/lib/utils/freeze.js
var freeze = function(obj) {
  return Object.freeze(obj);
};

// ../node_modules/@juggle/resize-observer/lib/ResizeObserverSize.js
var ResizeObserverSize = /* @__PURE__ */ function() {
  function ResizeObserverSize2(inlineSize, blockSize) {
    this.inlineSize = inlineSize;
    this.blockSize = blockSize;
    freeze(this);
  }
  return ResizeObserverSize2;
}();

// ../node_modules/@juggle/resize-observer/lib/DOMRectReadOnly.js
var DOMRectReadOnly = function() {
  function DOMRectReadOnly2(x2, y2, width, height) {
    this.x = x2;
    this.y = y2;
    this.width = width;
    this.height = height;
    this.top = this.y;
    this.left = this.x;
    this.bottom = this.top + this.height;
    this.right = this.left + this.width;
    return freeze(this);
  }
  DOMRectReadOnly2.prototype.toJSON = function() {
    var _a = this, x2 = _a.x, y2 = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
    return { x: x2, y: y2, top, right, bottom, left, width, height };
  };
  DOMRectReadOnly2.fromRect = function(rectangle) {
    return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
  };
  return DOMRectReadOnly2;
}();

// ../node_modules/@juggle/resize-observer/lib/utils/element.js
var isSVG = function(target) {
  return target instanceof SVGElement && "getBBox" in target;
};
var isHidden = function(target) {
  if (isSVG(target)) {
    var _a = target.getBBox(), width = _a.width, height = _a.height;
    return !width && !height;
  }
  var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
  return !(offsetWidth || offsetHeight || target.getClientRects().length);
};
var isElement = function(obj) {
  var _a;
  if (obj instanceof Element) {
    return true;
  }
  var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
  return !!(scope && obj instanceof scope.Element);
};
var isReplacedElement = function(target) {
  switch (target.tagName) {
    case "INPUT":
      if (target.type !== "image") {
        break;
      }
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return true;
  }
  return false;
};

// ../node_modules/@juggle/resize-observer/lib/utils/global.js
var global2 = typeof window !== "undefined" ? window : {};

// ../node_modules/@juggle/resize-observer/lib/algorithms/calculateBoxSize.js
var cache2 = /* @__PURE__ */ new WeakMap();
var scrollRegexp = /auto|scroll/;
var verticalRegexp = /^tb|vertical/;
var IE = /msie|trident/i.test(global2.navigator && global2.navigator.userAgent);
var parseDimension = function(pixel) {
  return parseFloat(pixel || "0");
};
var size = function(inlineSize, blockSize, switchSizes) {
  if (inlineSize === void 0) {
    inlineSize = 0;
  }
  if (blockSize === void 0) {
    blockSize = 0;
  }
  if (switchSizes === void 0) {
    switchSizes = false;
  }
  return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
};
var zeroBoxes = freeze({
  devicePixelContentBoxSize: size(),
  borderBoxSize: size(),
  contentBoxSize: size(),
  contentRect: new DOMRectReadOnly(0, 0, 0, 0)
});
var calculateBoxSizes = function(target, forceRecalculation) {
  if (forceRecalculation === void 0) {
    forceRecalculation = false;
  }
  if (cache2.has(target) && !forceRecalculation) {
    return cache2.get(target);
  }
  if (isHidden(target)) {
    cache2.set(target, zeroBoxes);
    return zeroBoxes;
  }
  var cs = getComputedStyle(target);
  var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
  var removePadding = !IE && cs.boxSizing === "border-box";
  var switchSizes = verticalRegexp.test(cs.writingMode || "");
  var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
  var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
  var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
  var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
  var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
  var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
  var borderTop2 = svg ? 0 : parseDimension(cs.borderTopWidth);
  var borderRight2 = svg ? 0 : parseDimension(cs.borderRightWidth);
  var borderBottom2 = svg ? 0 : parseDimension(cs.borderBottomWidth);
  var borderLeft2 = svg ? 0 : parseDimension(cs.borderLeftWidth);
  var horizontalPadding = paddingLeft + paddingRight;
  var verticalPadding = paddingTop + paddingBottom;
  var horizontalBorderArea = borderLeft2 + borderRight2;
  var verticalBorderArea = borderTop2 + borderBottom2;
  var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
  var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
  var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
  var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
  var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
  var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
  var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
  var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
  var boxes = freeze({
    devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
    borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
    contentBoxSize: size(contentWidth, contentHeight, switchSizes),
    contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
  });
  cache2.set(target, boxes);
  return boxes;
};
var calculateBoxSize = function(target, observedBox, forceRecalculation) {
  var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
  switch (observedBox) {
    case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
      return devicePixelContentBoxSize;
    case ResizeObserverBoxOptions.BORDER_BOX:
      return borderBoxSize;
    default:
      return contentBoxSize;
  }
};

// ../node_modules/@juggle/resize-observer/lib/ResizeObserverEntry.js
var ResizeObserverEntry = /* @__PURE__ */ function() {
  function ResizeObserverEntry2(target) {
    var boxes = calculateBoxSizes(target);
    this.target = target;
    this.contentRect = boxes.contentRect;
    this.borderBoxSize = freeze([boxes.borderBoxSize]);
    this.contentBoxSize = freeze([boxes.contentBoxSize]);
    this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
  }
  return ResizeObserverEntry2;
}();

// ../node_modules/@juggle/resize-observer/lib/algorithms/calculateDepthForNode.js
var calculateDepthForNode = function(node2) {
  if (isHidden(node2)) {
    return Infinity;
  }
  var depth = 0;
  var parent = node2.parentNode;
  while (parent) {
    depth += 1;
    parent = parent.parentNode;
  }
  return depth;
};

// ../node_modules/@juggle/resize-observer/lib/algorithms/broadcastActiveObservations.js
var broadcastActiveObservations = function() {
  var shallowestDepth = Infinity;
  var callbacks2 = [];
  resizeObservers.forEach(function processObserver(ro) {
    if (ro.activeTargets.length === 0) {
      return;
    }
    var entries = [];
    ro.activeTargets.forEach(function processTarget(ot2) {
      var entry = new ResizeObserverEntry(ot2.target);
      var targetDepth = calculateDepthForNode(ot2.target);
      entries.push(entry);
      ot2.lastReportedSize = calculateBoxSize(ot2.target, ot2.observedBox);
      if (targetDepth < shallowestDepth) {
        shallowestDepth = targetDepth;
      }
    });
    callbacks2.push(function resizeObserverCallback() {
      ro.callback.call(ro.observer, entries, ro.observer);
    });
    ro.activeTargets.splice(0, ro.activeTargets.length);
  });
  for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
    var callback = callbacks_1[_i];
    callback();
  }
  return shallowestDepth;
};

// ../node_modules/@juggle/resize-observer/lib/algorithms/gatherActiveObservationsAtDepth.js
var gatherActiveObservationsAtDepth = function(depth) {
  resizeObservers.forEach(function processObserver(ro) {
    ro.activeTargets.splice(0, ro.activeTargets.length);
    ro.skippedTargets.splice(0, ro.skippedTargets.length);
    ro.observationTargets.forEach(function processTarget(ot2) {
      if (ot2.isActive()) {
        if (calculateDepthForNode(ot2.target) > depth) {
          ro.activeTargets.push(ot2);
        } else {
          ro.skippedTargets.push(ot2);
        }
      }
    });
  });
};

// ../node_modules/@juggle/resize-observer/lib/utils/process.js
var process2 = function() {
  var depth = 0;
  gatherActiveObservationsAtDepth(depth);
  while (hasActiveObservations()) {
    depth = broadcastActiveObservations();
    gatherActiveObservationsAtDepth(depth);
  }
  if (hasSkippedObservations()) {
    deliverResizeLoopError();
  }
  return depth > 0;
};

// ../node_modules/@juggle/resize-observer/lib/utils/queueMicroTask.js
var trigger;
var callbacks = [];
var notify = function() {
  return callbacks.splice(0).forEach(function(cb) {
    return cb();
  });
};
var queueMicroTask = function(callback) {
  if (!trigger) {
    var toggle_1 = 0;
    var el_1 = document.createTextNode("");
    var config = { characterData: true };
    new MutationObserver(function() {
      return notify();
    }).observe(el_1, config);
    trigger = function() {
      el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
    };
  }
  callbacks.push(callback);
  trigger();
};

// ../node_modules/@juggle/resize-observer/lib/utils/queueResizeObserver.js
var queueResizeObserver = function(cb) {
  queueMicroTask(function ResizeObserver3() {
    requestAnimationFrame(cb);
  });
};

// ../node_modules/@juggle/resize-observer/lib/utils/scheduler.js
var watching = 0;
var isWatching = function() {
  return !!watching;
};
var CATCH_PERIOD = 250;
var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
var events = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
];
var time2 = function(timeout) {
  if (timeout === void 0) {
    timeout = 0;
  }
  return Date.now() + timeout;
};
var scheduled = false;
var Scheduler = function() {
  function Scheduler2() {
    var _this = this;
    this.stopped = true;
    this.listener = function() {
      return _this.schedule();
    };
  }
  Scheduler2.prototype.run = function(timeout) {
    var _this = this;
    if (timeout === void 0) {
      timeout = CATCH_PERIOD;
    }
    if (scheduled) {
      return;
    }
    scheduled = true;
    var until = time2(timeout);
    queueResizeObserver(function() {
      var elementsHaveResized = false;
      try {
        elementsHaveResized = process2();
      } finally {
        scheduled = false;
        timeout = until - time2();
        if (!isWatching()) {
          return;
        }
        if (elementsHaveResized) {
          _this.run(1e3);
        } else if (timeout > 0) {
          _this.run(timeout);
        } else {
          _this.start();
        }
      }
    });
  };
  Scheduler2.prototype.schedule = function() {
    this.stop();
    this.run();
  };
  Scheduler2.prototype.observe = function() {
    var _this = this;
    var cb = function() {
      return _this.observer && _this.observer.observe(document.body, observerConfig);
    };
    document.body ? cb() : global2.addEventListener("DOMContentLoaded", cb);
  };
  Scheduler2.prototype.start = function() {
    var _this = this;
    if (this.stopped) {
      this.stopped = false;
      this.observer = new MutationObserver(this.listener);
      this.observe();
      events.forEach(function(name) {
        return global2.addEventListener(name, _this.listener, true);
      });
    }
  };
  Scheduler2.prototype.stop = function() {
    var _this = this;
    if (!this.stopped) {
      this.observer && this.observer.disconnect();
      events.forEach(function(name) {
        return global2.removeEventListener(name, _this.listener, true);
      });
      this.stopped = true;
    }
  };
  return Scheduler2;
}();
var scheduler = new Scheduler();
var updateCount = function(n) {
  !watching && n > 0 && scheduler.start();
  watching += n;
  !watching && scheduler.stop();
};

// ../node_modules/@juggle/resize-observer/lib/ResizeObservation.js
var skipNotifyOnElement = function(target) {
  return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
};
var ResizeObservation = function() {
  function ResizeObservation2(target, observedBox) {
    this.target = target;
    this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
    this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  ResizeObservation2.prototype.isActive = function() {
    var size5 = calculateBoxSize(this.target, this.observedBox, true);
    if (skipNotifyOnElement(this.target)) {
      this.lastReportedSize = size5;
    }
    if (this.lastReportedSize.inlineSize !== size5.inlineSize || this.lastReportedSize.blockSize !== size5.blockSize) {
      return true;
    }
    return false;
  };
  return ResizeObservation2;
}();

// ../node_modules/@juggle/resize-observer/lib/ResizeObserverDetail.js
var ResizeObserverDetail = /* @__PURE__ */ function() {
  function ResizeObserverDetail2(resizeObserver, callback) {
    this.activeTargets = [];
    this.skippedTargets = [];
    this.observationTargets = [];
    this.observer = resizeObserver;
    this.callback = callback;
  }
  return ResizeObserverDetail2;
}();

// ../node_modules/@juggle/resize-observer/lib/ResizeObserverController.js
var observerMap = /* @__PURE__ */ new WeakMap();
var getObservationIndex = function(observationTargets, target) {
  for (var i2 = 0; i2 < observationTargets.length; i2 += 1) {
    if (observationTargets[i2].target === target) {
      return i2;
    }
  }
  return -1;
};
var ResizeObserverController = function() {
  function ResizeObserverController2() {
  }
  ResizeObserverController2.connect = function(resizeObserver, callback) {
    var detail = new ResizeObserverDetail(resizeObserver, callback);
    observerMap.set(resizeObserver, detail);
  };
  ResizeObserverController2.observe = function(resizeObserver, target, options) {
    var detail = observerMap.get(resizeObserver);
    var firstObservation = detail.observationTargets.length === 0;
    if (getObservationIndex(detail.observationTargets, target) < 0) {
      firstObservation && resizeObservers.push(detail);
      detail.observationTargets.push(new ResizeObservation(target, options && options.box));
      updateCount(1);
      scheduler.schedule();
    }
  };
  ResizeObserverController2.unobserve = function(resizeObserver, target) {
    var detail = observerMap.get(resizeObserver);
    var index2 = getObservationIndex(detail.observationTargets, target);
    var lastObservation = detail.observationTargets.length === 1;
    if (index2 >= 0) {
      lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
      detail.observationTargets.splice(index2, 1);
      updateCount(-1);
    }
  };
  ResizeObserverController2.disconnect = function(resizeObserver) {
    var _this = this;
    var detail = observerMap.get(resizeObserver);
    detail.observationTargets.slice().forEach(function(ot2) {
      return _this.unobserve(resizeObserver, ot2.target);
    });
    detail.activeTargets.splice(0, detail.activeTargets.length);
  };
  return ResizeObserverController2;
}();

// ../node_modules/@juggle/resize-observer/lib/ResizeObserver.js
var ResizeObserver2 = function() {
  function ResizeObserver3(callback) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (typeof callback !== "function") {
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    }
    ResizeObserverController.connect(this, callback);
  }
  ResizeObserver3.prototype.observe = function(target, options) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.observe(this, target, options);
  };
  ResizeObserver3.prototype.unobserve = function(target) {
    if (arguments.length === 0) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    }
    if (!isElement(target)) {
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    }
    ResizeObserverController.unobserve(this, target);
  };
  ResizeObserver3.prototype.disconnect = function() {
    ResizeObserverController.disconnect(this);
  };
  ResizeObserver3.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  };
  return ResizeObserver3;
}();

// ../node_modules/use-effect-event/dist/index.js
var import_react50 = __toESM(require_react());
function useEffectEvent(fn) {
  const ref = (0, import_react50.useRef)(null);
  return (0, import_react50.useInsertionEffect)(() => {
    ref.current = fn;
  }, [fn]), (0, import_react50.useCallback)((...args) => {
    const latestFn = ref.current;
    return latestFn(...args);
  }, []);
}

// ../node_modules/@sanity/ui/dist/_chunks-es/_visual-editing.mjs
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react_compiler_runtime = __toESM(require_dist(), 1);
var import_react52 = __toESM(require_react(), 1);
var import_react_is = __toESM(require_react_is(), 1);

// ../node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round2 = Math.round;
var floor = Math.floor;
var createCoords = (v2) => ({
  x: v2,
  y: v2
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp3(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length2 = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length2] > rects.floating[length2]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}

// ../node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware2.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length2 = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length2] + rects.reference[axis] - coords[axis] - rects.floating[length2];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length2];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length2] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length2] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length2] / 2 + centerToReference;
    const offset4 = clamp3(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset4 && rects.reference[length2] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length2] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset4,
        centerOffset: center - offset4 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          var _overflowsData$;
          const ignoreCrossAxisOverflow = checkCrossAxis === "alignment" ? initialSideAxis !== getSideAxis(nextPlacement) : false;
          const hasInitialMainAxisOverflow = ((_overflowsData$ = overflowsData[0]) == null ? void 0 : _overflowsData$.overflows[0]) > 0;
          if (!ignoreCrossAxisOverflow || hasInitialMainAxisOverflow) {
            return {
              data: {
                index: nextIndex,
                overflows: overflowsData
              },
              reset: {
                placement: nextPlacement
              }
            };
          }
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
var hide = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp3(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp3(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};

// ../node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node2) {
  if (isNode(node2)) {
    return (node2.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node2) {
  var _node$ownerDocument;
  return (node2 == null || (_node$ownerDocument = node2.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node2) {
  var _ref;
  return (_ref = (isNode(node2) ? node2.ownerDocument : node2.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement2(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle4(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css2 = isElement2(elementOrCss) ? getComputedStyle4(elementOrCss) : elementOrCss;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((value) => css2[value] ? css2[value] !== "none" : false) || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node2) {
  return ["html", "body", "#document"].includes(getNodeName(node2));
}
function getComputedStyle4(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement2(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node2) {
  if (getNodeName(node2) === "html") {
    return node2;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node2.assignedSlot || // DOM Element detected.
    node2.parentNode || // ShadowRoot detected.
    isShadowRoot(node2) && node2.host || // Fallback.
    getDocumentElement(node2)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node2) {
  const parentNode = getParentNode(node2);
  if (isLastTraversableNode(parentNode)) {
    return node2.ownerDocument ? node2.ownerDocument.body : node2.body;
  }
  if (isHTMLElement2(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node2, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node2);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node2.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}

// ../node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css2 = getComputedStyle4(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement2(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round2(width) !== offsetWidth || round2(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement2(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement2(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x2 = ($2 ? round2(rect.width) : rect.width) / width;
  let y2 = ($2 ? round2(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale2 = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement2(offsetParent)) {
        scale2 = getScale(offsetParent);
      }
    } else {
      scale2 = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale2.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale2.y;
  let width = clientRect.width / scale2.x;
  let height = clientRect.height / scale2.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement2(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle4(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getHTMLOffset(documentElement, scroll2, ignoreScrollbarX) {
  if (ignoreScrollbarX === void 0) {
    ignoreScrollbarX = false;
  }
  const htmlRect = documentElement.getBoundingClientRect();
  const x2 = htmlRect.left + scroll2.scrollLeft - (ignoreScrollbarX ? 0 : (
    // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect)
  ));
  const y2 = htmlRect.top + scroll2.scrollTop;
  return {
    x: x2,
    y: y2
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale2 = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement2(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale2 = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll2, true) : createCoords(0);
  return {
    width: rect.width * scale2.x,
    height: rect.height * scale2.y,
    x: rect.x * scale2.x - scroll2.scrollLeft * scale2.x + offsets.x + htmlOffset.x,
    y: rect.y * scale2.y - scroll2.scrollTop * scale2.y + offsets.y + htmlOffset.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll2 = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll2.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll2.scrollTop;
  if (getComputedStyle4(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale2 = isHTMLElement2(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale2.x;
  const height = element.clientHeight * scale2.y;
  const x2 = left * scale2.x;
  const y2 = top * scale2.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement2(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y,
      width: clippingAncestor.width,
      height: clippingAncestor.height
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement2(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle4(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache3) {
  const cachedResult = cache3.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el) => isElement2(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle4(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement2(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle4(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache3.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement2(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll2 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  function setLeftRTLScrollbarOffset() {
    offsets.x = getWindowScrollBarX(documentElement);
  }
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll2 = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      setLeftRTLScrollbarOffset();
    }
  }
  if (isFixed && !isOffsetParentAnElement && documentElement) {
    setLeftRTLScrollbarOffset();
  }
  const htmlOffset = documentElement && !isOffsetParentAnElement && !isFixed ? getHTMLOffset(documentElement, scroll2) : createCoords(0);
  const x2 = rect.left + scroll2.scrollLeft - offsets.x - htmlOffset.x;
  const y2 = rect.top + scroll2.scrollTop - offsets.y - htmlOffset.y;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle4(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement2(element) || getComputedStyle4(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement2(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement2(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle4(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement: isElement2,
  isRTL
};
function rectsAreEqual(a2, b2) {
  return a2.x === b2.x && a2.y === b2.y && a2.width === b2.width && a2.height === b2.height;
}
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const elementRectForRootMargin = element.getBoundingClientRect();
    const {
      left,
      top,
      width,
      height
    } = elementRectForRootMargin;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      if (ratio === 1 && !rectsAreEqual(elementRectForRootMargin, element.getBoundingClientRect())) {
        refresh();
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (_e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && !rectsAreEqual(prevRefRect, nextRefRect)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var detectOverflow2 = detectOverflow;
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var hide2 = hide;
var arrow2 = arrow;
var computePosition2 = (reference, floating, options) => {
  const cache3 = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache3
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// ../node_modules/@floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React4 = __toESM(require_react(), 1);
var import_react51 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var index = typeof document !== "undefined" ? import_react51.useLayoutEffect : import_react51.useEffect;
function deepEqual(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length2;
  let i2;
  let keys;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length2 = a2.length;
      if (length2 !== b2.length) return false;
      for (i2 = length2; i2-- !== 0; ) {
        if (!deepEqual(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length2 = keys.length;
    if (length2 !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length2; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length2; i2-- !== 0; ) {
      const key2 = keys[i2];
      if (key2 === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual(a2[key2], b2[key2])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = React4.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware: middleware2 = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform: transform2 = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = React4.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = React4.useState(middleware2);
  if (!deepEqual(latestMiddleware, middleware2)) {
    setLatestMiddleware(middleware2);
  }
  const [_reference, _setReference] = React4.useState(null);
  const [_floating, _setFloating] = React4.useState(null);
  const setReference = React4.useCallback((node2) => {
    if (node2 !== referenceRef.current) {
      referenceRef.current = node2;
      _setReference(node2);
    }
  }, []);
  const setFloating = React4.useCallback((node2) => {
    if (node2 !== floatingRef.current) {
      floatingRef.current = node2;
      _setFloating(node2);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = React4.useRef(null);
  const floatingRef = React4.useRef(null);
  const dataRef = React4.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = React4.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = React4.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = React4.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = React4.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = React4.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform2) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform2, elements.floating, data.x, data.y]);
  return React4.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
var arrow$1 = (options) => {
  function isRef(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var offset3 = (options, deps) => ({
  ...offset2(options),
  options: [options, deps]
});
var shift3 = (options, deps) => ({
  ...shift2(options),
  options: [options, deps]
});
var flip3 = (options, deps) => ({
  ...flip2(options),
  options: [options, deps]
});
var hide3 = (options, deps) => ({
  ...hide2(options),
  options: [options, deps]
});
var arrow3 = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});

// ../node_modules/@sanity/ui/dist/_chunks-es/_visual-editing.mjs
var import_react_dom2 = __toESM(require_react_dom(), 1);
var rgba3 = rgba;
var studioTheme = buildTheme();
var EMPTY_ARRAY = [];
var EMPTY_RECORD = {};
var POPOVER_MOTION_PROPS = {
  card: {
    initial: {
      scale: 0.97,
      willChange: "transform"
    },
    hidden: {
      opacity: 0
    },
    visible: {
      opacity: 1,
      transition: {
        when: "beforeChildren",
        duration: 0.1
      }
    },
    scaleIn: {
      scale: 1
    },
    scaleOut: {
      scale: 0.97
    }
  },
  children: {
    hidden: {
      opacity: 0
    },
    visible: {
      opacity: 1
    }
  },
  transition: {
    type: "spring",
    visualDuration: 0.2,
    bounce: 0.25
  }
};
function _isEnterToClickElement(element) {
  return isHTMLAnchorElement(element) || isHTMLButtonElement(element);
}
function isHTMLElement3(node2) {
  return node2 instanceof Node && node2.nodeType === Node.ELEMENT_NODE;
}
function isHTMLAnchorElement(element) {
  return isHTMLElement3(element) && element.nodeName === "A";
}
function isHTMLInputElement(element) {
  return isHTMLElement3(element) && element.nodeName === "INPUT";
}
function isHTMLButtonElement(element) {
  return isHTMLElement3(element) && element.nodeName === "BUTTON";
}
function isHTMLSelectElement(element) {
  return isHTMLElement3(element) && element.nodeName === "SELECT";
}
function isHTMLTextAreaElement(element) {
  return isHTMLElement3(element) && element.nodeName === "TEXTAREA";
}
function containsOrEqualsElement(element, node2) {
  return element.contains(node2) || element === node2;
}
function _isScrollable(el) {
  if (!(el instanceof Element)) return false;
  const style = window.getComputedStyle(el);
  return style.overflowX.includes("auto") || style.overflowX.includes("scroll") || style.overflowY.includes("auto") || style.overflowY.includes("scroll");
}
function _fillCSSObject(keys, value) {
  return keys.reduce((style, key2) => (style[key2] = value, style), {});
}
function rem(pixelValue) {
  return pixelValue === 0 ? 0 : `${pixelValue / 16}rem`;
}
function _responsive(media, values, callback) {
  return ((values == null ? void 0 : values.map(callback)) || []).map((statement, mediaIndex) => mediaIndex === 0 ? statement : {
    [`@media screen and (min-width: ${media[mediaIndex - 1]}px)`]: statement
  });
}
function _getArrayProp(val, defaultVal) {
  return val === void 0 ? defaultVal || EMPTY_ARRAY : Array.isArray(val) ? val : [val];
}
function _getResponsiveSpace(theme, props, spaceIndexes = EMPTY_ARRAY) {
  if (!Array.isArray(spaceIndexes))
    throw new Error("the property must be array of numbers");
  if (spaceIndexes.length === 0)
    return null;
  const {
    media,
    space
  } = getTheme_v2(theme);
  return _responsive(media, spaceIndexes, (spaceIndex) => _fillCSSObject(props, rem(space[spaceIndex])));
}
function responsiveFont(fontKey, props) {
  const {
    $size,
    $weight
  } = props, {
    font,
    media
  } = getTheme_v2(props.theme), {
    family,
    sizes,
    weights
  } = font[fontKey], fontWeight = $weight && weights[$weight] || weights.regular, defaultSize = sizes[2], base = {
    position: "relative",
    fontFamily: family,
    fontWeight,
    padding: "1px 0",
    margin: 0,
    "&:before": {
      content: '""',
      display: "block",
      height: 0
    },
    "&:after": {
      content: '""',
      display: "block",
      height: 0
    },
    "& > code, & > span": {
      display: "block"
    },
    "&:not([hidden])": {
      display: "block"
    }
  };
  if (!$size)
    return responsiveFont.warned || (console.warn("No size specified for responsive font", {
      fontKey,
      $size,
      props,
      base
    }), responsiveFont.warned = true), [base];
  const resp = _responsive(media, $size, (sizeIndex) => fontSize(sizes[sizeIndex] || defaultSize));
  return [base, ...resp];
}
function fontSize(size22) {
  const {
    ascenderHeight,
    descenderHeight,
    fontSize: fontSize2,
    iconSize,
    letterSpacing,
    lineHeight
  } = size22, negHeight = ascenderHeight + descenderHeight, capHeight = lineHeight - negHeight, iconOffset = (capHeight - iconSize) / 2, customIconSize = Math.floor(fontSize2 * 1.125 / 2) * 2 + 1, customIconOffset = (capHeight - customIconSize) / 2;
  return {
    fontSize: rem(fontSize2),
    lineHeight: `calc(${lineHeight} / ${fontSize2})`,
    letterSpacing: rem(letterSpacing),
    transform: `translateY(${rem(descenderHeight)})`,
    "&:before": {
      marginTop: `calc(${rem(0 - negHeight)} - 1px)`
    },
    "&:after": {
      marginBottom: "-1px"
    },
    "& svg:not([data-sanity-icon])": {
      fontSize: `calc(${customIconSize} / 16 * 1rem)`,
      margin: rem(customIconOffset)
    },
    "& [data-sanity-icon]": {
      fontSize: `calc(${iconSize} / 16 * 1rem)`,
      margin: rem(iconOffset)
    }
  };
}
function responsiveCodeFontStyle(props) {
  return responsiveFont("code", props);
}
function responsiveHeadingFont(props) {
  return responsiveFont("heading", props);
}
function responsiveLabelFont(props) {
  return responsiveFont("label", props);
}
function responsiveTextAlignStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$align, (textAlign) => ({
    textAlign
  }));
}
function responsiveTextFont(props) {
  return responsiveFont("text", props);
}
function useArrayProp(val, defaultVal) {
  const $2 = (0, import_react_compiler_runtime.c)(3);
  let t0;
  $2[0] !== defaultVal || $2[1] !== val ? (t0 = () => [_getArrayProp(val, defaultVal), JSON.stringify(val ?? defaultVal)], $2[0] = defaultVal, $2[1] = val, $2[2] = t0) : t0 = $2[2];
  const [t1, setCache] = (0, import_react52.useState)(t0), [cachedVal, cachedHash] = t1, hash2 = JSON.stringify(val ?? defaultVal);
  return hash2 !== cachedHash && setCache([_getArrayProp(val, defaultVal), hash2]), cachedVal;
}
function useClickOutsideEvent(listener, t0, boundaryElement) {
  const $2 = (0, import_react_compiler_runtime.c)(9), elementsArg = t0 === void 0 ? _temp$9 : t0;
  let t1;
  $2[0] !== boundaryElement || $2[1] !== elementsArg || $2[2] !== listener ? (t1 = (evt) => {
    if (!listener)
      return;
    const target = evt.target;
    if (!(target instanceof Node))
      return;
    const resolvedBoundaryElement = boundaryElement == null ? void 0 : boundaryElement();
    if (resolvedBoundaryElement && !resolvedBoundaryElement.contains(target))
      return;
    const elements = elementsArg().flat();
    for (const el of elements)
      if (el && (target === el || el.contains(target)))
        return;
    listener(evt);
  }, $2[0] = boundaryElement, $2[1] = elementsArg, $2[2] = listener, $2[3] = t1) : t1 = $2[3];
  const onEvent = useEffectEvent(t1), hasListener = !!listener;
  let t2;
  $2[4] !== hasListener || $2[5] !== onEvent ? (t2 = () => {
    if (!hasListener)
      return;
    const handleEvent = (evt_0) => onEvent(evt_0);
    return document.addEventListener("mousedown", handleEvent), () => {
      document.removeEventListener("mousedown", handleEvent);
    };
  }, $2[4] = hasListener, $2[5] = onEvent, $2[6] = t2) : t2 = $2[6];
  let t3;
  $2[7] !== hasListener ? (t3 = [hasListener], $2[7] = hasListener, $2[8] = t3) : t3 = $2[8], (0, import_react52.useEffect)(t2, t3), (0, import_react52.useDebugValue)(listener ? "MouseDown On" : "MouseDown Off");
}
function _temp$9() {
  return EMPTY_ARRAY;
}
function useCustomValidity(ref, customValidity) {
  const $2 = (0, import_react_compiler_runtime.c)(6);
  let t0;
  $2[0] !== customValidity || $2[1] !== ref.current ? (t0 = () => {
    var _a;
    (_a = ref.current) == null ? void 0 : _a.setCustomValidity(customValidity || "");
  }, $2[0] = customValidity, $2[1] = ref.current, $2[2] = t0) : t0 = $2[2];
  let t1;
  $2[3] !== customValidity || $2[4] !== ref ? (t1 = [customValidity, ref], $2[3] = customValidity, $2[4] = ref, $2[5] = t1) : t1 = $2[5], (0, import_react52.useEffect)(t0, t1);
}
var _ResizeObserver = typeof document < "u" && typeof window < "u" && window.ResizeObserver ? window.ResizeObserver : ResizeObserver2;
var _elementSizeObserver = _createElementSizeObserver();
function _createElementRectValueListener() {
  return {
    subscribe(element, subscriber) {
      const resizeObserver = new _ResizeObserver(([entry]) => {
        subscriber({
          _contentRect: entry.contentRect,
          border: {
            width: entry.borderBoxSize[0].inlineSize,
            height: entry.borderBoxSize[0].blockSize
          },
          content: {
            width: entry.contentRect.width,
            height: entry.contentRect.height
          }
        });
      });
      return resizeObserver.observe(element), () => {
        resizeObserver.unobserve(element), resizeObserver.disconnect();
      };
    }
  };
}
function _createElementSizeObserver() {
  const disposeCache = /* @__PURE__ */ new WeakMap(), subscribersCache = /* @__PURE__ */ new WeakMap();
  return {
    subscribe(element, subscriber) {
      const subscribers = subscribersCache.get(element) || [];
      let dispose = disposeCache.get(element);
      return subscribersCache.has(element) || (subscribersCache.set(element, subscribers), dispose = _createElementRectValueListener().subscribe(element, (elementRect) => {
        for (const sub of subscribers)
          sub(elementRect);
      })), subscribers.push(subscriber), () => {
        const idx = subscribers.indexOf(subscriber);
        idx > -1 && subscribers.splice(idx, 1), subscribers.length === 0 && dispose && dispose();
      };
    }
  };
}
function useElementSize(element) {
  const $2 = (0, import_react_compiler_runtime.c)(3), [size22, setSize] = (0, import_react52.useState)(null);
  let t0, t1;
  return $2[0] !== element ? (t0 = () => {
    if (element)
      return _elementSizeObserver.subscribe(element, setSize);
  }, t1 = [element], $2[0] = element, $2[1] = t0, $2[2] = t1) : (t0 = $2[1], t1 = $2[2]), (0, import_react52.useEffect)(t0, t1), size22;
}
function useGlobalKeyDown(onKeyDown) {
  const $2 = (0, import_react_compiler_runtime.c)(5);
  let t0;
  $2[0] !== onKeyDown ? (t0 = (event) => onKeyDown(event), $2[0] = onKeyDown, $2[1] = t0) : t0 = $2[1];
  const handleKeyDown = useEffectEvent(t0);
  let t1;
  $2[2] !== handleKeyDown ? (t1 = () => {
    const handler = (event_0) => handleKeyDown(event_0);
    return window.addEventListener("keydown", handler), () => window.removeEventListener("keydown", handler);
  }, $2[2] = handleKeyDown, $2[3] = t1) : t1 = $2[3];
  let t2;
  $2[4] === Symbol.for("react.memo_cache_sentinel") ? (t2 = [], $2[4] = t2) : t2 = $2[4], (0, import_react52.useEffect)(t1, t2);
}
function useMatchMedia(mediaQueryString, getServerSnapshot2) {
  const $2 = (0, import_react_compiler_runtime.c)(4);
  (0, import_react52.useDebugValue)(mediaQueryString);
  let t0;
  $2[0] !== mediaQueryString ? (t0 = (onStoreChange) => {
    const media = window.matchMedia(mediaQueryString);
    return media.addEventListener("change", onStoreChange), () => media.removeEventListener("change", onStoreChange);
  }, $2[0] = mediaQueryString, $2[1] = t0) : t0 = $2[1];
  let t1;
  return $2[2] !== mediaQueryString ? (t1 = () => window.matchMedia(mediaQueryString).matches, $2[2] = mediaQueryString, $2[3] = t1) : t1 = $2[3], (0, import_react52.useSyncExternalStore)(t0, t1, getServerSnapshot2);
}
function getGlobalScope() {
  if (typeof globalThis < "u") return globalThis;
  if (typeof window < "u") return window;
  if (typeof self < "u") return self;
  if (typeof global < "u") return global;
  throw new Error("@sanity/ui: could not locate global scope");
}
var globalScope = getGlobalScope();
function createGlobalScopedContext(key2, defaultValue) {
  const symbol = Symbol.for(key2);
  return typeof document > "u" ? (0, import_react52.createContext)(defaultValue) : (globalScope[symbol] = globalScope[symbol] || (0, import_react52.createContext)(defaultValue), globalScope[symbol]);
}
var ThemeContext = createGlobalScopedContext("@sanity/ui/context/theme", null);
function ThemeProvider(props) {
  const $2 = (0, import_react_compiler_runtime.c)(15), parentTheme = (0, import_react52.useContext)(ThemeContext), {
    children
  } = props, scheme = props.scheme ?? ((parentTheme == null ? void 0 : parentTheme.scheme) || "light"), rootTheme = props.theme ?? ((parentTheme == null ? void 0 : parentTheme.theme) || null), tone = props.tone ?? ((parentTheme == null ? void 0 : parentTheme.tone) || "default");
  let t0;
  bb0: {
    if (!rootTheme) {
      t0 = null;
      break bb0;
    }
    let t12;
    $2[0] !== rootTheme || $2[1] !== scheme || $2[2] !== tone ? (t12 = {
      version: 0,
      theme: rootTheme,
      scheme,
      tone
    }, $2[0] = rootTheme, $2[1] = scheme, $2[2] = tone, $2[3] = t12) : t12 = $2[3], t0 = t12;
  }
  const themeContext = t0;
  let t1;
  bb1: {
    if (!rootTheme) {
      t1 = null;
      break bb1;
    }
    let t22;
    $2[4] !== rootTheme || $2[5] !== scheme || $2[6] !== tone ? (t22 = getScopedTheme(rootTheme, scheme, tone), $2[4] = rootTheme, $2[5] = scheme, $2[6] = tone, $2[7] = t22) : t22 = $2[7], t1 = t22;
  }
  const theme = t1;
  if (!theme) {
    let t22;
    return $2[8] === Symbol.for("react.memo_cache_sentinel") ? (t22 = (0, import_jsx_runtime12.jsx)("pre", { children: 'ThemeProvider: no "theme" property provided' }), $2[8] = t22) : t22 = $2[8], t22;
  }
  let t2;
  $2[9] !== children || $2[10] !== theme ? (t2 = (0, import_jsx_runtime12.jsx)(ot, { theme, children }), $2[9] = children, $2[10] = theme, $2[11] = t2) : t2 = $2[11];
  let t3;
  return $2[12] !== t2 || $2[13] !== themeContext ? (t3 = (0, import_jsx_runtime12.jsx)(ThemeContext.Provider, { value: themeContext, children: t2 }), $2[12] = t2, $2[13] = themeContext, $2[14] = t3) : t3 = $2[14], t3;
}
ThemeProvider.displayName = "ThemeProvider";
function useRootTheme() {
  const value = (0, import_react52.useContext)(ThemeContext);
  if (!value)
    throw new Error("useRootTheme(): missing context value");
  return value;
}
function ThemeColorProvider(props) {
  const $2 = (0, import_react_compiler_runtime.c)(5), {
    children,
    scheme,
    tone
  } = props, root = useRootTheme(), t0 = scheme || root.scheme;
  let t1;
  return $2[0] !== children || $2[1] !== root.theme || $2[2] !== t0 || $2[3] !== tone ? (t1 = (0, import_jsx_runtime12.jsx)(ThemeProvider, { scheme: t0, theme: root.theme, tone, children }), $2[0] = children, $2[1] = root.theme, $2[2] = t0, $2[3] = tone, $2[4] = t1) : t1 = $2[4], t1;
}
ThemeColorProvider.displayName = "ThemeColorProvider";
function useTheme() {
  return nt();
}
function useTheme_v2() {
  const $2 = (0, import_react_compiler_runtime.c)(2), t0 = nt();
  let t1;
  return $2[0] !== t0 ? (t1 = getTheme_v2(t0), $2[0] = t0, $2[1] = t1) : t1 = $2[1], t1;
}
function _getMediaQuery(media, index2) {
  return index2 === 0 ? `screen and (max-width: ${media[index2] - 1}px)` : index2 === media.length ? `screen and (min-width: ${media[index2 - 1]}px)` : `screen and (min-width: ${media[index2 - 1]}px) and (max-width: ${media[index2] - 1}px)`;
}
function _createMediaStore(media) {
  const mediaLen = media.length;
  let sizes;
  const getSizes = () => {
    if (!sizes) {
      sizes = [];
      for (let index2 = mediaLen; index2 > -1; index2 -= 1) {
        const mediaQuery = _getMediaQuery(media, index2);
        sizes.push({
          index: index2,
          mq: window.matchMedia(mediaQuery)
        });
      }
    }
    return sizes;
  };
  return {
    getSnapshot: () => {
      for (const {
        index: index2,
        mq
      } of getSizes())
        if (mq.matches) return index2;
      return 0;
    },
    subscribe: (onStoreChange) => {
      const disposeFns = [];
      for (const {
        mq
      } of getSizes()) {
        const handleChange = () => {
          mq.matches && onStoreChange();
        };
        mq.addEventListener("change", handleChange), disposeFns.push(() => mq.removeEventListener("change", handleChange));
      }
      return () => {
        for (const disposeFn of disposeFns)
          disposeFn();
      };
    }
  };
}
function getServerSnapshot() {
  return 0;
}
function useMediaIndex() {
  const $2 = (0, import_react_compiler_runtime.c)(2), {
    media
  } = useTheme_v2();
  let t0, t1;
  $2[0] !== media ? (t1 = _createMediaStore(media), $2[0] = media, $2[1] = t1) : t1 = $2[1], t0 = t1;
  const store = t0;
  return (0, import_react52.useSyncExternalStore)(store.subscribe, store.getSnapshot, getServerSnapshot);
}
function usePrefersDark(t0) {
  return useMatchMedia("(prefers-color-scheme: dark)", t0 === void 0 ? _temp$8 : t0);
}
function _temp$8() {
  return false;
}
function usePrefersReducedMotion(t0) {
  return useMatchMedia("(prefers-reduced-motion: reduce)", t0 === void 0 ? _temp$7 : t0);
}
function _temp$7() {
  return false;
}
function responsiveBorderStyle() {
  return [border, borderTop, borderRight, borderBottom, borderLeft];
}
function border(props) {
  var _a;
  const {
    card,
    media
  } = getTheme_v2(props.theme), borderStyle = `${((_a = card.border) == null ? void 0 : _a.width) ?? 1}px solid var(--card-border-color)`;
  return _responsive(media, props.$border, (value) => value ? {
    "&&": {
      border: borderStyle
    }
  } : {
    "&&": {
      border: 0
    }
  });
}
function borderTop(props) {
  var _a;
  const {
    card,
    media
  } = getTheme_v2(props.theme), borderStyle = `${((_a = card.border) == null ? void 0 : _a.width) ?? 1}px solid var(--card-border-color)`;
  return _responsive(media, props.$borderTop, (value) => value ? {
    "&&": {
      borderTop: borderStyle
    }
  } : {
    "&&": {
      borderTop: 0
    }
  });
}
function borderRight(props) {
  var _a;
  const {
    card,
    media
  } = getTheme_v2(props.theme), borderStyle = `${((_a = card.border) == null ? void 0 : _a.width) ?? 1}px solid var(--card-border-color)`;
  return _responsive(media, props.$borderRight, (value) => value ? {
    "&&": {
      borderRight: borderStyle
    }
  } : {
    "&&": {
      borderRight: 0
    }
  });
}
function borderBottom(props) {
  var _a;
  const {
    card,
    media
  } = getTheme_v2(props.theme), borderStyle = `${((_a = card.border) == null ? void 0 : _a.width) ?? 1}px solid var(--card-border-color)`;
  return _responsive(media, props.$borderBottom, (value) => value ? {
    "&&": {
      borderBottom: borderStyle
    }
  } : {
    "&&": {
      borderBottom: 0
    }
  });
}
function borderLeft(props) {
  var _a;
  const {
    card,
    media
  } = getTheme_v2(props.theme), borderStyle = `${((_a = card.border) == null ? void 0 : _a.width) ?? 1}px solid var(--card-border-color)`;
  return _responsive(media, props.$borderLeft, (value) => value ? {
    "&&": {
      borderLeft: borderStyle
    }
  } : {
    "&&": {
      borderLeft: 0
    }
  });
}
var BASE_STYLE$4 = {
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
var BOX_SIZING = {
  content: "content-box",
  border: "border-box"
};
var BOX_HEIGHT = {
  stretch: "stretch",
  fill: "100%"
};
function boxStyle() {
  return BASE_STYLE$4;
}
function responsiveBoxStyle() {
  return [responsiveBoxSizingStyle, responsiveBoxHeightStyle, responsiveBoxOverflowStyle, responsiveBoxDisplayStyle];
}
function responsiveBoxDisplayStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$display, (display) => ({
    "&:not([hidden])": {
      display
    }
  }));
}
function responsiveBoxSizingStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$sizing, (sizing) => ({
    boxSizing: BOX_SIZING[sizing]
  }));
}
function responsiveBoxHeightStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$height, (height) => ({
    height: BOX_HEIGHT[height]
  }));
}
function responsiveBoxOverflowStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$overflow, (overflow) => ({
    overflow
  }));
}
var BASE_STYLE$3 = {
  minWidth: 0,
  minHeight: 0
};
function flexItemStyle() {
  return [BASE_STYLE$3, responsiveFlexItemStyle];
}
function responsiveFlexItemStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return props.$flex ? _responsive(media, props.$flex, (flex) => ({
    flex
  })) : EMPTY_ARRAY;
}
var BASE_STYLE$2 = {
  "&&:not([hidden])": {
    display: "flex"
  }
};
function responsiveFlexStyle() {
  return [BASE_STYLE$2, responsiveFlexAlignStyle, responsiveFlexGapStyle, responsiveFlexWrapStyle, responsiveFlexJustifyStyle, responsiveFlexDirectionStyle];
}
function responsiveFlexAlignStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$align, (align) => ({
    alignItems: align
  }));
}
function responsiveFlexGapStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gap, (gap) => ({
    gap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveFlexWrapStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$wrap, (wrap2) => ({
    flexWrap: wrap2
  }));
}
function responsiveFlexJustifyStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$justify, (justify) => ({
    justifyContent: justify
  }));
}
function responsiveFlexDirectionStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$direction, (direction) => ({
    flexDirection: direction
  }));
}
function focusRingBorderStyle(border2) {
  return `inset 0 0 0 ${border2.width}px ${border2.color}`;
}
function focusRingStyle(opts) {
  const {
    base,
    border: border2,
    focusRing
  } = opts, focusRingOutsetWidth = focusRing.offset + focusRing.width, focusRingInsetWidth = 0 - focusRing.offset, bgColor = base ? base.bg : "var(--card-bg-color)";
  return [focusRingInsetWidth > 0 && `inset 0 0 0 ${focusRingInsetWidth}px var(--card-focus-ring-color)`, border2 && focusRingBorderStyle(border2), focusRingInsetWidth < 0 && `0 0 0 ${0 - focusRingInsetWidth}px ${bgColor}`, focusRingOutsetWidth > 0 && `0 0 0 ${focusRingOutsetWidth}px var(--card-focus-ring-color)`].filter(Boolean).join(",");
}
function responsiveGridItemStyle() {
  return [responsiveGridItemRowStyle, responsiveGridItemRowStartStyle, responsiveGridItemRowEndStyle, responsiveGridItemColumnStyle, responsiveGridItemColumnStartStyle, responsiveGridItemColumnEndStyle];
}
var GRID_ITEM_ROW = {
  auto: "auto",
  full: "1 / -1"
};
var GRID_ITEM_COLUMN = {
  auto: "auto",
  full: "1 / -1"
};
function responsiveGridItemRowStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$row, (row) => typeof row == "number" ? {
    gridRow: `span ${row} / span ${row}`
  } : {
    gridRow: GRID_ITEM_ROW[row]
  });
}
function responsiveGridItemRowStartStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$rowStart, (rowStart) => ({
    gridRowStart: rowStart
  }));
}
function responsiveGridItemRowEndStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$rowEnd, (rowEnd) => ({
    gridRowEnd: rowEnd
  }));
}
function responsiveGridItemColumnStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$column, (column2) => typeof column2 == "number" ? {
    gridColumn: `span ${column2} / span ${column2}`
  } : {
    gridColumn: GRID_ITEM_COLUMN[column2]
  });
}
function responsiveGridItemColumnStartStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$columnStart, (columnStart) => ({
    gridColumnStart: columnStart
  }));
}
function responsiveGridItemColumnEndStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$columnEnd, (columnEnd) => ({
    gridColumnEnd: columnEnd
  }));
}
var GRID_CSS = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  }
};
var GRID_AUTO_COLUMS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
var GRID_AUTO_ROWS = {
  auto: "auto",
  min: "min-content",
  max: "max-content",
  fr: "minmax(0, 1fr)"
};
function responsiveGridStyle() {
  return [GRID_CSS, responsiveGridAutoFlowStyle, responsiveGridAutoRowsStyle, responsiveGridAutoColsStyle, responsiveGridColumnsStyle, responsiveGridRowsStyle, responsiveGridGapStyle, responsiveGridGapXStyle, responsiveGridGapYStyle];
}
function responsiveGridAutoFlowStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoFlow, (autoFlow) => ({
    gridAutoFlow: autoFlow
  }));
}
function responsiveGridAutoRowsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoRows, (autoRows) => ({
    gridAutoRows: autoRows && GRID_AUTO_ROWS[autoRows]
  }));
}
function responsiveGridAutoColsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$autoCols, (autoCols) => ({
    gridAutoColumns: autoCols && GRID_AUTO_COLUMS[autoCols]
  }));
}
function responsiveGridColumnsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$columns, (columns) => ({
    gridTemplateColumns: columns && `repeat(${columns},minmax(0,1fr));`
  }));
}
function responsiveGridRowsStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$rows, (rows) => ({
    gridTemplateRows: rows && `repeat(${rows},minmax(0,1fr));`
  }));
}
function responsiveGridGapStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gap, (gap) => ({
    gridGap: gap ? rem(space[gap]) : void 0
  }));
}
function responsiveGridGapXStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gapX, (gapX) => ({
    columnGap: gapX ? rem(space[gapX]) : void 0
  }));
}
function responsiveGridGapYStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$gapY, (gapY) => ({
    rowGap: gapY ? rem(space[gapY]) : void 0
  }));
}
function responsiveInputPaddingStyle(props) {
  const {
    $fontSize,
    $iconLeft,
    $iconRight,
    $padding,
    $space
  } = props, {
    font,
    media,
    space
  } = getTheme_v2(props.theme), len = Math.max($padding.length, $space.length, $fontSize.length), _padding = [], _space = [], _fontSize = [];
  for (let i2 = 0; i2 < len; i2 += 1)
    _fontSize[i2] = $fontSize[i2] === void 0 ? _fontSize[i2 - 1] : $fontSize[i2], _padding[i2] = $padding[i2] === void 0 ? _padding[i2 - 1] : $padding[i2], _space[i2] = $space[i2] === void 0 ? _space[i2 - 1] : $space[i2];
  return _responsive(media, _padding, (_2, i2) => {
    const size22 = font.text.sizes[_fontSize[i2]] || font.text.sizes[2], emSize = size22.lineHeight - size22.ascenderHeight - size22.descenderHeight, p2 = space[_padding[i2]], s2 = space[_space[i2]], styles = {
      paddingTop: rem(p2 - size22.ascenderHeight),
      paddingRight: rem(p2),
      paddingBottom: rem(p2 - size22.descenderHeight),
      paddingLeft: rem(p2)
    };
    return $iconRight && (styles.paddingRight = rem(p2 + emSize + s2)), $iconLeft && (styles.paddingLeft = rem(p2 + emSize + s2)), styles;
  });
}
function responsiveInputPaddingIconRightStyle(props) {
  return responsiveInputPaddingStyle({
    ...props,
    $iconRight: true
  });
}
var ROOT_STYLE = lt`
  &:not([hidden]) {
    display: flex;
  }

  align-items: center;
`;
function textInputRootStyle() {
  return ROOT_STYLE;
}
function textInputBaseStyle(props) {
  const {
    $scheme,
    $tone,
    $weight
  } = props, {
    color: color3,
    font
  } = getTheme_v2(props.theme);
  return lt`
    appearance: none;
    background: none;
    border: 0;
    border-radius: 0;
    outline: none;
    width: 100%;
    box-sizing: border-box;
    font-family: ${font.text.family};
    font-weight: ${$weight && font.text.weights[$weight] || font.text.weights.regular};
    margin: 0;
    position: relative;
    z-index: 1;
    display: block;

    /* NOTE: This is a hack to disable Chrome’s autofill styles */
    &:-webkit-autofill,
    &:-webkit-autofill:hover,
    &:-webkit-autofill:focus,
    &:-webkit-autofill:active {
      -webkit-text-fill-color: var(--input-fg-color) !important;
      transition: background-color 5000s;
      transition-delay: 86400s /* 24h */;
    }

    /* &:is(textarea) */
    &[data-as='textarea'] {
      resize: none;
    }

    color: var(--input-fg-color);

    &::placeholder {
      color: var(--input-placeholder-color);
    }

    &[data-scheme='${$scheme}'][data-tone='${$tone}'] {
      --input-fg-color: ${color3.input.default.enabled.fg};
      --input-placeholder-color: ${color3.input.default.enabled.placeholder};

      /* enabled */
      &:not(:invalid):not(:disabled):not(:read-only) {
        --input-fg-color: ${color3.input.default.enabled.fg};
        --input-placeholder-color: ${color3.input.default.enabled.placeholder};
      }

      /* disabled */
      &:not(:invalid):disabled {
        --input-fg-color: ${color3.input.default.disabled.fg};
        --input-placeholder-color: ${color3.input.default.disabled.placeholder};
      }

      /* invalid */
      &:invalid {
        --input-fg-color: ${color3.input.invalid.enabled.fg};
        --input-placeholder-color: ${color3.input.invalid.enabled.placeholder};
      }

      /* readOnly */
      &:read-only {
        --input-fg-color: ${color3.input.default.readOnly.fg};
        --input-placeholder-color: ${color3.input.default.readOnly.placeholder};
      }
    }
  `;
}
function textInputFontSizeStyle(props) {
  const {
    font,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$fontSize, (sizeIndex) => {
    const size22 = font.text.sizes[sizeIndex] || font.text.sizes[2];
    return {
      fontSize: rem(size22.fontSize),
      lineHeight: size22.lineHeight / size22.fontSize
    };
  });
}
function textInputRepresentationStyle(props) {
  const {
    $hasPrefix,
    $hasSuffix,
    $scheme,
    $tone,
    $unstableDisableFocusRing
  } = props, {
    color: color3,
    input
  } = getTheme_v2(props.theme);
  return lt`
    --input-box-shadow: none;

    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    display: block;
    pointer-events: none;
    z-index: 0;

    background-color: var(--card-bg-color);
    box-shadow: var(--input-box-shadow);

    border-top-left-radius: ${$hasPrefix ? 0 : void 0};
    border-bottom-left-radius: ${$hasPrefix ? 0 : void 0};
    border-top-right-radius: ${$hasSuffix ? 0 : void 0};
    border-bottom-right-radius: ${$hasSuffix ? 0 : void 0};

    &[data-scheme='${$scheme}'][data-tone='${$tone}'] {
      --card-bg-color: ${color3.input.default.enabled.bg};
      --card-fg-color: ${color3.input.default.enabled.fg};

      /* enabled */
      *:not(:disabled) + &[data-border] {
        --input-box-shadow: ${focusRingBorderStyle({
    color: color3.input.default.enabled.border,
    width: input.border.width
  })};
      }

      /* invalid */
      *:not(:disabled):invalid + & {
        --card-bg-color: ${color3.input.invalid.enabled.bg};
        --card-fg-color: ${color3.input.invalid.enabled.fg};

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color3.input.invalid.enabled.border,
    width: input.border.width
  })};
        }
      }

      /* focused */
      *:not(:disabled):focus + & {
        &[data-border] {
          --input-box-shadow: ${$unstableDisableFocusRing ? void 0 : focusRingStyle({
    border: {
      color: color3.input.default.enabled.border,
      width: input.border.width
    },
    focusRing: input.text.focusRing
  })};
        }

        &:not([data-border]) {
          --input-box-shadow: ${$unstableDisableFocusRing ? void 0 : focusRingStyle({
    focusRing: input.text.focusRing
  })};
        }
      }

      /* disabled */
      *:not(:invalid):disabled + & {
        --card-bg-color: ${color3.input.default.disabled.bg} !important;
        --card-fg-color: ${color3.input.default.disabled.fg} !important;
        --card-icon-color: ${color3.input.default.disabled.fg} !important;

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color3.input.default.disabled.border,
    width: input.border.width
  })};
        }
      }

      *:invalid:disabled + & {
        --card-bg-color: ${color3.input.invalid.disabled.bg} !important;
        --card-fg-color: ${color3.input.invalid.disabled.fg} !important;
        --card-icon-color: ${color3.input.invalid.disabled.fg} !important;

        &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color3.input.invalid.disabled.border,
    width: input.border.width
  })};
        }
      }

      /* readOnly */
      *:not(:invalid):read-only + & {
        --card-bg-color: ${color3.input.default.readOnly.bg} !important;
        --card-fg-color: ${color3.input.default.readOnly.fg} !important;
      }

      *:invalid:read-only + & {
        --card-bg-color: ${color3.input.invalid.readOnly.bg} !important;
        --card-fg-color: ${color3.input.invalid.readOnly.fg} !important;
      }

      /* hovered */
      @media (hover: hover) {
        *:not(:disabled):not(:read-only):not(:invalid):hover + & {
          --card-bg-color: ${color3.input.default.hovered.bg};
          --card-fg-color: ${color3.input.default.hovered.fg};
        }

        *:invalid:not(:disabled):not(:read-only):hover + & {
          --card-bg-color: ${color3.input.invalid.hovered.bg};
          --card-fg-color: ${color3.input.invalid.hovered.fg};
        }

        *:not(:disabled):not(:read-only):not(:invalid):not(:focus):hover + &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color3.input.default.hovered.border,
    width: input.border.width
  })};
        }

        *:invalid:not(:disabled):not(:read-only):not(:focus):hover + &[data-border] {
          --input-box-shadow: ${focusRingBorderStyle({
    color: color3.input.invalid.hovered.border,
    width: input.border.width
  })};
        }
      }
    }
  `;
}
function responsiveMarginStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["margin"], props.$margin), _getResponsiveSpace(theme, ["marginLeft", "marginRight"], props.$marginX), _getResponsiveSpace(theme, ["marginTop", "marginBottom"], props.$marginY), _getResponsiveSpace(theme, ["marginTop"], props.$marginTop), _getResponsiveSpace(theme, ["marginRight"], props.$marginRight), _getResponsiveSpace(theme, ["marginBottom"], props.$marginBottom), _getResponsiveSpace(theme, ["marginLeft"], props.$marginLeft)].filter(Boolean);
}
function responsivePaddingStyle(props) {
  const {
    theme
  } = props;
  return [_getResponsiveSpace(theme, ["padding"], props.$padding), _getResponsiveSpace(theme, ["paddingLeft", "paddingRight"], props.$paddingX), _getResponsiveSpace(theme, ["paddingTop", "paddingBottom"], props.$paddingY), _getResponsiveSpace(theme, ["paddingTop"], props.$paddingTop), _getResponsiveSpace(theme, ["paddingRight"], props.$paddingRight), _getResponsiveSpace(theme, ["paddingBottom"], props.$paddingBottom), _getResponsiveSpace(theme, ["paddingLeft"], props.$paddingLeft)].filter(Boolean);
}
function responsiveRadiusStyle(props) {
  const {
    media,
    radius
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$radius, (value) => {
    let borderRadius = 0;
    return typeof value == "number" && (borderRadius = rem(radius[value])), value === "full" && (borderRadius = "9999px"), {
      borderRadius
    };
  });
}
function toBoxShadow(shadow, color3) {
  return `${shadow.map(rem).join(" ")} ${color3}`;
}
function shadowStyle(shadow, outlineWidth = 1) {
  if (!shadow) return EMPTY_RECORD;
  const outline = `0 0 0 ${rem(outlineWidth)} var(--card-shadow-outline-color)`, umbra = toBoxShadow(shadow.umbra, "var(--card-shadow-umbra-color)"), penumbra = toBoxShadow(shadow.penumbra, "var(--card-shadow-penumbra-color)"), ambient = toBoxShadow(shadow.ambient, "var(--card-shadow-ambient-color)");
  return {
    boxShadow: `${outline}, ${umbra}, ${penumbra}, ${ambient}`
  };
}
function responsiveShadowStyle(props) {
  const {
    card,
    media,
    shadow
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$shadow, (index2) => shadowStyle(shadow[index2], card.shadow.outline));
}
var SpanWithTextOverflow = dt.span.withConfig({
  displayName: "SpanWithTextOverflow",
  componentId: "sc-ol2i3b-0"
})`display:block;white-space:nowrap;text-overflow:ellipsis;overflow:hidden;overflow:clip;`;
function labelBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props, {
    font
  } = getTheme_v2(props.theme);
  return lt`
    text-transform: uppercase;

    ${$accent && lt`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && lt`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
var StyledLabel = dt.div.withConfig({
  displayName: "StyledLabel",
  componentId: "sc-1luap7z-0"
})(responsiveLabelFont, responsiveTextAlignStyle, labelBaseStyle);
var Label = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(22);
  let accent, align, childrenProp, restProps, t0, t1, textOverflow, weight;
  $2[0] !== props ? ({
    accent,
    align,
    children: childrenProp,
    muted: t0,
    size: t1,
    textOverflow,
    weight,
    ...restProps
  } = props, $2[0] = props, $2[1] = accent, $2[2] = align, $2[3] = childrenProp, $2[4] = restProps, $2[5] = t0, $2[6] = t1, $2[7] = textOverflow, $2[8] = weight) : (accent = $2[1], align = $2[2], childrenProp = $2[3], restProps = $2[4], t0 = $2[5], t1 = $2[6], textOverflow = $2[7], weight = $2[8]);
  const muted = t0 === void 0 ? false : t0, size22 = t1 === void 0 ? 2 : t1;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    let t22;
    $2[9] !== children ? (t22 = (0, import_jsx_runtime12.jsx)(SpanWithTextOverflow, { children }), $2[9] = children, $2[10] = t22) : t22 = $2[10], children = t22;
  } else {
    let t22;
    $2[11] !== children ? (t22 = (0, import_jsx_runtime12.jsx)("span", { children }), $2[11] = children, $2[12] = t22) : t22 = $2[12], children = t22;
  }
  const t2 = useArrayProp(align), t3 = useArrayProp(size22);
  let t4;
  return $2[13] !== accent || $2[14] !== children || $2[15] !== muted || $2[16] !== ref || $2[17] !== restProps || $2[18] !== t2 || $2[19] !== t3 || $2[20] !== weight ? (t4 = (0, import_jsx_runtime12.jsx)(StyledLabel, { "data-ui": "Label", ...restProps, $accent: accent, $align: t2, $muted: muted, $size: t3, $weight: weight, ref, children }), $2[13] = accent, $2[14] = children, $2[15] = muted, $2[16] = ref, $2[17] = restProps, $2[18] = t2, $2[19] = t3, $2[20] = weight, $2[21] = t4) : t4 = $2[21], t4;
});
Label.displayName = "ForwardRef(Label)";
var avatarStyle = {
  root: avatarRootStyle,
  arrow: avatarArrowStyle,
  bgStroke: avatarBgStrokeStyle,
  stroke: avatarStrokeStyle,
  initials: avatarInitialsStyle,
  image: avatarImageStyle
};
function avatarArrowStyle() {
  return {
    position: "absolute",
    boxSizing: "border-box",
    zIndex: 0,
    opacity: 0,
    transition: "all 0.2s linear",
    transform: "rotate(-90deg) translate3d(0, 6px, 0)",
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    "& > svg": {
      width: "11px",
      height: "7px",
      position: "absolute",
      top: "-5px",
      left: "50%",
      transform: "translateX(-6px)",
      "&:not([hidden])": {
        display: "block"
      }
    },
    "[data-arrow-position='inside'] > &": {
      transform: "rotate(-90deg) translate3d(0, 6px, 0)",
      opacity: 0
    },
    "[data-arrow-position='top'] > &": {
      opacity: 1,
      transform: "rotate(0deg)"
    },
    "[data-arrow-position='bottom'] > &": {
      opacity: 1,
      transform: "rotate(-180deg)"
    }
  };
}
function avatarRootStyle(props) {
  const {
    $color
  } = props, {
    avatar
  } = getTheme_v2(props.theme);
  return {
    "--avatar-bg-color": `var(--card-avatar-${$color}-bg-color)`,
    "--avatar-fg-color": `var(--card-avatar-${$color}-fg-color)`,
    backgroundColor: "var(--avatar-bg-color)",
    position: "relative",
    boxSizing: "border-box",
    userSelect: "none",
    boxShadow: "0 0 0 1px var(--card-bg-color)",
    '&[data-status="inactive"]': {
      opacity: 0.5
    },
    "&>svg": {
      "&:not([hidden])": {
        display: "block"
      }
    },
    /* &:is(button) */
    '&[data-as="button"]': {
      WebkitFontSmoothing: "inherit",
      appearance: "none",
      margin: 0,
      padding: 0,
      border: 0,
      font: "inherit",
      color: "inherit",
      outline: "none",
      "&:focus": {
        boxShadow: focusRingStyle({
          focusRing: avatar.focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: "none"
      }
    }
  };
}
function responsiveAvatarSizeStyle(props) {
  const {
    avatar,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size22) => {
    const avatarSize = avatar.sizes[size22] || avatar.sizes[0];
    return {
      width: rem(avatarSize.size),
      height: rem(avatarSize.size),
      borderRadius: rem(avatarSize.size / 2),
      "&>svg": {
        width: rem(avatarSize.size),
        height: rem(avatarSize.size),
        borderRadius: rem(avatarSize.size / 2)
      }
    };
  });
}
function avatarImageStyle() {
  return {
    position: "relative"
  };
}
function avatarInitialsStyle() {
  return {
    width: "100%",
    height: "100%",
    color: "var(--avatar-fg-color)",
    alignItems: "center",
    justifyContent: "center",
    textTransform: "uppercase",
    textAlign: "center",
    borderRadius: "50%",
    "&:not([hidden])": {
      display: "flex"
    }
  };
}
function avatarBgStrokeStyle() {
  return {
    strokeWidth: "4px",
    stroke: "var(--card-bg-color)"
  };
}
function avatarStrokeStyle() {
  return {
    strokeWidth: "2px",
    stroke: "var(--avatar-bg-color)",
    '[data-status="editing"] &': {
      strokeDasharray: "2 4",
      strokeLinecap: "round"
    }
  };
}
var StyledAvatar = dt.div.withConfig({
  displayName: "StyledAvatar",
  componentId: "sc-1rj7kl0-0"
})(responsiveAvatarSizeStyle, avatarStyle.root);
var Arrow$1 = dt.div.withConfig({
  displayName: "Arrow",
  componentId: "sc-1rj7kl0-1"
})(avatarStyle.arrow);
var BgStroke = dt.ellipse.withConfig({
  displayName: "BgStroke",
  componentId: "sc-1rj7kl0-2"
})(avatarStyle.bgStroke);
var Stroke = dt.ellipse.withConfig({
  displayName: "Stroke",
  componentId: "sc-1rj7kl0-3"
})(avatarStyle.stroke);
var Initials = dt.div.withConfig({
  displayName: "Initials",
  componentId: "sc-1rj7kl0-4"
})(avatarStyle.initials);
var InitialsLabel = dt(Label).withConfig({
  displayName: "InitialsLabel",
  componentId: "sc-1rj7kl0-5"
})({
  color: "inherit"
});
var AvatarImage = dt.svg.withConfig({
  displayName: "AvatarImage",
  componentId: "sc-1rj7kl0-6"
})(avatarStyle.image);
var Avatar = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(52);
  let __unstable_hideInnerStroke, animateArrowFrom, arrowPositionProp, asProp, initials, onImageLoadError, restProps, src, t0, t1, t2, title;
  $2[0] !== props ? ({
    __unstable_hideInnerStroke,
    as: asProp,
    color: t0,
    src,
    title,
    initials,
    onImageLoadError,
    arrowPosition: arrowPositionProp,
    animateArrowFrom,
    status: t1,
    size: t2,
    ...restProps
  } = props, $2[0] = props, $2[1] = __unstable_hideInnerStroke, $2[2] = animateArrowFrom, $2[3] = arrowPositionProp, $2[4] = asProp, $2[5] = initials, $2[6] = onImageLoadError, $2[7] = restProps, $2[8] = src, $2[9] = t0, $2[10] = t1, $2[11] = t2, $2[12] = title) : (__unstable_hideInnerStroke = $2[1], animateArrowFrom = $2[2], arrowPositionProp = $2[3], asProp = $2[4], initials = $2[5], onImageLoadError = $2[6], restProps = $2[7], src = $2[8], t0 = $2[9], t1 = $2[10], t2 = $2[11], title = $2[12]);
  const color3 = t0 === void 0 ? "gray" : t0, status = t1 === void 0 ? "online" : t1, sizeProp = t2 === void 0 ? 1 : t2, {
    avatar
  } = useTheme_v2(), as = import_react_is.default.isValidElementType(asProp) ? asProp : "div", size22 = useArrayProp(sizeProp), _sizeRem = (avatar.sizes[size22[0]] || avatar.sizes[0]).size, _radius = _sizeRem / 2, elementId = (0, import_react52.useId)(), [arrowPosition, setArrowPosition] = (0, import_react52.useState)(animateArrowFrom || arrowPositionProp || "inside"), [imageFailed, setImageFailed] = (0, import_react52.useState)(false), imageId = `avatar-image-${elementId}`;
  let t3, t4;
  $2[13] !== arrowPosition || $2[14] !== arrowPositionProp ? (t3 = () => {
    if (arrowPosition === arrowPositionProp)
      return;
    const raf = requestAnimationFrame(() => setArrowPosition(arrowPositionProp));
    return () => cancelAnimationFrame(raf);
  }, t4 = [arrowPosition, arrowPositionProp], $2[13] = arrowPosition, $2[14] = arrowPositionProp, $2[15] = t3, $2[16] = t4) : (t3 = $2[15], t4 = $2[16]), (0, import_react52.useEffect)(t3, t4);
  let t5, t6;
  $2[17] !== src ? (t5 = () => {
    src && setImageFailed(false);
  }, t6 = [src], $2[17] = src, $2[18] = t5, $2[19] = t6) : (t5 = $2[18], t6 = $2[19]), (0, import_react52.useEffect)(t5, t6);
  let t7;
  $2[20] !== onImageLoadError ? (t7 = () => {
    setImageFailed(true), onImageLoadError && onImageLoadError(new Error("Avatar: the image failed to load"));
  }, $2[20] = onImageLoadError, $2[21] = t7) : t7 = $2[21];
  const handleImageError = t7;
  let t8, t9;
  $2[22] !== size22 ? (t9 = size22.map(_temp$6), $2[22] = size22, $2[23] = t9) : t9 = $2[23], t8 = t9;
  const initialsSize = t8, t10 = typeof as == "string" ? as : void 0;
  let t11;
  $2[24] !== color3 ? (t11 = (0, import_jsx_runtime12.jsx)(Arrow$1, { children: (0, import_jsx_runtime12.jsx)("svg", { width: "11", height: "7", viewBox: "0 0 11 7", fill: "none", children: (0, import_jsx_runtime12.jsx)("path", { d: "M6.67948 1.50115L11 7L0 7L4.32052 1.50115C4.92109 0.736796 6.07891 0.736795 6.67948 1.50115Z", fill: color3 }) }) }), $2[24] = color3, $2[25] = t11) : t11 = $2[25];
  let t12;
  $2[26] !== __unstable_hideInnerStroke || $2[27] !== _radius || $2[28] !== _sizeRem || $2[29] !== handleImageError || $2[30] !== imageFailed || $2[31] !== imageId || $2[32] !== src ? (t12 = !imageFailed && src && (0, import_jsx_runtime12.jsxs)(AvatarImage, { viewBox: `0 0 ${_sizeRem} ${_sizeRem}`, fill: "none", children: [
    (0, import_jsx_runtime12.jsx)("defs", { children: (0, import_jsx_runtime12.jsx)("pattern", { id: imageId, patternContentUnits: "objectBoundingBox", width: "1", height: "1", children: (0, import_jsx_runtime12.jsx)("image", { href: src, width: "1", height: "1", onError: handleImageError }) }) }),
    (0, import_jsx_runtime12.jsx)("circle", { cx: _radius, cy: _radius, r: _radius, fill: `url(#${imageId})` }),
    !__unstable_hideInnerStroke && (0, import_jsx_runtime12.jsx)(BgStroke, { cx: _radius, cy: _radius, rx: _radius, ry: _radius, vectorEffect: "non-scaling-stroke" }),
    (0, import_jsx_runtime12.jsx)(Stroke, { cx: _radius, cy: _radius, rx: _radius, ry: _radius, vectorEffect: "non-scaling-stroke" })
  ] }), $2[26] = __unstable_hideInnerStroke, $2[27] = _radius, $2[28] = _sizeRem, $2[29] = handleImageError, $2[30] = imageFailed, $2[31] = imageId, $2[32] = src, $2[33] = t12) : t12 = $2[33];
  let t13;
  $2[34] !== imageFailed || $2[35] !== initials || $2[36] !== initialsSize || $2[37] !== src ? (t13 = (imageFailed || !src) && initials && (0, import_jsx_runtime12.jsx)(import_jsx_runtime12.Fragment, { children: (0, import_jsx_runtime12.jsx)(Initials, { children: (0, import_jsx_runtime12.jsx)(InitialsLabel, { forwardedAs: "span", size: initialsSize, weight: "medium", children: initials }) }) }), $2[34] = imageFailed, $2[35] = initials, $2[36] = initialsSize, $2[37] = src, $2[38] = t13) : t13 = $2[38];
  let t14;
  return $2[39] !== arrowPosition || $2[40] !== as || $2[41] !== color3 || $2[42] !== ref || $2[43] !== restProps || $2[44] !== size22 || $2[45] !== status || $2[46] !== t10 || $2[47] !== t11 || $2[48] !== t12 || $2[49] !== t13 || $2[50] !== title ? (t14 = (0, import_jsx_runtime12.jsxs)(StyledAvatar, { as, "data-as": t10, "data-ui": "Avatar", ...restProps, $color: color3, $size: size22, "aria-label": title, "data-arrow-position": arrowPosition, "data-status": status, ref, title, children: [
    t11,
    t12,
    t13
  ] }), $2[39] = arrowPosition, $2[40] = as, $2[41] = color3, $2[42] = ref, $2[43] = restProps, $2[44] = size22, $2[45] = status, $2[46] = t10, $2[47] = t11, $2[48] = t12, $2[49] = t13, $2[50] = title, $2[51] = t14) : t14 = $2[51], t14;
});
Avatar.displayName = "ForwardRef(Avatar)";
function _temp$6(s2) {
  return s2 === 1 ? 1 : s2 === 2 ? 3 : s2 === 3 ? 5 : 0;
}
function _responsiveAvatarCounterSizeStyle(props) {
  const {
    avatar,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size22) => {
    const avatarSize = avatar.sizes[size22];
    return avatarSize ? {
      borderRadius: rem(avatarSize.size / 2),
      minWidth: rem(avatarSize.size),
      height: rem(avatarSize.size)
    } : EMPTY_RECORD;
  });
}
function _avatarCounterBaseStyle(props) {
  const {
    space
  } = getTheme_v2(props.theme);
  return lt`
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    user-select: none;
    color: inherit;
    color: var(--card-fg-color);
    background: var(--card-bg-color);
    box-shadow:
      0 0 0 1px var(--card-bg-color),
      inset 0 0 0 1px var(--card-hairline-hard-color);
    padding: 0 ${rem(space[2])};

    &:not([hidden]) {
      display: flex;
    }
  `;
}
var StyledAvatarCounter = dt.div.withConfig({
  displayName: "StyledAvatarCounter",
  componentId: "sc-1ydx86y-0"
})(_responsiveAvatarCounterSizeStyle, _avatarCounterBaseStyle);
var AvatarCounter = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(9), {
    count,
    size: t0
  } = props, size22 = useArrayProp(t0 === void 0 ? 1 : t0);
  let t1, t2;
  $2[0] !== size22 ? (t2 = size22.map(_temp$5), $2[0] = size22, $2[1] = t2) : t2 = $2[1], t1 = t2;
  const fontSize2 = t1;
  let t3;
  $2[2] !== count || $2[3] !== fontSize2 ? (t3 = (0, import_jsx_runtime12.jsx)(Label, { as: "span", size: fontSize2, weight: "medium", children: count }), $2[2] = count, $2[3] = fontSize2, $2[4] = t3) : t3 = $2[4];
  let t4;
  return $2[5] !== ref || $2[6] !== size22 || $2[7] !== t3 ? (t4 = (0, import_jsx_runtime12.jsx)(StyledAvatarCounter, { $size: size22, "data-ui": "AvatarCounter", ref, children: t3 }), $2[5] = ref, $2[6] = size22, $2[7] = t3, $2[8] = t4) : t4 = $2[8], t4;
});
AvatarCounter.displayName = "ForwardRef(AvatarCounter)";
function _temp$5(s2) {
  return s2 === 1 ? 1 : s2 === 2 ? 3 : s2 === 3 ? 5 : 0;
}
var BASE_STYLES = lt`
  white-space: nowrap;

  & > div {
    vertical-align: top;

    &:not([hidden]) {
      display: inline-block;
    }
  }
`;
function avatarStackStyle() {
  return BASE_STYLES;
}
function responsiveAvatarStackSizeStyle(props) {
  const {
    avatar,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$size, (size22) => {
    const avatarSize = avatar.sizes[size22];
    return avatarSize ? {
      "& > div + div": {
        marginLeft: rem(avatarSize.distance)
      }
    } : EMPTY_RECORD;
  });
}
var StyledAvatarStack = dt.div.withConfig({
  displayName: "StyledAvatarStack",
  componentId: "sc-cysmbb-0"
})(responsiveAvatarStackSizeStyle, avatarStackStyle);
var AvatarStack = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(15);
  let childrenProp, restProps, t0, t1;
  $2[0] !== props ? ({
    children: childrenProp,
    maxLength: t0,
    size: t1,
    ...restProps
  } = props, $2[0] = props, $2[1] = childrenProp, $2[2] = restProps, $2[3] = t0, $2[4] = t1) : (childrenProp = $2[1], restProps = $2[2], t0 = $2[3], t1 = $2[4]);
  const maxLengthProp = t0 === void 0 ? 4 : t0, sizeProp = t1 === void 0 ? 1 : t1, children = import_react52.Children.toArray(childrenProp).filter(import_react52.isValidElement), maxLength = Math.max(maxLengthProp, 0), size22 = useArrayProp(sizeProp), len = children.length, visibleCount = maxLength - 1, extraCount = len - visibleCount, visibleChildren = extraCount > 1 ? children.slice(extraCount, len) : children, T0 = StyledAvatarStack, t2 = "AvatarStack", t3 = len === 0 && (0, import_jsx_runtime12.jsx)("div", { children: (0, import_jsx_runtime12.jsx)(AvatarCounter, { count: len, size: size22 }) }), t4 = len !== 0 && extraCount > 1 && (0, import_jsx_runtime12.jsx)("div", { children: (0, import_jsx_runtime12.jsx)(AvatarCounter, { count: extraCount, size: size22 }) });
  let t5;
  $2[5] !== size22 ? (t5 = (child, childIndex) => (0, import_jsx_runtime12.jsx)("div", { children: (0, import_react52.cloneElement)(child, {
    size: size22
  }) }, String(childIndex)), $2[5] = size22, $2[6] = t5) : t5 = $2[6];
  const t6 = visibleChildren.map(t5);
  let t7;
  return $2[7] !== T0 || $2[8] !== ref || $2[9] !== restProps || $2[10] !== size22 || $2[11] !== t3 || $2[12] !== t4 || $2[13] !== t6 ? (t7 = (0, import_jsx_runtime12.jsxs)(T0, { "data-ui": t2, ...restProps, ref, $size: size22, children: [
    t3,
    t4,
    t6
  ] }), $2[7] = T0, $2[8] = ref, $2[9] = restProps, $2[10] = size22, $2[11] = t3, $2[12] = t4, $2[13] = t6, $2[14] = t7) : t7 = $2[14], t7;
});
AvatarStack.displayName = "ForwardRef(AvatarStack)";
var StyledBox = dt.div.withConfig({
  displayName: "StyledBox",
  componentId: "sc-1hhky9f-0"
})(boxStyle, flexItemStyle, responsiveBoxStyle, responsiveGridItemStyle, responsiveMarginStyle, responsivePaddingStyle);
var Box = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(59);
  let column2, columnEnd, columnStart, flex, height, marginBottom, marginLeft, marginRight, marginTop, marginX, marginY, overflow, paddingBottom, paddingLeft, paddingRight, paddingTop, paddingX, paddingY, restProps, row, rowEnd, rowStart, sizing, t0, t1, t2, t3;
  $2[0] !== props ? ({
    as: t0,
    column: column2,
    columnStart,
    columnEnd,
    display: t1,
    flex,
    height,
    margin: t2,
    marginX,
    marginY,
    marginTop,
    marginRight,
    marginBottom,
    marginLeft,
    overflow,
    padding: t3,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    row,
    rowStart,
    rowEnd,
    sizing,
    ...restProps
  } = props, $2[0] = props, $2[1] = column2, $2[2] = columnEnd, $2[3] = columnStart, $2[4] = flex, $2[5] = height, $2[6] = marginBottom, $2[7] = marginLeft, $2[8] = marginRight, $2[9] = marginTop, $2[10] = marginX, $2[11] = marginY, $2[12] = overflow, $2[13] = paddingBottom, $2[14] = paddingLeft, $2[15] = paddingRight, $2[16] = paddingTop, $2[17] = paddingX, $2[18] = paddingY, $2[19] = restProps, $2[20] = row, $2[21] = rowEnd, $2[22] = rowStart, $2[23] = sizing, $2[24] = t0, $2[25] = t1, $2[26] = t2, $2[27] = t3) : (column2 = $2[1], columnEnd = $2[2], columnStart = $2[3], flex = $2[4], height = $2[5], marginBottom = $2[6], marginLeft = $2[7], marginRight = $2[8], marginTop = $2[9], marginX = $2[10], marginY = $2[11], overflow = $2[12], paddingBottom = $2[13], paddingLeft = $2[14], paddingRight = $2[15], paddingTop = $2[16], paddingX = $2[17], paddingY = $2[18], restProps = $2[19], row = $2[20], rowEnd = $2[21], rowStart = $2[22], sizing = $2[23], t0 = $2[24], t1 = $2[25], t2 = $2[26], t3 = $2[27]);
  const asProp = t0 === void 0 ? "div" : t0, display = t1 === void 0 ? "block" : t1, margin = t2 === void 0 ? 0 : t2, padding = t3 === void 0 ? 0 : t3, t4 = typeof asProp == "string" ? asProp : void 0, t5 = useArrayProp(column2), t6 = useArrayProp(columnStart), t7 = useArrayProp(columnEnd), t8 = useArrayProp(display), t9 = useArrayProp(flex), t10 = useArrayProp(height), t11 = useArrayProp(margin), t12 = useArrayProp(marginX), t13 = useArrayProp(marginY), t14 = useArrayProp(marginTop), t15 = useArrayProp(marginRight), t16 = useArrayProp(marginBottom), t17 = useArrayProp(marginLeft), t18 = useArrayProp(overflow), t19 = useArrayProp(padding), t20 = useArrayProp(paddingX), t21 = useArrayProp(paddingY), t22 = useArrayProp(paddingTop), t23 = useArrayProp(paddingRight), t24 = useArrayProp(paddingBottom), t25 = useArrayProp(paddingLeft), t26 = useArrayProp(row), t27 = useArrayProp(rowStart), t28 = useArrayProp(rowEnd), t29 = useArrayProp(sizing);
  let t30;
  return $2[28] !== asProp || $2[29] !== props.children || $2[30] !== ref || $2[31] !== restProps || $2[32] !== t10 || $2[33] !== t11 || $2[34] !== t12 || $2[35] !== t13 || $2[36] !== t14 || $2[37] !== t15 || $2[38] !== t16 || $2[39] !== t17 || $2[40] !== t18 || $2[41] !== t19 || $2[42] !== t20 || $2[43] !== t21 || $2[44] !== t22 || $2[45] !== t23 || $2[46] !== t24 || $2[47] !== t25 || $2[48] !== t26 || $2[49] !== t27 || $2[50] !== t28 || $2[51] !== t29 || $2[52] !== t4 || $2[53] !== t5 || $2[54] !== t6 || $2[55] !== t7 || $2[56] !== t8 || $2[57] !== t9 ? (t30 = (0, import_jsx_runtime12.jsx)(StyledBox, { "data-as": t4, "data-ui": "Box", ...restProps, $column: t5, $columnStart: t6, $columnEnd: t7, $display: t8, $flex: t9, $height: t10, $margin: t11, $marginX: t12, $marginY: t13, $marginTop: t14, $marginRight: t15, $marginBottom: t16, $marginLeft: t17, $overflow: t18, $padding: t19, $paddingX: t20, $paddingY: t21, $paddingTop: t22, $paddingRight: t23, $paddingBottom: t24, $paddingLeft: t25, $row: t26, $rowStart: t27, $rowEnd: t28, $sizing: t29, as: asProp, ref, children: props.children }), $2[28] = asProp, $2[29] = props.children, $2[30] = ref, $2[31] = restProps, $2[32] = t10, $2[33] = t11, $2[34] = t12, $2[35] = t13, $2[36] = t14, $2[37] = t15, $2[38] = t16, $2[39] = t17, $2[40] = t18, $2[41] = t19, $2[42] = t20, $2[43] = t21, $2[44] = t22, $2[45] = t23, $2[46] = t24, $2[47] = t25, $2[48] = t26, $2[49] = t27, $2[50] = t28, $2[51] = t29, $2[52] = t4, $2[53] = t5, $2[54] = t6, $2[55] = t7, $2[56] = t8, $2[57] = t9, $2[58] = t30) : t30 = $2[58], t30;
});
Box.displayName = "ForwardRef(Box)";
function textBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props, {
    font
  } = getTheme_v2(props.theme);
  return lt`
    color: var(--card-fg-color);

    ${$accent && lt`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && lt`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
      background-color: var(--card-code-bg-color);
      color: var(--card-code-fg-color);
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
      color: var(--card-link-color);
      outline: none;

      @media (hover: hover) {
        &:hover {
          text-decoration: underline;
        }
      }

      &:focus {
        box-shadow:
          0 0 0 1px var(--card-bg-color),
          0 0 0 3px var(--card-focus-ring-color);
      }

      &:focus:not(:focus-visible) {
        box-shadow: none;
      }
    }

    & strong {
      font-weight: ${font.text.weights.bold};
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
      color: var(--card-icon-color);

      & path {
        vector-effect: non-scaling-stroke !important;
      }
    }
  `;
}
var StyledText = dt.div.withConfig({
  displayName: "StyledText",
  componentId: "sc-11ov82j-0"
})(responsiveTextFont, responsiveTextAlignStyle, textBaseStyle);
var Text = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(22);
  let align, childrenProp, restProps, t0, t1, t2, textOverflow, weight;
  $2[0] !== props ? ({
    accent: t0,
    align,
    children: childrenProp,
    muted: t1,
    size: t2,
    textOverflow,
    weight,
    ...restProps
  } = props, $2[0] = props, $2[1] = align, $2[2] = childrenProp, $2[3] = restProps, $2[4] = t0, $2[5] = t1, $2[6] = t2, $2[7] = textOverflow, $2[8] = weight) : (align = $2[1], childrenProp = $2[2], restProps = $2[3], t0 = $2[4], t1 = $2[5], t2 = $2[6], textOverflow = $2[7], weight = $2[8]);
  const accent = t0 === void 0 ? false : t0, muted = t1 === void 0 ? false : t1, size22 = t2 === void 0 ? 2 : t2;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    let t32;
    $2[9] !== children ? (t32 = (0, import_jsx_runtime12.jsx)(SpanWithTextOverflow, { children }), $2[9] = children, $2[10] = t32) : t32 = $2[10], children = t32;
  }
  const t3 = useArrayProp(align), t4 = useArrayProp(size22);
  let t5;
  $2[11] !== children ? (t5 = (0, import_jsx_runtime12.jsx)("span", { children }), $2[11] = children, $2[12] = t5) : t5 = $2[12];
  let t6;
  return $2[13] !== accent || $2[14] !== muted || $2[15] !== ref || $2[16] !== restProps || $2[17] !== t3 || $2[18] !== t4 || $2[19] !== t5 || $2[20] !== weight ? (t6 = (0, import_jsx_runtime12.jsx)(StyledText, { "data-ui": "Text", ...restProps, $accent: accent, $align: t3, $muted: muted, ref, $size: t4, $weight: weight, children: t5 }), $2[13] = accent, $2[14] = muted, $2[15] = ref, $2[16] = restProps, $2[17] = t3, $2[18] = t4, $2[19] = t5, $2[20] = weight, $2[21] = t6) : t6 = $2[21], t6;
});
Text.displayName = "ForwardRef(Text)";
function badgeStyle(props) {
  const {
    $tone
  } = props;
  return {
    "--card-bg-color": `var(--card-badge-${$tone}-bg-color)`,
    "--card-fg-color": `var(--card-badge-${$tone}-fg-color)`,
    backgroundColor: "var(--card-bg-color)",
    cursor: "default",
    "&:not([hidden])": {
      display: "inline-block",
      verticalAlign: "top"
    }
  };
}
var StyledBadge = dt(Box).withConfig({
  displayName: "StyledBadge",
  componentId: "sc-5u140l-0"
})(responsiveRadiusStyle, badgeStyle);
var Badge = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(17);
  let children, restProps, t0, t1, t2, t3;
  if ($2[0] !== props) {
    const {
      children: t42,
      fontSize: t52,
      mode: _deprecated_mode,
      padding: t62,
      radius: t72,
      tone: t8,
      ...t9
    } = props;
    children = t42, t0 = t52, t1 = t62, t2 = t72, t3 = t8, restProps = t9, $2[0] = props, $2[1] = children, $2[2] = restProps, $2[3] = t0, $2[4] = t1, $2[5] = t2, $2[6] = t3;
  } else
    children = $2[1], restProps = $2[2], t0 = $2[3], t1 = $2[4], t2 = $2[5], t3 = $2[6];
  const fontSize2 = t0 === void 0 ? 1 : t0, padding = t1 === void 0 ? 1 : t1, radius = t2 === void 0 ? "full" : t2, tone = t3 === void 0 ? "default" : t3, t4 = useArrayProp(radius), t5 = useArrayProp(padding);
  let t6;
  $2[7] !== children || $2[8] !== fontSize2 ? (t6 = (0, import_jsx_runtime12.jsx)(Text, { size: fontSize2, children }), $2[7] = children, $2[8] = fontSize2, $2[9] = t6) : t6 = $2[9];
  let t7;
  return $2[10] !== ref || $2[11] !== restProps || $2[12] !== t4 || $2[13] !== t5 || $2[14] !== t6 || $2[15] !== tone ? (t7 = (0, import_jsx_runtime12.jsx)(StyledBadge, { "data-ui": "Badge", ...restProps, $tone: tone, $radius: t4, padding: t5, ref, children: t6 }), $2[10] = ref, $2[11] = restProps, $2[12] = t4, $2[13] = t5, $2[14] = t6, $2[15] = tone, $2[16] = t7) : t7 = $2[16], t7;
});
Badge.displayName = "ForwardRef(Badge)";
var StyledFlex = dt(Box).withConfig({
  displayName: "StyledFlex",
  componentId: "sc-oxesg3-0"
})(flexItemStyle, responsiveFlexStyle);
var Flex = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(17);
  let align, as, gap, justify, restProps, t0, wrap2;
  $2[0] !== props ? ({
    align,
    as,
    direction: t0,
    gap,
    justify,
    wrap: wrap2,
    ...restProps
  } = props, $2[0] = props, $2[1] = align, $2[2] = as, $2[3] = gap, $2[4] = justify, $2[5] = restProps, $2[6] = t0, $2[7] = wrap2) : (align = $2[1], as = $2[2], gap = $2[3], justify = $2[4], restProps = $2[5], t0 = $2[6], wrap2 = $2[7]);
  const direction = t0 === void 0 ? "row" : t0, t1 = useArrayProp(align), t2 = useArrayProp(direction), t3 = useArrayProp(gap), t4 = useArrayProp(justify), t5 = useArrayProp(wrap2);
  let t6;
  return $2[8] !== as || $2[9] !== ref || $2[10] !== restProps || $2[11] !== t1 || $2[12] !== t2 || $2[13] !== t3 || $2[14] !== t4 || $2[15] !== t5 ? (t6 = (0, import_jsx_runtime12.jsx)(StyledFlex, { "data-ui": "Flex", ...restProps, $align: t1, $direction: t2, $gap: t3, $justify: t4, $wrap: t5, forwardedAs: as, ref }), $2[8] = as, $2[9] = ref, $2[10] = restProps, $2[11] = t1, $2[12] = t2, $2[13] = t3, $2[14] = t4, $2[15] = t5, $2[16] = t6) : t6 = $2[16], t6;
});
Flex.displayName = "ForwardRef(Flex)";
var rotate2 = mt`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`;
var StyledSpinner = dt(Text).withConfig({
  displayName: "StyledSpinner",
  componentId: "sc-124hnd0-0"
})`& > span > svg{animation:${rotate2} 500ms linear infinite;}`;
var Spinner = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(4);
  let t0;
  $2[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = (0, import_jsx_runtime12.jsx)(SpinnerIcon, {}), $2[0] = t0) : t0 = $2[0];
  let t1;
  return $2[1] !== props || $2[2] !== ref ? (t1 = (0, import_jsx_runtime12.jsx)(StyledSpinner, { "data-ui": "Spinner", ...props, ref, children: t0 }), $2[1] = props, $2[2] = ref, $2[3] = t1) : t1 = $2[3], t1;
});
Spinner.displayName = "ForwardRef(Spinner)";
function _cardColorStyle(base, color3, checkered = false) {
  var _a, _b, _c, _d, _e2, _f, _g, _h;
  return {
    // from base
    "--card-backdrop-color": base.backdrop,
    "--card-focus-ring-color": base.focusRing,
    "--card-shadow-outline-color": base.shadow.outline,
    "--card-shadow-umbra-color": base.shadow.umbra,
    "--card-shadow-penumbra-color": base.shadow.penumbra,
    "--card-shadow-ambient-color": base.shadow.ambient,
    // from state
    "--card-accent-fg-color": color3.accent.fg,
    "--card-avatar-gray-bg-color": color3.avatar.gray.bg,
    "--card-avatar-gray-fg-color": color3.avatar.gray.fg,
    "--card-avatar-blue-bg-color": color3.avatar.blue.bg,
    "--card-avatar-blue-fg-color": color3.avatar.blue.fg,
    "--card-avatar-purple-bg-color": color3.avatar.purple.bg,
    "--card-avatar-purple-fg-color": color3.avatar.purple.fg,
    "--card-avatar-magenta-bg-color": color3.avatar.magenta.bg,
    "--card-avatar-magenta-fg-color": color3.avatar.magenta.fg,
    "--card-avatar-red-bg-color": color3.avatar.red.bg,
    "--card-avatar-red-fg-color": color3.avatar.red.fg,
    "--card-avatar-orange-bg-color": color3.avatar.orange.bg,
    "--card-avatar-orange-fg-color": color3.avatar.orange.fg,
    "--card-avatar-yellow-bg-color": color3.avatar.yellow.bg,
    "--card-avatar-yellow-fg-color": color3.avatar.yellow.fg,
    "--card-avatar-green-bg-color": color3.avatar.green.bg,
    "--card-avatar-green-fg-color": color3.avatar.green.fg,
    "--card-avatar-cyan-bg-color": color3.avatar.cyan.bg,
    "--card-avatar-cyan-fg-color": color3.avatar.cyan.fg,
    "--card-bg-color": color3.bg,
    "--card-bg-image": checkered ? `repeating-conic-gradient(${color3.bg} 0% 25%, ${color3.muted.bg} 0% 50%)` : void 0,
    "--card-border-color": color3.border,
    "--card-badge-default-bg-color": color3.badge.default.bg,
    "--card-badge-default-dot-color": color3.badge.default.dot,
    "--card-badge-default-fg-color": color3.badge.default.fg,
    "--card-badge-default-icon-color": color3.badge.default.icon,
    "--card-badge-neutral-bg-color": (_a = color3.badge.neutral) == null ? void 0 : _a.bg,
    "--card-badge-neutral-dot-color": (_b = color3.badge.neutral) == null ? void 0 : _b.dot,
    "--card-badge-neutral-fg-color": (_c = color3.badge.neutral) == null ? void 0 : _c.fg,
    "--card-badge-neutral-icon-color": (_d = color3.badge.neutral) == null ? void 0 : _d.icon,
    "--card-badge-primary-bg-color": color3.badge.primary.bg,
    "--card-badge-primary-dot-color": color3.badge.primary.dot,
    "--card-badge-primary-fg-color": color3.badge.primary.fg,
    "--card-badge-primary-icon-color": color3.badge.primary.icon,
    "--card-badge-suggest-bg-color": (_e2 = color3.badge.suggest) == null ? void 0 : _e2.bg,
    "--card-badge-suggest-dot-color": (_f = color3.badge.suggest) == null ? void 0 : _f.dot,
    "--card-badge-suggest-fg-color": (_g = color3.badge.suggest) == null ? void 0 : _g.fg,
    "--card-badge-suggest-icon-color": (_h = color3.badge.suggest) == null ? void 0 : _h.icon,
    "--card-badge-positive-bg-color": color3.badge.positive.bg,
    "--card-badge-positive-dot-color": color3.badge.positive.dot,
    "--card-badge-positive-fg-color": color3.badge.positive.fg,
    "--card-badge-positive-icon-color": color3.badge.positive.icon,
    "--card-badge-caution-bg-color": color3.badge.caution.bg,
    "--card-badge-caution-dot-color": color3.badge.caution.dot,
    "--card-badge-caution-fg-color": color3.badge.caution.fg,
    "--card-badge-caution-icon-color": color3.badge.caution.icon,
    "--card-badge-critical-bg-color": color3.badge.critical.bg,
    "--card-badge-critical-dot-color": color3.badge.critical.dot,
    "--card-badge-critical-fg-color": color3.badge.critical.fg,
    "--card-badge-critical-icon-color": color3.badge.critical.icon,
    "--card-code-bg-color": color3.code.bg,
    "--card-code-fg-color": color3.code.fg,
    "--card-fg-color": color3.fg,
    "--card-icon-color": color3.icon,
    "--card-kbd-bg-color": color3.kbd.bg,
    "--card-kbd-border-color": color3.kbd.border,
    "--card-kbd-fg-color": color3.kbd.fg,
    "--card-link-fg-color": color3.link.fg,
    "--card-muted-bg-color": color3.muted.bg,
    "--card-muted-fg-color": color3.muted.fg,
    "--card-skeleton-color-from": color3.skeleton.from,
    "--card-skeleton-color-to": color3.skeleton.to,
    // deprecated variables (kept for legacy)
    "--card-bg2-color": color3.muted.bg,
    "--card-link-color": color3.link.fg,
    "--card-hairline-soft-color": color3.border,
    "--card-hairline-hard-color": color3.border
  };
}
function buttonBaseStyles(props) {
  const {
    $width
  } = props, {
    style
  } = getTheme_v2(props.theme);
  return lt`
    ${style == null ? void 0 : style.button};

    -webkit-font-smoothing: inherit;
    appearance: none;
    display: inline-flex;
    align-items: center;
    font: inherit;
    border: 0;
    outline: none;
    user-select: none;
    text-decoration: none;
    border: 0;
    box-sizing: border-box;
    padding: 0;
    margin: 0;
    white-space: nowrap;
    text-align: left;
    position: relative;
    vertical-align: top;

    ${$width === "fill" && lt`
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    `}

    & > span {
      display: block;
      flex: 1;
      min-width: 0;
      border-radius: inherit;
    }

    &::-moz-focus-inner {
      border: 0;
      padding: 0;
    }
  `;
}
function combineBoxShadow(...boxShadows) {
  return boxShadows.filter(Boolean).join(",");
}
function buttonColorStyles(props) {
  var _a;
  const {
    $mode
  } = props, {
    button,
    color: baseColor,
    style
  } = getTheme_v2(props.theme), shadow = props.$mode === "ghost", mode = baseColor.button[$mode] || baseColor.button.default, color3 = mode[props.$tone] || mode.default, border2 = {
    width: button.border.width,
    color: "var(--card-border-color)"
  }, defaultBoxShadow = void 0;
  return [_cardColorStyle(baseColor, color3.enabled), {
    backgroundColor: "var(--card-bg-color)",
    color: "var(--card-fg-color)",
    boxShadow: focusRingBorderStyle(border2),
    '&:disabled, &[data-disabled="true"]': _cardColorStyle(baseColor, color3.disabled),
    "&:not([data-disabled='true'])": {
      boxShadow: combineBoxShadow(focusRingBorderStyle(border2), shadow ? defaultBoxShadow : void 0),
      "&:focus": {
        boxShadow: focusRingStyle({
          base: baseColor,
          border: {
            width: 2,
            color: baseColor.bg
          },
          focusRing: button.focusRing
        })
      },
      "&:focus:not(:focus-visible)": {
        boxShadow: combineBoxShadow(focusRingBorderStyle(border2), shadow ? defaultBoxShadow : void 0)
      },
      "@media (hover: hover)": {
        "&:hover": _cardColorStyle(baseColor, color3.hovered),
        "&:active": _cardColorStyle(baseColor, color3.pressed),
        "&[data-hovered]": _cardColorStyle(baseColor, color3.hovered)
      },
      "&[data-selected]": _cardColorStyle(baseColor, color3.pressed)
    }
  }, (_a = style == null ? void 0 : style.button) == null ? void 0 : _a.root].filter(Boolean);
}
var StyledButton = dt.button.withConfig({
  displayName: "StyledButton",
  componentId: "sc-aaekt4-0"
})(responsiveRadiusStyle, buttonBaseStyles, buttonColorStyles);
var LoadingBox = dt.div.withConfig({
  displayName: "LoadingBox",
  componentId: "sc-aaekt4-1"
})`position:absolute;top:0;left:0;right:0;bottom:0;display:flex;align-items:center;justify-content:center;background-color:var(--card-bg-color);border-radius:inherit;z-index:1;box-shadow:inherit;`;
var Button = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(66);
  let IconComponent, IconRightComponent, children, disabled, loading, paddingBottomProp, paddingLeftProp, paddingRightProp, paddingTopProp, paddingXProp, paddingYProp, restProps, selected, t0, t1, t2, t3, t4, t5, t6, t7, t8, text, textAlign, textWeight, width;
  $2[0] !== props ? ({
    children,
    disabled,
    fontSize: t0,
    icon: IconComponent,
    iconRight: IconRightComponent,
    justify: t1,
    loading,
    mode: t2,
    padding: t3,
    paddingX: paddingXProp,
    paddingY: paddingYProp,
    paddingTop: paddingTopProp,
    paddingBottom: paddingBottomProp,
    paddingLeft: paddingLeftProp,
    paddingRight: paddingRightProp,
    radius: t4,
    selected,
    space: t5,
    text,
    textAlign,
    textWeight,
    tone: t6,
    type: t7,
    muted: t8,
    width,
    ...restProps
  } = props, $2[0] = props, $2[1] = IconComponent, $2[2] = IconRightComponent, $2[3] = children, $2[4] = disabled, $2[5] = loading, $2[6] = paddingBottomProp, $2[7] = paddingLeftProp, $2[8] = paddingRightProp, $2[9] = paddingTopProp, $2[10] = paddingXProp, $2[11] = paddingYProp, $2[12] = restProps, $2[13] = selected, $2[14] = t0, $2[15] = t1, $2[16] = t2, $2[17] = t3, $2[18] = t4, $2[19] = t5, $2[20] = t6, $2[21] = t7, $2[22] = t8, $2[23] = text, $2[24] = textAlign, $2[25] = textWeight, $2[26] = width) : (IconComponent = $2[1], IconRightComponent = $2[2], children = $2[3], disabled = $2[4], loading = $2[5], paddingBottomProp = $2[6], paddingLeftProp = $2[7], paddingRightProp = $2[8], paddingTopProp = $2[9], paddingXProp = $2[10], paddingYProp = $2[11], restProps = $2[12], selected = $2[13], t0 = $2[14], t1 = $2[15], t2 = $2[16], t3 = $2[17], t4 = $2[18], t5 = $2[19], t6 = $2[20], t7 = $2[21], t8 = $2[22], text = $2[23], textAlign = $2[24], textWeight = $2[25], width = $2[26]);
  const fontSize2 = t0 === void 0 ? 1 : t0, justifyProp = t1 === void 0 ? "center" : t1, mode = t2 === void 0 ? "default" : t2, paddingProp = t3 === void 0 ? 3 : t3, radiusProp = t4 === void 0 ? 2 : t4, spaceProp = t5 === void 0 ? 3 : t5, tone = t6 === void 0 ? "default" : t6, type = t7 === void 0 ? "button" : t7, muted = t8 === void 0 ? false : t8, {
    button
  } = useTheme_v2(), justify = useArrayProp(justifyProp), padding = useArrayProp(paddingProp), paddingX = useArrayProp(paddingXProp), paddingY = useArrayProp(paddingYProp), paddingTop = useArrayProp(paddingTopProp), paddingBottom = useArrayProp(paddingBottomProp), paddingLeft = useArrayProp(paddingLeftProp), paddingRight = useArrayProp(paddingRightProp), radius = useArrayProp(radiusProp), space = useArrayProp(spaceProp);
  let t9, t10;
  $2[27] !== padding || $2[28] !== paddingBottom || $2[29] !== paddingLeft || $2[30] !== paddingRight || $2[31] !== paddingTop || $2[32] !== paddingX || $2[33] !== paddingY ? (t10 = {
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingBottom,
    paddingLeft,
    paddingRight
  }, $2[27] = padding, $2[28] = paddingBottom, $2[29] = paddingLeft, $2[30] = paddingRight, $2[31] = paddingTop, $2[32] = paddingX, $2[33] = paddingY, $2[34] = t10) : t10 = $2[34], t9 = t10;
  const boxProps = t9, t11 = !!(loading || disabled), t12 = selected ? "" : void 0, t13 = !!(loading || disabled);
  let t14;
  $2[35] !== loading ? (t14 = !!loading && (0, import_jsx_runtime12.jsx)(LoadingBox, { children: (0, import_jsx_runtime12.jsx)(Spinner, {}) }), $2[35] = loading, $2[36] = t14) : t14 = $2[36];
  let t15;
  $2[37] !== IconComponent || $2[38] !== IconRightComponent || $2[39] !== boxProps || $2[40] !== button || $2[41] !== fontSize2 || $2[42] !== justify || $2[43] !== muted || $2[44] !== space || $2[45] !== text || $2[46] !== textAlign || $2[47] !== textWeight ? (t15 = (IconComponent || text || IconRightComponent) && (0, import_jsx_runtime12.jsx)(Box, { as: "span", ...boxProps, children: (0, import_jsx_runtime12.jsxs)(Flex, { as: "span", justify, gap: space, children: [
    IconComponent && (0, import_jsx_runtime12.jsxs)(Text, { size: fontSize2, children: [
      (0, import_react52.isValidElement)(IconComponent) && IconComponent,
      (0, import_react_is.isValidElementType)(IconComponent) && (0, import_jsx_runtime12.jsx)(IconComponent, {})
    ] }),
    text && (0, import_jsx_runtime12.jsx)(Box, { children: (0, import_jsx_runtime12.jsx)(Text, { muted, align: textAlign, size: fontSize2, textOverflow: "ellipsis", weight: textWeight ?? button.textWeight, children: text }) }),
    IconRightComponent && (0, import_jsx_runtime12.jsxs)(Text, { size: fontSize2, children: [
      (0, import_react52.isValidElement)(IconRightComponent) && IconRightComponent,
      (0, import_react_is.isValidElementType)(IconRightComponent) && (0, import_jsx_runtime12.jsx)(IconRightComponent, {})
    ] })
  ] }) }), $2[37] = IconComponent, $2[38] = IconRightComponent, $2[39] = boxProps, $2[40] = button, $2[41] = fontSize2, $2[42] = justify, $2[43] = muted, $2[44] = space, $2[45] = text, $2[46] = textAlign, $2[47] = textWeight, $2[48] = t15) : t15 = $2[48];
  let t16;
  $2[49] !== boxProps || $2[50] !== children ? (t16 = children && (0, import_jsx_runtime12.jsx)(Box, { as: "span", ...boxProps, children }), $2[49] = boxProps, $2[50] = children, $2[51] = t16) : t16 = $2[51];
  let t17;
  return $2[52] !== mode || $2[53] !== radius || $2[54] !== ref || $2[55] !== restProps || $2[56] !== t11 || $2[57] !== t12 || $2[58] !== t13 || $2[59] !== t14 || $2[60] !== t15 || $2[61] !== t16 || $2[62] !== tone || $2[63] !== type || $2[64] !== width ? (t17 = (0, import_jsx_runtime12.jsxs)(StyledButton, { "data-ui": "Button", ...restProps, $mode: mode, $radius: radius, $tone: tone, "data-disabled": t11, "data-selected": t12, disabled: t13, ref, type, $width: width, children: [
    t14,
    t15,
    t16
  ] }), $2[52] = mode, $2[53] = radius, $2[54] = ref, $2[55] = restProps, $2[56] = t11, $2[57] = t12, $2[58] = t13, $2[59] = t14, $2[60] = t15, $2[61] = t16, $2[62] = tone, $2[63] = type, $2[64] = width, $2[65] = t17) : t17 = $2[65], t17;
});
Button.displayName = "ForwardRef(Button)";
function cardStyle(props) {
  return [cardBaseStyle(props), cardColorStyle(props)];
}
function cardBaseStyle(props) {
  const {
    $checkered
  } = props, {
    space
  } = getTheme_v2(props.theme);
  return lt`
    ${$checkered && lt`
      background-size: ${space[3]}px ${space[3]}px;
      background-position: 50% 50%;
      background-image: var(--card-bg-image);
    `}

    &[data-as='button'] {
      -webkit-font-smoothing: inherit;
      appearance: none;
      outline: none;
      font: inherit;
      text-align: inherit;
      border: 0;
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    }

    /* &:is(a) */
    &[data-as='a'] {
      outline: none;
      text-decoration: none;
    }

    /* &:is(pre) */
    &[data-as='pre'] {
      font: inherit;
    }
  `;
}
function cardColorStyle(props) {
  var _a;
  const {
    $checkered,
    $focusRing,
    $muted
  } = props, {
    card,
    color: color3,
    style
  } = getTheme_v2(props.theme), border2 = {
    width: card.border.width,
    color: "var(--card-border-color)"
  };
  return lt`
    color-scheme: ${color3._dark ? "dark" : "light"};

    ${_cardColorStyle(color3, color3, $checkered)}

    background-color: ${$muted ? "var(--card-muted-bg-color)" : "var(--card-bg-color)"};
    color: var(--card-fg-color);

    /* &:is(button) */
    &[data-as='button'] {
      --card-focus-ring-box-shadow: none;

      cursor: default;
      box-shadow: var(--card-focus-ring-box-shadow);

      &:disabled {
        ${_cardColorStyle(color3, color3.selectable.default.disabled, $checkered)}
      }

      &:not(:disabled) {
        &[data-pressed] {
          ${_cardColorStyle(color3, color3.selectable.default.pressed, $checkered)}
        }

        &[data-selected] {
          ${_cardColorStyle(color3, color3.selectable.default.selected, $checkered)}
        }

        @media (hover: hover) {
          &:not([data-pressed]):not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color3, color3.selectable.default.hovered, $checkered)}
            }

            &:active {
              ${_cardColorStyle(color3, color3.selectable.default.pressed, $checkered)}
            }
          }
        }

        &:focus-visible {
          --card-focus-ring-box-shadow: ${$focusRing ? focusRingStyle({
    base: color3,
    border: border2,
    focusRing: card.focusRing
  }) : void 0};
        }
      }
    }

    /* &:is(a) */
    &[data-as='a'] {
      cursor: pointer;
      box-shadow: var(--card-focus-ring-box-shadow);

      &[data-disabled] {
        ${_cardColorStyle(color3, color3.selectable.default.disabled, $checkered)}
      }

      &:not([data-disabled]) {
        &[data-pressed] {
          ${_cardColorStyle(color3, color3.selectable.default.pressed, $checkered)}
        }

        &[data-selected] {
          ${_cardColorStyle(color3, color3.selectable.default.selected, $checkered)}
        }

        @media (hover: hover) {
          &:not([data-pressed]):not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color3, color3.selectable.default.hovered, $checkered)}
            }

            &:active {
              ${_cardColorStyle(color3, color3.selectable.default.pressed, $checkered)}
            }
          }
        }

        &:focus-visible {
          --card-focus-ring-box-shadow: ${$focusRing ? focusRingStyle({
    base: color3,
    border: border2,
    focusRing: card.focusRing
  }) : void 0};
        }
      }
    }

    ${(_a = style == null ? void 0 : style.card) == null ? void 0 : _a.root}
  `;
}
var StyledCard = dt(Box).withConfig({
  displayName: "StyledCard",
  componentId: "sc-osnro2-0"
})(responsiveBorderStyle, responsiveRadiusStyle, responsiveShadowStyle, cardStyle);
var Card = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(42);
  let asProp, border2, borderBottom2, borderLeft2, borderRight2, borderTop2, muted, pressed, restProps, scheme, selected, shadow, t0, t1, t2, t3;
  $2[0] !== props ? ({
    __unstable_checkered: t0,
    __unstable_focusRing: t1,
    as: asProp,
    border: border2,
    borderTop: borderTop2,
    borderRight: borderRight2,
    borderBottom: borderBottom2,
    borderLeft: borderLeft2,
    muted,
    pressed,
    radius: t2,
    scheme,
    selected,
    shadow,
    tone: t3,
    ...restProps
  } = props, $2[0] = props, $2[1] = asProp, $2[2] = border2, $2[3] = borderBottom2, $2[4] = borderLeft2, $2[5] = borderRight2, $2[6] = borderTop2, $2[7] = muted, $2[8] = pressed, $2[9] = restProps, $2[10] = scheme, $2[11] = selected, $2[12] = shadow, $2[13] = t0, $2[14] = t1, $2[15] = t2, $2[16] = t3) : (asProp = $2[1], border2 = $2[2], borderBottom2 = $2[3], borderLeft2 = $2[4], borderRight2 = $2[5], borderTop2 = $2[6], muted = $2[7], pressed = $2[8], restProps = $2[9], scheme = $2[10], selected = $2[11], shadow = $2[12], t0 = $2[13], t1 = $2[14], t2 = $2[15], t3 = $2[16]);
  const checkered = t0 === void 0 ? false : t0, focusRing = t1 === void 0 ? false : t1, radius = t2 === void 0 ? 0 : t2, toneProp = t3 === void 0 ? "default" : t3, as = (0, import_react_is.isValidElementType)(asProp) ? asProp : "div", rootTheme = useRootTheme(), tone = toneProp === "inherit" ? rootTheme.tone : toneProp, t4 = typeof as == "string" ? as : void 0, t5 = rootTheme.scheme, t6 = useArrayProp(border2), t7 = useArrayProp(borderTop2), t8 = useArrayProp(borderRight2), t9 = useArrayProp(borderBottom2), t10 = useArrayProp(borderLeft2), t11 = useArrayProp(radius), t12 = useArrayProp(shadow), t13 = checkered ? "" : void 0, t14 = pressed ? "" : void 0, t15 = selected ? "" : void 0;
  let t16;
  $2[17] !== as || $2[18] !== checkered || $2[19] !== focusRing || $2[20] !== muted || $2[21] !== ref || $2[22] !== restProps || $2[23] !== rootTheme.scheme || $2[24] !== selected || $2[25] !== t10 || $2[26] !== t11 || $2[27] !== t12 || $2[28] !== t13 || $2[29] !== t14 || $2[30] !== t15 || $2[31] !== t4 || $2[32] !== t6 || $2[33] !== t7 || $2[34] !== t8 || $2[35] !== t9 || $2[36] !== tone ? (t16 = (0, import_jsx_runtime12.jsx)(StyledCard, { "data-as": t4, "data-scheme": t5, "data-ui": "Card", "data-tone": tone, ...restProps, $border: t6, $borderTop: t7, $borderRight: t8, $borderBottom: t9, $borderLeft: t10, $checkered: checkered, $focusRing: focusRing, $muted: muted, $radius: t11, $shadow: t12, $tone: tone, "data-checkered": t13, "data-pressed": t14, "data-selected": t15, forwardedAs: as, ref, selected }), $2[17] = as, $2[18] = checkered, $2[19] = focusRing, $2[20] = muted, $2[21] = ref, $2[22] = restProps, $2[23] = rootTheme.scheme, $2[24] = selected, $2[25] = t10, $2[26] = t11, $2[27] = t12, $2[28] = t13, $2[29] = t14, $2[30] = t15, $2[31] = t4, $2[32] = t6, $2[33] = t7, $2[34] = t8, $2[35] = t9, $2[36] = tone, $2[37] = t16) : t16 = $2[37];
  let t17;
  return $2[38] !== scheme || $2[39] !== t16 || $2[40] !== tone ? (t17 = (0, import_jsx_runtime12.jsx)(ThemeColorProvider, { scheme, tone, children: t16 }), $2[38] = scheme, $2[39] = t16, $2[40] = tone, $2[41] = t17) : t17 = $2[41], t17;
});
Card.displayName = "ForwardRef(Card)";
function checkboxBaseStyles() {
  return lt`
    position: relative;
    display: inline-block;
  `;
}
function inputElementStyles(props) {
  const {
    color: color3,
    input,
    radius
  } = getTheme_v2(props.theme), {
    focusRing
  } = input.checkbox;
  return lt`
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    outline: none;
    opacity: 0;
    z-index: 1;
    padding: 0;
    margin: 0;

    & + span {
      position: relative;
      display: block;
      height: ${rem(input.checkbox.size)};
      width: ${rem(input.checkbox.size)};
      box-sizing: border-box;
      box-shadow: ${focusRingBorderStyle({
    color: color3.input.default.enabled.border,
    width: input.border.width
  })};
      border-radius: ${rem(radius[2])};
      line-height: 1;
      background-color: ${color3.input.default.enabled.bg};

      & > svg {
        display: block;
        position: absolute;
        opacity: 0;
        height: 100%;
        width: 100%;

        & > path {
          vector-effect: non-scaling-stroke;
          stroke-width: 1.5px !important;
        }
      }
    }

    &:checked + span {
      background: ${color3.input.default.enabled.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color3.input.default.enabled.fg,
    width: input.border.width
  })};
      color: ${color3.input.default.enabled.bg};
    }

    /* focus */
    &:not(:disabled):focus:focus-visible + span {
      box-shadow: ${focusRingStyle({
    focusRing
  })};
    }

    /* focus when checked - uses a different offset */
    &:not(:disabled):focus:focus-visible&:checked + span {
      box-shadow: ${focusRingStyle({
    focusRing: {
      width: 1,
      offset: 1
    }
  })};
    }

    &[data-error] + span {
      background-color: ${color3.input.invalid.enabled.border};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color3.input.invalid.enabled.muted.bg
  })};
      color: ${color3.input.default.disabled.fg};
    }
    &[data-error]&:checked + span {
      background-color: ${color3.input.invalid.enabled.muted.bg};
      color: ${color3.input.default.enabled.bg};
    }
    &[data-error]&:checked&:not(:disabled):focus:focus-visible + span {
      box-shadow: ${focusRingStyle({
    border: {
      width: input.border.width,
      color: color3.input.invalid.readOnly.muted.bg
    },
    focusRing: {
      width: 1,
      offset: 1
    }
  })};
    }

    &:disabled + span {
      background-color: ${color3.input.default.disabled.bg};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color3.input.default.disabled.border
  })};
      color: ${color3.input.default.disabled.fg};
    }
    &:disabled&:checked + span {
      background-color: ${color3.input.default.disabled.muted.bg};
    }

    &[data-read-only] + span {
      background-color: ${color3.input.default.readOnly.bg};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color3.input.default.readOnly.border
  })};
      color: ${color3.input.default.readOnly.fg};
    }

    &[data-read-only]&:checked + span {
      background-color: ${color3.input.default.readOnly.muted.bg};
    }

    &:checked + span > svg:first-child {
      opacity: 1;
    }
    &:indeterminate + span > svg:last-child {
      opacity: 1;
    }
  `;
}
var StyledCheckbox = dt.div.withConfig({
  displayName: "StyledCheckbox",
  componentId: "sc-1l5mt2l-0"
})(checkboxBaseStyles);
var Input$5 = dt.input.withConfig({
  displayName: "Input",
  componentId: "sc-1l5mt2l-1"
})(inputElementStyles);
var Checkbox = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(25);
  let checked, className, customValidity, disabled, indeterminate, readOnly, restProps, style;
  $2[0] !== props ? ({
    checked,
    className,
    disabled,
    indeterminate,
    customValidity,
    readOnly,
    style,
    ...restProps
  } = props, $2[0] = props, $2[1] = checked, $2[2] = className, $2[3] = customValidity, $2[4] = disabled, $2[5] = indeterminate, $2[6] = readOnly, $2[7] = restProps, $2[8] = style) : (checked = $2[1], className = $2[2], customValidity = $2[3], disabled = $2[4], indeterminate = $2[5], readOnly = $2[6], restProps = $2[7], style = $2[8]);
  const ref = (0, import_react52.useRef)(null);
  let t0;
  $2[9] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $2[9] = t0) : t0 = $2[9], (0, import_react52.useImperativeHandle)(forwardedRef, t0);
  let t1, t2;
  $2[10] !== indeterminate ? (t1 = () => {
    ref.current && (ref.current.indeterminate = indeterminate || false);
  }, t2 = [indeterminate], $2[10] = indeterminate, $2[11] = t1, $2[12] = t2) : (t1 = $2[11], t2 = $2[12]), (0, import_react52.useEffect)(t1, t2), useCustomValidity(ref, customValidity);
  const t3 = !disabled && readOnly ? "" : void 0, t4 = customValidity ? "" : void 0, t5 = disabled || readOnly;
  let t6;
  $2[13] !== checked || $2[14] !== readOnly || $2[15] !== restProps || $2[16] !== t3 || $2[17] !== t4 || $2[18] !== t5 ? (t6 = (0, import_jsx_runtime12.jsx)(Input$5, { "data-read-only": t3, "data-error": t4, ...restProps, checked, disabled: t5, type: "checkbox", readOnly, ref }), $2[13] = checked, $2[14] = readOnly, $2[15] = restProps, $2[16] = t3, $2[17] = t4, $2[18] = t5, $2[19] = t6) : t6 = $2[19];
  let t7;
  $2[20] === Symbol.for("react.memo_cache_sentinel") ? (t7 = (0, import_jsx_runtime12.jsxs)("span", { children: [
    (0, import_jsx_runtime12.jsx)(CheckmarkIcon, {}),
    (0, import_jsx_runtime12.jsx)(RemoveIcon, {})
  ] }), $2[20] = t7) : t7 = $2[20];
  let t8;
  return $2[21] !== className || $2[22] !== style || $2[23] !== t6 ? (t8 = (0, import_jsx_runtime12.jsxs)(StyledCheckbox, { className, "data-ui": "Checkbox", style, children: [
    t6,
    t7
  ] }), $2[21] = className, $2[22] = style, $2[23] = t6, $2[24] = t8) : t8 = $2[24], t8;
});
Checkbox.displayName = "ForwardRef(Checkbox)";
function codeSyntaxHighlightingStyle({
  theme
}) {
  const {
    color: {
      syntax: color3
    }
  } = getTheme_v2(theme);
  return {
    "&.atrule": {
      color: color3.atrule
    },
    "&.attr-name": {
      color: color3.attrName
    },
    "&.attr-value": {
      color: color3.attrValue
    },
    "&.attribute": {
      color: color3.attribute
    },
    "&.boolean": {
      color: color3.boolean
    },
    "&.builtin": {
      color: color3.builtin
    },
    "&.cdata": {
      color: color3.cdata
    },
    "&.char": {
      color: color3.char
    },
    "&.class": {
      color: color3.class
    },
    "&.class-name": {
      color: color3.className
    },
    "&.comment": {
      color: color3.comment
    },
    "&.constant": {
      color: color3.constant
    },
    "&.deleted": {
      color: color3.deleted
    },
    "&.doctype": {
      color: color3.doctype
    },
    "&.entity": {
      color: color3.entity
    },
    "&.function": {
      color: color3.function
    },
    "&.hexcode": {
      color: color3.hexcode
    },
    "&.id": {
      color: color3.id
    },
    "&.important": {
      color: color3.important
    },
    "&.inserted": {
      color: color3.inserted
    },
    "&.keyword": {
      color: color3.keyword
    },
    "&.number": {
      color: color3.number
    },
    "&.operator": {
      color: color3.operator
    },
    "&.prolog": {
      color: color3.prolog
    },
    "&.property": {
      color: color3.property
    },
    "&.pseudo-class": {
      color: color3.pseudoClass
    },
    "&.pseudo-element": {
      color: color3.pseudoElement
    },
    "&.punctuation": {
      color: color3.punctuation
    },
    "&.regex": {
      color: color3.regex
    },
    "&.selector": {
      color: color3.selector
    },
    "&.string": {
      color: color3.string
    },
    "&.symbol": {
      color: color3.symbol
    },
    "&.tag": {
      color: color3.tag
    },
    "&.unit": {
      color: color3.unit
    },
    "&.url": {
      color: color3.url
    },
    "&.variable": {
      color: color3.variable
    }
  };
}
function codeBaseStyle() {
  return lt`
    color: var(--card-code-fg-color);

    & code {
      font-family: inherit;

      &.refractor .token {
        ${codeSyntaxHighlightingStyle}
      }
    }

    & a {
      color: inherit;
      text-decoration: underline;
      border-radius: 1px;
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
var LazyRefractor = (0, import_react52.lazy)(() => import("./refractor-E7CJEFLX.js"));
var StyledCode = dt.pre.withConfig({
  displayName: "StyledCode",
  componentId: "sc-4dymyn-0"
})(codeBaseStyle, responsiveCodeFontStyle);
var Code = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(20);
  let children, language, restProps, t0, weight;
  $2[0] !== props ? ({
    children,
    language,
    size: t0,
    weight,
    ...restProps
  } = props, $2[0] = props, $2[1] = children, $2[2] = language, $2[3] = restProps, $2[4] = t0, $2[5] = weight) : (children = $2[1], language = $2[2], restProps = $2[3], t0 = $2[4], weight = $2[5]);
  const t1 = useArrayProp(t0 === void 0 ? 2 : t0);
  let t2;
  $2[6] !== children ? (t2 = (0, import_jsx_runtime12.jsx)("code", { children }), $2[6] = children, $2[7] = t2) : t2 = $2[7];
  let t3;
  $2[8] !== children || $2[9] !== language ? (t3 = (0, import_jsx_runtime12.jsx)(LazyRefractor, { language, value: children }), $2[8] = children, $2[9] = language, $2[10] = t3) : t3 = $2[10];
  let t4;
  $2[11] !== t2 || $2[12] !== t3 ? (t4 = (0, import_jsx_runtime12.jsx)(import_react52.Suspense, { fallback: t2, children: t3 }), $2[11] = t2, $2[12] = t3, $2[13] = t4) : t4 = $2[13];
  let t5;
  return $2[14] !== ref || $2[15] !== restProps || $2[16] !== t1 || $2[17] !== t4 || $2[18] !== weight ? (t5 = (0, import_jsx_runtime12.jsx)(StyledCode, { "data-ui": "Code", ...restProps, $size: t1, $weight: weight, ref, children: t4 }), $2[14] = ref, $2[15] = restProps, $2[16] = t1, $2[17] = t4, $2[18] = weight, $2[19] = t5) : t5 = $2[19], t5;
});
Code.displayName = "ForwardRef(Code)";
var BASE_STYLE$1 = {
  width: "100%",
  margin: "0 auto"
};
function containerBaseStyle() {
  return BASE_STYLE$1;
}
function responsiveContainerWidthStyle(props) {
  const {
    container: container2,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$width, (val) => ({
    maxWidth: val === "auto" ? "none" : rem(container2[val])
  }));
}
var StyledContainer = dt(Box).withConfig({
  displayName: "StyledContainer",
  componentId: "sc-wyroop-0"
})(containerBaseStyle, responsiveContainerWidthStyle);
var Container = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(9);
  let as, restProps, t0;
  $2[0] !== props ? ({
    as,
    width: t0,
    ...restProps
  } = props, $2[0] = props, $2[1] = as, $2[2] = restProps, $2[3] = t0) : (as = $2[1], restProps = $2[2], t0 = $2[3]);
  const t1 = useArrayProp(t0 === void 0 ? 2 : t0);
  let t2;
  return $2[4] !== as || $2[5] !== ref || $2[6] !== restProps || $2[7] !== t1 ? (t2 = (0, import_jsx_runtime12.jsx)(StyledContainer, { "data-ui": "Container", ...restProps, $width: t1, forwardedAs: as, ref }), $2[4] = as, $2[5] = ref, $2[6] = restProps, $2[7] = t1, $2[8] = t2) : t2 = $2[8], t2;
});
Container.displayName = "ForwardRef(Container)";
var StyledGrid = dt(Box).withConfig({
  displayName: "StyledGrid",
  componentId: "sc-v8t8oz-0"
})(responsiveGridStyle);
var Grid = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(26);
  let as, autoCols, autoFlow, autoRows, children, columns, gap, gapX, gapY, restProps, rows;
  $2[0] !== props ? ({
    as,
    autoRows,
    autoCols,
    autoFlow,
    columns,
    gap,
    gapX,
    gapY,
    rows,
    children,
    ...restProps
  } = props, $2[0] = props, $2[1] = as, $2[2] = autoCols, $2[3] = autoFlow, $2[4] = autoRows, $2[5] = children, $2[6] = columns, $2[7] = gap, $2[8] = gapX, $2[9] = gapY, $2[10] = restProps, $2[11] = rows) : (as = $2[1], autoCols = $2[2], autoFlow = $2[3], autoRows = $2[4], children = $2[5], columns = $2[6], gap = $2[7], gapX = $2[8], gapY = $2[9], restProps = $2[10], rows = $2[11]);
  const t0 = typeof as == "string" ? as : void 0, t1 = useArrayProp(autoRows), t2 = useArrayProp(autoCols), t3 = useArrayProp(autoFlow), t4 = useArrayProp(columns), t5 = useArrayProp(gap), t6 = useArrayProp(gapX), t7 = useArrayProp(gapY), t8 = useArrayProp(rows);
  let t9;
  return $2[12] !== as || $2[13] !== children || $2[14] !== ref || $2[15] !== restProps || $2[16] !== t0 || $2[17] !== t1 || $2[18] !== t2 || $2[19] !== t3 || $2[20] !== t4 || $2[21] !== t5 || $2[22] !== t6 || $2[23] !== t7 || $2[24] !== t8 ? (t9 = (0, import_jsx_runtime12.jsx)(StyledGrid, { "data-as": t0, "data-ui": "Grid", ...restProps, $autoRows: t1, $autoCols: t2, $autoFlow: t3, $columns: t4, $gap: t5, $gapX: t6, $gapY: t7, $rows: t8, forwardedAs: as, ref, children }), $2[12] = as, $2[13] = children, $2[14] = ref, $2[15] = restProps, $2[16] = t0, $2[17] = t1, $2[18] = t2, $2[19] = t3, $2[20] = t4, $2[21] = t5, $2[22] = t6, $2[23] = t7, $2[24] = t8, $2[25] = t9) : t9 = $2[25], t9;
});
Grid.displayName = "ForwardRef(Grid)";
function headingBaseStyle(props) {
  const {
    $accent,
    $muted
  } = props, {
    font
  } = getTheme_v2(props.theme);
  return lt`
    ${$accent && lt`
      color: var(--card-accent-fg-color);
    `}

    ${$muted && lt`
      color: var(--card-muted-fg-color);
    `}

    & code {
      font-family: ${font.code.family};
      border-radius: 1px;
    }

    & a {
      text-decoration: none;
      border-radius: 1px;
      color: var(--card-link-color);
      outline: none;

      @media (hover: hover) {
        &:hover {
          text-decoration: underline;
        }
      }

      &:focus {
        box-shadow:
          0 0 0 1px var(--card-bg-color),
          0 0 0 3px var(--card-focus-ring-color);
      }

      &:focus:not(:focus-visible) {
        box-shadow: none;
      }
    }

    & strong {
      font-weight: ${font.heading.weights.bold};
    }

    & svg {
      /* Certain popular CSS libraries changes the defaults for SVG display */
      /* Make sure SVGs are rendered as inline elements */
      display: inline;
    }

    & [data-sanity-icon] {
      vertical-align: baseline;
    }
  `;
}
var StyledHeading = dt.div.withConfig({
  displayName: "StyledHeading",
  componentId: "sc-137lwim-0"
})(headingBaseStyle, responsiveTextAlignStyle, responsiveHeadingFont);
var Heading = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(22);
  let align, childrenProp, restProps, t0, t1, t2, textOverflow, weight;
  $2[0] !== props ? ({
    accent: t0,
    align,
    children: childrenProp,
    muted: t1,
    size: t2,
    textOverflow,
    weight,
    ...restProps
  } = props, $2[0] = props, $2[1] = align, $2[2] = childrenProp, $2[3] = restProps, $2[4] = t0, $2[5] = t1, $2[6] = t2, $2[7] = textOverflow, $2[8] = weight) : (align = $2[1], childrenProp = $2[2], restProps = $2[3], t0 = $2[4], t1 = $2[5], t2 = $2[6], textOverflow = $2[7], weight = $2[8]);
  const accent = t0 === void 0 ? false : t0, muted = t1 === void 0 ? false : t1, size22 = t2 === void 0 ? 2 : t2;
  let children = childrenProp;
  if (textOverflow === "ellipsis") {
    let t32;
    $2[9] !== children ? (t32 = (0, import_jsx_runtime12.jsx)(SpanWithTextOverflow, { children }), $2[9] = children, $2[10] = t32) : t32 = $2[10], children = t32;
  }
  const t3 = useArrayProp(align), t4 = useArrayProp(size22);
  let t5;
  $2[11] !== children ? (t5 = (0, import_jsx_runtime12.jsx)("span", { children }), $2[11] = children, $2[12] = t5) : t5 = $2[12];
  let t6;
  return $2[13] !== accent || $2[14] !== muted || $2[15] !== ref || $2[16] !== restProps || $2[17] !== t3 || $2[18] !== t4 || $2[19] !== t5 || $2[20] !== weight ? (t6 = (0, import_jsx_runtime12.jsx)(StyledHeading, { "data-ui": "Heading", ...restProps, $accent: accent, $align: t3, $muted: muted, $size: t4, $weight: weight, ref, children: t5 }), $2[13] = accent, $2[14] = muted, $2[15] = ref, $2[16] = restProps, $2[17] = t3, $2[18] = t4, $2[19] = t5, $2[20] = weight, $2[21] = t6) : t6 = $2[21], t6;
});
Heading.displayName = "ForwardRef(Heading)";
function inlineBaseStyle() {
  return {
    lineHeight: 0,
    "&&:not([hidden])": {
      display: "block"
    },
    "& > div": {
      display: "inline-block",
      verticalAlign: "middle"
    }
  };
}
function inlineSpaceStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$space, (spaceIndex) => {
    const _space = rem(spaceIndex === 0.5 ? space[1] / 2 : space[spaceIndex]);
    return {
      margin: `-${_space} 0 0 -${_space}`,
      "& > div": {
        padding: `${_space} 0 0 ${_space}`
      }
    };
  });
}
var StyledInline = dt(Box).withConfig({
  displayName: "StyledInline",
  componentId: "sc-1pkiy6j-0"
})(inlineBaseStyle, inlineSpaceStyle);
var Inline = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(12);
  let as, childrenProp, restProps, space;
  $2[0] !== props ? ({
    as,
    children: childrenProp,
    space,
    ...restProps
  } = props, $2[0] = props, $2[1] = as, $2[2] = childrenProp, $2[3] = restProps, $2[4] = space) : (as = $2[1], childrenProp = $2[2], restProps = $2[3], space = $2[4]);
  let t0, t1;
  $2[5] !== childrenProp ? (t1 = import_react52.Children.map(childrenProp, _temp$4), $2[5] = childrenProp, $2[6] = t1) : t1 = $2[6], t0 = t1;
  const children = t0, t2 = useArrayProp(space);
  let t3;
  return $2[7] !== as || $2[8] !== children || $2[9] !== restProps || $2[10] !== t2 ? (t3 = (0, import_jsx_runtime12.jsx)(StyledInline, { "data-ui": "Inline", ...restProps, $space: t2, forwardedAs: as, ref, children }), $2[7] = as, $2[8] = children, $2[9] = restProps, $2[10] = t2, $2[11] = t3) : t3 = $2[11], t3;
});
Inline.displayName = "ForwardRef(Inline)";
function _temp$4(child) {
  return child && (0, import_jsx_runtime12.jsx)("div", { children: child });
}
function kbdStyle() {
  return lt`
    --card-bg-color: var(--card-kbd-bg-color);
    --card-border-color: var(--card-kbd-border-color);
    --card-fg-color: var(--card-kbd-fg-color);

    box-shadow: inset 0 0 0 1px var(--card-border-color);
    background: var(--card-bg-color);
    font: inherit;

    vertical-align: top;

    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
var StyledKBD = dt.kbd.withConfig({
  displayName: "StyledKBD",
  componentId: "sc-1w7yd8w-0"
})(responsiveRadiusStyle, kbdStyle);
var KBD = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(17);
  let children, restProps, t0, t1, t2;
  $2[0] !== props ? ({
    children,
    fontSize: t0,
    padding: t1,
    radius: t2,
    ...restProps
  } = props, $2[0] = props, $2[1] = children, $2[2] = restProps, $2[3] = t0, $2[4] = t1, $2[5] = t2) : (children = $2[1], restProps = $2[2], t0 = $2[3], t1 = $2[4], t2 = $2[5]);
  const fontSize2 = t0 === void 0 ? 0 : t0, padding = t1 === void 0 ? 1 : t1, t3 = useArrayProp(t2 === void 0 ? 2 : t2);
  let t4;
  $2[6] !== children || $2[7] !== fontSize2 ? (t4 = (0, import_jsx_runtime12.jsx)(Text, { as: "span", size: fontSize2, weight: "semibold", children }), $2[6] = children, $2[7] = fontSize2, $2[8] = t4) : t4 = $2[8];
  let t5;
  $2[9] !== padding || $2[10] !== t4 ? (t5 = (0, import_jsx_runtime12.jsx)(Box, { as: "span", padding, children: t4 }), $2[9] = padding, $2[10] = t4, $2[11] = t5) : t5 = $2[11];
  let t6;
  return $2[12] !== ref || $2[13] !== restProps || $2[14] !== t3 || $2[15] !== t5 ? (t6 = (0, import_jsx_runtime12.jsx)(StyledKBD, { "data-ui": "KBD", ...restProps, $radius: t3, ref, children: t5 }), $2[12] = ref, $2[13] = restProps, $2[14] = t3, $2[15] = t5, $2[16] = t6) : t6 = $2[16], t6;
});
KBD.displayName = "ForwardRef(KBD)";
var origin = {
  name: "@sanity/ui/origin",
  fn({
    middlewareData,
    placement,
    rects
  }) {
    var _a, _b;
    const [side] = placement.split("-"), floatingWidth = rects.floating.width, floatingHeight = rects.floating.height, shiftX = ((_a = middlewareData.shift) == null ? void 0 : _a.x) || 0, shiftY = ((_b = middlewareData.shift) == null ? void 0 : _b.y) || 0;
    if (floatingWidth <= 0 || floatingHeight <= 0)
      return {};
    const isVerticalPlacement = ["bottom", "top"].includes(side), {
      originX,
      originY
    } = isVerticalPlacement ? {
      originX: clamp4(0.5 - shiftX / floatingWidth, 0, 1),
      originY: side === "bottom" ? 0 : 1
    } : {
      originX: side === "left" ? 1 : 0,
      originY: clamp4(0.5 - shiftY / floatingHeight, 0, 1)
    };
    return {
      data: {
        originX,
        originY
      }
    };
  }
};
function clamp4(num, min2, max2) {
  return Math.min(Math.max(num, min2), max2);
}
function moveTowardsLength(movingPoint, targetPoint, amount) {
  const width = targetPoint.x - movingPoint.x, height = targetPoint.y - movingPoint.y, distance2 = Math.sqrt(width * width + height * height);
  return moveTowardsFractional(movingPoint, targetPoint, Math.min(1, amount / distance2));
}
function moveTowardsFractional(movingPoint, targetPoint, fraction) {
  return {
    x: movingPoint.x + (targetPoint.x - movingPoint.x) * fraction,
    y: movingPoint.y + (targetPoint.y - movingPoint.y) * fraction
  };
}
function getRoundedCommands(points) {
  const len = points.length, cmds = [];
  for (let i2 = 0; i2 < len; i2 += 1) {
    const point = points[i2], prevPoint = points[i2 - 1], nextPoint = points[i2 + 1];
    if (prevPoint && point.radius) {
      const curveStart = moveTowardsLength(point, prevPoint, point.radius), curveEnd = moveTowardsLength(point, nextPoint, point.radius), startControl = moveTowardsFractional(curveStart, point, 0.5), endControl = moveTowardsFractional(point, curveEnd, 0.5);
      cmds.push({
        type: "point",
        ...curveStart
      }), cmds.push({
        type: "curve",
        curveEnd,
        startControl,
        endControl
      });
    } else
      cmds.push({
        type: "point",
        ...point
      });
  }
  return cmds;
}
function compileCommands(cmds) {
  return cmds.map((n, idx) => n.type === "point" ? `${idx === 0 ? "M" : "L"} ${n.x} ${n.y}` : n.type === "curve" ? `C ${n.startControl.x} ${n.startControl.y} ${n.endControl.x} ${n.endControl.y} ${n.curveEnd.x} ${n.curveEnd.y}` : "").join(" ");
}
var StyledArrow = dt.div.withConfig({
  displayName: "StyledArrow",
  componentId: "sc-12vzy6c-0"
})(({
  $w: w2
}) => lt`
    position: absolute;
    width: ${w2}px;
    height: ${w2}px;

    :empty + & {
      display: none;
    }

    & > svg {
      display: block;
      line-height: 0;
      transform-origin: ${w2 / 2}px ${w2 / 2}px;
    }

    [data-placement^='top'] > & {
      bottom: -${w2}px;

      & > svg {
        transform: rotate(0);
      }
    }

    [data-placement^='right'] > & {
      left: -${w2}px;

      & > svg {
        transform: rotate(90deg);
      }
    }

    [data-placement^='left'] > & {
      right: -${w2}px;

      & > svg {
        transform: rotate(-90deg);
      }
    }

    [data-placement^='bottom'] > & {
      top: -${w2}px;

      & > svg {
        transform: rotate(180deg);
      }
    }
  `);
var StrokePath = dt.path.withConfig({
  displayName: "StrokePath",
  componentId: "sc-12vzy6c-1"
})`stroke:var(--card-shadow-outline-color);`;
var ShapePath = dt.path.withConfig({
  displayName: "ShapePath",
  componentId: "sc-12vzy6c-2"
})`fill:var(--card-bg-color);`;
var Arrow = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(24);
  let h, restProps, t0, w2;
  $2[0] !== props ? ({
    width: w2,
    height: h,
    radius: t0,
    ...restProps
  } = props, $2[0] = props, $2[1] = h, $2[2] = restProps, $2[3] = t0, $2[4] = w2) : (h = $2[1], restProps = $2[2], t0 = $2[3], w2 = $2[4]);
  const radius = t0 === void 0 ? 0 : t0, {
    card
  } = useTheme_v2(), strokeWidth = card.shadow.outline, center = w2 / 2, points = [{
    x: 0,
    y: 0
  }, {
    x: radius,
    y: 0,
    radius
  }, {
    x: center,
    y: h - 1,
    radius
  }, {
    x: w2 - radius,
    y: 0,
    radius
  }, {
    x: w2,
    y: 0
  }], cmds = getRoundedCommands(points), path = compileCommands(cmds), strokePath = `${path}`, fillPath = `${path} M ${w2} -1 M 0 -1 Z`, t1 = `0 0 ${w2} ${w2}`;
  let t2;
  $2[5] !== strokeWidth || $2[6] !== w2 ? (t2 = (0, import_jsx_runtime12.jsx)("mask", { id: "stroke-mask", children: (0, import_jsx_runtime12.jsx)("rect", { x: 0, y: strokeWidth, width: w2, height: w2, fill: "white" }) }), $2[5] = strokeWidth, $2[6] = w2, $2[7] = t2) : t2 = $2[7];
  const t3 = strokeWidth * 2;
  let t4;
  $2[8] !== strokePath || $2[9] !== t3 ? (t4 = (0, import_jsx_runtime12.jsx)(StrokePath, { d: strokePath, mask: "url(#stroke-mask)", strokeWidth: t3 }), $2[8] = strokePath, $2[9] = t3, $2[10] = t4) : t4 = $2[10];
  let t5;
  $2[11] !== fillPath ? (t5 = (0, import_jsx_runtime12.jsx)(ShapePath, { d: fillPath }), $2[11] = fillPath, $2[12] = t5) : t5 = $2[12];
  let t6;
  $2[13] !== t1 || $2[14] !== t2 || $2[15] !== t4 || $2[16] !== t5 || $2[17] !== w2 ? (t6 = (0, import_jsx_runtime12.jsxs)("svg", { width: w2, height: w2, viewBox: t1, children: [
    t2,
    t4,
    t5
  ] }), $2[13] = t1, $2[14] = t2, $2[15] = t4, $2[16] = t5, $2[17] = w2, $2[18] = t6) : t6 = $2[18];
  let t7;
  return $2[19] !== ref || $2[20] !== restProps || $2[21] !== t6 || $2[22] !== w2 ? (t7 = (0, import_jsx_runtime12.jsx)(StyledArrow, { ...restProps, $w: w2, ref, children: t6 }), $2[19] = ref, $2[20] = restProps, $2[21] = t6, $2[22] = w2, $2[23] = t7) : t7 = $2[23], t7;
});
Arrow.displayName = "ForwardRef(Arrow)";
var BoundaryElementContext = createGlobalScopedContext("@sanity/ui/context/boundaryElement", null);
function BoundaryElementProvider(props) {
  const $2 = (0, import_react_compiler_runtime.c)(5), {
    children,
    element
  } = props;
  let t0, t1;
  $2[0] !== element ? (t1 = {
    version: 0,
    element
  }, $2[0] = element, $2[1] = t1) : t1 = $2[1], t0 = t1;
  const value = t0;
  let t2;
  return $2[2] !== children || $2[3] !== value ? (t2 = (0, import_jsx_runtime12.jsx)(BoundaryElementContext.Provider, { value, children }), $2[2] = children, $2[3] = value, $2[4] = t2) : t2 = $2[4], t2;
}
BoundaryElementProvider.displayName = "BoundaryElementProvider";
function isRecord2(value) {
  return !!(value && typeof value == "object" && !Array.isArray(value));
}
var DEFAULT_VALUE = {
  version: 0,
  element: null
};
function useBoundaryElement() {
  const value = (0, import_react52.useContext)(BoundaryElementContext);
  if (value && (!isRecord2(value) || value.version !== 0))
    throw new Error("useBoundaryElement(): the context value is not compatible");
  return value || DEFAULT_VALUE;
}
function ConditionalWrapper({
  children,
  condition,
  wrapper
}) {
  return condition ? wrapper(children) : children;
}
ConditionalWrapper.displayName = "ConditionalWrapper";
function findMaxBreakpoints(media, width) {
  const ret = [];
  for (let i2 = 0; i2 < media.length; i2 += 1)
    media[i2] > width && ret.push(i2);
  return ret;
}
function findMinBreakpoints(media, width) {
  const ret = [];
  for (let i2 = 0; i2 < media.length; i2 += 1)
    media[i2] <= width && ret.push(i2);
  return ret;
}
var ElementQuery = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(18), theme = useTheme_v2();
  let _media, children, restProps;
  $2[0] !== props ? ({
    children,
    media: _media,
    ...restProps
  } = props, $2[0] = props, $2[1] = _media, $2[2] = children, $2[3] = restProps) : (_media = $2[1], children = $2[2], restProps = $2[3]);
  const media = _media ?? theme.media, [element, setElement] = (0, import_react52.useState)(null), elementSize = useElementSize(element);
  let t0;
  t0 = (elementSize == null ? void 0 : elementSize.border.width) ?? window.innerWidth;
  const width = t0;
  let t1, t2;
  if ($2[4] !== media || $2[5] !== width) {
    const eq = findMaxBreakpoints(media, width);
    t2 = eq.length ? eq.join(" ") : void 0, $2[4] = media, $2[5] = width, $2[6] = t2;
  } else
    t2 = $2[6];
  t1 = t2;
  const max2 = t1;
  let t3, t4;
  if ($2[7] !== media || $2[8] !== width) {
    const eq_0 = findMinBreakpoints(media, width);
    t4 = eq_0.length ? eq_0.join(" ") : void 0, $2[7] = media, $2[8] = width, $2[9] = t4;
  } else
    t4 = $2[9];
  t3 = t4;
  const min2 = t3;
  let t5, t6;
  $2[10] !== element ? (t5 = () => element, t6 = [element], $2[10] = element, $2[11] = t5, $2[12] = t6) : (t5 = $2[11], t6 = $2[12]), (0, import_react52.useImperativeHandle)(forwardedRef, t5, t6);
  let t7;
  return $2[13] !== children || $2[14] !== max2 || $2[15] !== min2 || $2[16] !== restProps ? (t7 = (0, import_jsx_runtime12.jsx)("div", { "data-ui": "ElementQuery", ...restProps, "data-eq-max": max2, "data-eq-min": min2, ref: setElement, children }), $2[13] = children, $2[14] = max2, $2[15] = min2, $2[16] = restProps, $2[17] = t7) : t7 = $2[17], t7;
});
ElementQuery.displayName = "ForwardRef(ElementQuery)";
function getLayerContext(contextValue) {
  if (!isRecord2(contextValue) || contextValue.version !== 0)
    throw new Error("the context value is not compatible");
  if (!contextValue)
    throw new Error("components using `useLayer()` should be wrapped in a <LayerProvider>.");
  if (contextValue.version === 0)
    return contextValue;
  throw new Error("could not get layer context");
}
var LayerContext = createGlobalScopedContext("@sanity/ui/context/layer", null);
function LayerProvider(props) {
  const $2 = (0, import_react_compiler_runtime.c)(19), {
    children,
    zOffset: t0
  } = props, zOffsetProp = t0 === void 0 ? 0 : t0, parentContextValue = (0, import_react52.useContext)(LayerContext);
  let t1;
  $2[0] !== parentContextValue ? (t1 = parentContextValue && getLayerContext(parentContextValue), $2[0] = parentContextValue, $2[1] = t1) : t1 = $2[1];
  const parent = t1, parentRegisterChild = parent == null ? void 0 : parent.registerChild, level = ((parent == null ? void 0 : parent.level) ?? 0) + 1, zOffset = useArrayProp(zOffsetProp), maxMediaIndex = zOffset.length - 1, mediaIndex = Math.min(useMediaIndex(), maxMediaIndex), zIndex = parent ? parent.zIndex + zOffset[mediaIndex] : zOffset[mediaIndex];
  let t2;
  $2[2] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {}, $2[2] = t2) : t2 = $2[2];
  const [, setChildLayers] = (0, import_react52.useState)(t2), [size22, setSize] = (0, import_react52.useState)(0), isTopLayer2 = size22 === 0;
  let t3;
  $2[3] !== parentRegisterChild || $2[4] !== setChildLayers ? (t3 = (childLevel) => {
    const parentDispose = parentRegisterChild == null ? void 0 : parentRegisterChild(childLevel);
    return childLevel !== void 0 ? setChildLayers((state) => {
      const prevLen = state[childLevel] ?? 0, nextState = {
        ...state,
        [childLevel]: prevLen + 1
      };
      return setSize(Object.keys(nextState).length), nextState;
    }) : setSize(_temp$3), () => {
      childLevel !== void 0 ? setChildLayers((state_0) => {
        const nextState_0 = {
          ...state_0
        };
        return nextState_0[childLevel] === 1 ? (delete nextState_0[childLevel], setSize(Object.keys(nextState_0).length)) : nextState_0[childLevel] = nextState_0[childLevel] - 1, nextState_0;
      }) : setSize(_temp2$2), parentDispose == null ? void 0 : parentDispose();
    };
  }, $2[3] = parentRegisterChild, $2[4] = setChildLayers, $2[5] = t3) : t3 = $2[5];
  const registerChild = t3;
  let t4, t5;
  $2[6] !== level || $2[7] !== parentRegisterChild ? (t4 = () => parentRegisterChild == null ? void 0 : parentRegisterChild(level), t5 = [level, parentRegisterChild], $2[6] = level, $2[7] = parentRegisterChild, $2[8] = t4, $2[9] = t5) : (t4 = $2[8], t5 = $2[9]), (0, import_react52.useEffect)(t4, t5);
  let t6, t7;
  $2[10] !== isTopLayer2 || $2[11] !== level || $2[12] !== registerChild || $2[13] !== size22 || $2[14] !== zIndex ? (t7 = {
    version: 0,
    isTopLayer: isTopLayer2,
    level,
    registerChild,
    size: size22,
    zIndex
  }, $2[10] = isTopLayer2, $2[11] = level, $2[12] = registerChild, $2[13] = size22, $2[14] = zIndex, $2[15] = t7) : t7 = $2[15], t6 = t7;
  const value = t6;
  let t8;
  return $2[16] !== children || $2[17] !== value ? (t8 = (0, import_jsx_runtime12.jsx)(LayerContext.Provider, { value, children }), $2[16] = children, $2[17] = value, $2[18] = t8) : t8 = $2[18], t8;
}
function _temp2$2(v_0) {
  return v_0 - 1;
}
function _temp$3(v2) {
  return v2 + 1;
}
LayerProvider.displayName = "LayerProvider";
function useLayer() {
  const $2 = (0, import_react_compiler_runtime.c)(2), value = (0, import_react52.useContext)(LayerContext);
  if (!value)
    throw new Error("useLayer(): missing context value");
  try {
    let t1;
    return $2[0] !== value ? (t1 = getLayerContext(value), $2[0] = value, $2[1] = t1) : t1 = $2[1], t1;
  } catch (t0) {
    const err = t0;
    throw err instanceof Error ? new Error(`useLayer(): ${err.message}`) : new Error(`useLayer(): ${err}`);
  }
}
var StyledLayer = dt.div.withConfig({
  displayName: "StyledLayer",
  componentId: "sc-16kojrv-0"
})({
  position: "relative"
});
var LayerChildren = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(22);
  let children, onActivate, onFocus, restProps, t0;
  $2[0] !== props ? ({
    children,
    onActivate,
    onFocus,
    style: t0,
    ...restProps
  } = props, $2[0] = props, $2[1] = children, $2[2] = onActivate, $2[3] = onFocus, $2[4] = restProps, $2[5] = t0) : (children = $2[1], onActivate = $2[2], onFocus = $2[3], restProps = $2[4], t0 = $2[5]);
  const style = t0 === void 0 ? EMPTY_RECORD : t0, {
    zIndex,
    isTopLayer: isTopLayer2
  } = useLayer(), lastFocusedRef = (0, import_react52.useRef)(null), ref = (0, import_react52.useRef)(null), isTopLayerRef = (0, import_react52.useRef)(isTopLayer2);
  let t1;
  $2[6] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => ref.current, $2[6] = t1) : t1 = $2[6], (0, import_react52.useImperativeHandle)(forwardedRef, t1);
  let t2, t3;
  $2[7] !== isTopLayer2 || $2[8] !== onActivate ? (t2 = () => {
    isTopLayerRef.current !== isTopLayer2 && isTopLayer2 && (onActivate == null ? void 0 : onActivate({
      activeElement: lastFocusedRef.current
    })), isTopLayerRef.current = isTopLayer2;
  }, t3 = [isTopLayer2, onActivate], $2[7] = isTopLayer2, $2[8] = onActivate, $2[9] = t2, $2[10] = t3) : (t2 = $2[9], t3 = $2[10]), (0, import_react52.useEffect)(t2, t3);
  let t4;
  $2[11] !== isTopLayer2 || $2[12] !== onFocus ? (t4 = (event) => {
    onFocus == null ? void 0 : onFocus(event);
    const rootElement = ref.current, target = document.activeElement;
    !isTopLayer2 || !rootElement || !target || isHTMLElement3(target) && containsOrEqualsElement(rootElement, target) && (lastFocusedRef.current = target);
  }, $2[11] = isTopLayer2, $2[12] = onFocus, $2[13] = t4) : t4 = $2[13];
  const handleFocus = t4;
  let t5;
  $2[14] !== style || $2[15] !== zIndex ? (t5 = {
    ...style,
    zIndex
  }, $2[14] = style, $2[15] = zIndex, $2[16] = t5) : t5 = $2[16];
  let t6;
  return $2[17] !== children || $2[18] !== handleFocus || $2[19] !== restProps || $2[20] !== t5 ? (t6 = (0, import_jsx_runtime12.jsx)(StyledLayer, { ...restProps, "data-ui": "Layer", onFocus: handleFocus, ref, style: t5, children }), $2[17] = children, $2[18] = handleFocus, $2[19] = restProps, $2[20] = t5, $2[21] = t6) : t6 = $2[21], t6;
});
var Layer = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(11);
  let children, restProps, t0;
  $2[0] !== props ? ({
    children,
    zOffset: t0,
    ...restProps
  } = props, $2[0] = props, $2[1] = children, $2[2] = restProps, $2[3] = t0) : (children = $2[1], restProps = $2[2], t0 = $2[3]);
  const zOffset = t0 === void 0 ? 1 : t0;
  let t1;
  $2[4] !== children || $2[5] !== ref || $2[6] !== restProps ? (t1 = (0, import_jsx_runtime12.jsx)(LayerChildren, { ...restProps, ref, children }), $2[4] = children, $2[5] = ref, $2[6] = restProps, $2[7] = t1) : t1 = $2[7];
  let t2;
  return $2[8] !== t1 || $2[9] !== zOffset ? (t2 = (0, import_jsx_runtime12.jsx)(LayerProvider, { zOffset, children: t1 }), $2[8] = t1, $2[9] = zOffset, $2[10] = t2) : t2 = $2[10], t2;
});
Layer.displayName = "ForwardRef(Layer)";
var key = "@sanity/ui/context/portal";
var elementKey = Symbol.for(`${key}/element`);
globalScope[elementKey] = null;
var defaultContextValue = {
  version: 0,
  boundaryElement: null,
  get element() {
    return typeof document > "u" ? null : (globalScope[elementKey] || (globalScope[elementKey] = document.createElement("div"), globalScope[elementKey].setAttribute("data-portal", ""), document.body.appendChild(globalScope[elementKey])), globalScope[elementKey]);
  }
};
var PortalContext = createGlobalScopedContext(key, defaultContextValue);
function usePortal() {
  const value = (0, import_react52.useContext)(PortalContext);
  if (!value)
    throw new Error("usePortal(): missing context value");
  if (!isRecord2(value) || value.version !== 0)
    throw new Error("usePortal(): the context value is not compatible");
  return value;
}
function Portal(props) {
  var _a;
  const $2 = (0, import_react_compiler_runtime.c)(3), {
    children,
    __unstable_name: name
  } = props, portal = usePortal(), portalElement = (name ? portal.elements && portal.elements[name] : portal.element) || ((_a = portal.elements) == null ? void 0 : _a.default);
  if (!portalElement)
    return null;
  let t0;
  return $2[0] !== children || $2[1] !== portalElement ? (t0 = (0, import_react_dom2.createPortal)(children, portalElement), $2[0] = children, $2[1] = portalElement, $2[2] = t0) : t0 = $2[2], t0;
}
Portal.displayName = "Portal";
function PortalProvider(props) {
  const $2 = (0, import_react_compiler_runtime.c)(7), {
    boundaryElement,
    children,
    element,
    __unstable_elements: elementsProp
  } = props, elements = useUnique(elementsProp), fallbackElement = (0, import_react52.useSyncExternalStore)(emptySubscribe, _temp$2, _temp2$1);
  let t0;
  const t1 = boundaryElement || null, t2 = element || fallbackElement;
  let t3;
  $2[0] !== elements || $2[1] !== t1 || $2[2] !== t2 ? (t3 = {
    version: 0,
    boundaryElement: t1,
    element: t2,
    elements
  }, $2[0] = elements, $2[1] = t1, $2[2] = t2, $2[3] = t3) : t3 = $2[3], t0 = t3;
  const value = t0;
  let t4;
  return $2[4] !== children || $2[5] !== value ? (t4 = (0, import_jsx_runtime12.jsx)(PortalContext.Provider, { value, children }), $2[4] = children, $2[5] = value, $2[6] = t4) : t4 = $2[6], t4;
}
function _temp2$1() {
  return null;
}
function _temp$2() {
  return document.body;
}
PortalProvider.displayName = "PortalProvider";
var emptySubscribe = () => () => {
};
function useUnique(value) {
  const valueRef = (0, import_react52.useRef)(value);
  return _isEqual(valueRef.current, value) || (valueRef.current = value), valueRef.current;
}
function _isEqual(objA, objB) {
  if (!objA || !objB)
    return objA === objB;
  const keysA = Object.keys(objA), keysB = Object.keys(objB);
  return keysA.length !== keysB.length ? false : keysA.every((key2) => objA[key2] === objB[key2]);
}
var StyledSrOnly = dt.div.withConfig({
  displayName: "StyledSrOnly",
  componentId: "sc-mubr0c-0"
})`display:block;width:0;height:0;position:absolute;overflow:hidden;overflow:clip;`;
var SrOnly = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(4), {
    as,
    children
  } = props;
  let t0;
  return $2[0] !== as || $2[1] !== children || $2[2] !== ref ? (t0 = (0, import_jsx_runtime12.jsx)(StyledSrOnly, { "aria-hidden": true, as, "data-ui": "SrOnly", ref, children }), $2[0] = as, $2[1] = children, $2[2] = ref, $2[3] = t0) : t0 = $2[3], t0;
});
SrOnly.displayName = "ForwardRef(SrOnly)";
var StyledVirtualList = dt.div.withConfig({
  displayName: "StyledVirtualList",
  componentId: "sc-dlqsj4-0"
})`position:relative;`;
var ItemWrapper = dt.div.withConfig({
  displayName: "ItemWrapper",
  componentId: "sc-dlqsj4-1"
})`position:absolute;left:0;right:0;`;
var VirtualList = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(56);
  let getItemKey, onChange, renderItem, restProps, t0, t1, t2;
  $2[0] !== props ? ({
    as: t0,
    gap: t1,
    getItemKey,
    items: t2,
    onChange,
    renderItem,
    ...restProps
  } = props, $2[0] = props, $2[1] = getItemKey, $2[2] = onChange, $2[3] = renderItem, $2[4] = restProps, $2[5] = t0, $2[6] = t1, $2[7] = t2) : (getItemKey = $2[1], onChange = $2[2], renderItem = $2[3], restProps = $2[4], t0 = $2[5], t1 = $2[6], t2 = $2[7]);
  const as = t0 === void 0 ? "div" : t0, gap = t1 === void 0 ? 0 : t1;
  let t3;
  $2[8] !== t2 ? (t3 = t2 === void 0 ? [] : t2, $2[8] = t2, $2[9] = t3) : t3 = $2[9];
  const items = t3, {
    space
  } = useTheme_v2(), ref = (0, import_react52.useRef)(null), wrapperRef = (0, import_react52.useRef)(null), [scrollTop, setScrollTop] = (0, import_react52.useState)(0), [scrollHeight, setScrollHeight] = (0, import_react52.useState)(0), [itemHeight, setItemHeight] = (0, import_react52.useState)(-1);
  let t4;
  $2[10] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => ref.current, $2[10] = t4) : t4 = $2[10], (0, import_react52.useImperativeHandle)(forwardedRef, t4);
  let t5;
  $2[11] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => {
    if (!wrapperRef.current)
      return;
    const firstElement = wrapperRef.current.firstChild;
    firstElement instanceof HTMLElement && setItemHeight(firstElement.offsetHeight);
  }, $2[11] = t5) : t5 = $2[11];
  let t6;
  $2[12] !== renderItem ? (t6 = [renderItem], $2[12] = renderItem, $2[13] = t6) : t6 = $2[13], (0, import_react52.useEffect)(t5, t6);
  let t7, t8;
  $2[14] === Symbol.for("react.memo_cache_sentinel") ? (t7 = () => {
    if (!ref.current)
      return;
    const scrollEl = findScrollable(ref.current.parentNode);
    if (scrollEl) {
      if (!(scrollEl instanceof HTMLElement))
        return;
      const handleScroll = () => {
        setScrollTop(scrollEl.scrollTop);
      };
      scrollEl.addEventListener("scroll", handleScroll, {
        passive: true
      });
      const ro = new _ResizeObserver((entries) => {
        setScrollHeight(entries[0].contentRect.height);
      });
      return ro.observe(scrollEl), handleScroll(), () => {
        scrollEl.removeEventListener("scroll", handleScroll), ro.unobserve(scrollEl), ro.disconnect();
      };
    }
    const handleScroll_0 = () => {
      setScrollTop(window.scrollY);
    }, handleResize = () => {
      setScrollHeight(window.innerHeight);
    };
    return window.addEventListener("scroll", handleScroll_0, {
      passive: true
    }), window.addEventListener("resize", handleResize), setScrollHeight(window.innerHeight), handleScroll_0(), () => {
      window.removeEventListener("scroll", handleScroll_0), window.removeEventListener("resize", handleResize);
    };
  }, t8 = [], $2[14] = t7, $2[15] = t8) : (t7 = $2[14], t8 = $2[15]), (0, import_react52.useEffect)(t7, t8);
  const len = items.length, height = itemHeight ? len * (itemHeight + space[gap]) - space[gap] : 0, fromIndex = height ? Math.max(Math.floor(scrollTop / height * len) - 2, 0) : 0, toIndex = height ? Math.ceil((scrollTop + scrollHeight) / height * len) + 1 : 0;
  let t10, t9;
  $2[16] !== fromIndex || $2[17] !== gap || $2[18] !== itemHeight || $2[19] !== onChange || $2[20] !== scrollHeight || $2[21] !== scrollTop || $2[22] !== space || $2[23] !== toIndex ? (t9 = () => {
    onChange && onChange({
      fromIndex,
      gap: space[gap],
      itemHeight,
      scrollHeight,
      scrollTop,
      toIndex
    });
  }, t10 = [fromIndex, gap, itemHeight, onChange, scrollHeight, scrollTop, space, toIndex], $2[16] = fromIndex, $2[17] = gap, $2[18] = itemHeight, $2[19] = onChange, $2[20] = scrollHeight, $2[21] = scrollTop, $2[22] = space, $2[23] = toIndex, $2[24] = t10, $2[25] = t9) : (t10 = $2[24], t9 = $2[25]), (0, import_react52.useEffect)(t9, t10);
  let t11;
  bb0: {
    if (!renderItem || items.length === 0) {
      t11 = null;
      break bb0;
    }
    if (itemHeight === -1) {
      let t123;
      $2[26] !== items[0] || $2[27] !== renderItem ? (t123 = renderItem(items[0]), $2[26] = items[0], $2[27] = renderItem, $2[28] = t123) : t123 = $2[28];
      let t132;
      $2[29] !== t123 ? (t132 = [(0, import_jsx_runtime12.jsx)(ItemWrapper, { children: t123 }, 0)], $2[29] = t123, $2[30] = t132) : t132 = $2[30], t11 = t132;
      break bb0;
    }
    let t122;
    if ($2[31] !== fromIndex || $2[32] !== gap || $2[33] !== getItemKey || $2[34] !== itemHeight || $2[35] !== items || $2[36] !== renderItem || $2[37] !== space || $2[38] !== toIndex) {
      let t132;
      $2[40] !== fromIndex || $2[41] !== gap || $2[42] !== getItemKey || $2[43] !== itemHeight || $2[44] !== renderItem || $2[45] !== space ? (t132 = (item, _itemIndex) => {
        const itemIndex = fromIndex + _itemIndex, node2 = renderItem(item), key2 = getItemKey ? getItemKey(item, itemIndex) : itemIndex;
        return (0, import_jsx_runtime12.jsx)(ItemWrapper, { style: {
          top: itemIndex * (itemHeight + space[gap])
        }, children: node2 }, key2);
      }, $2[40] = fromIndex, $2[41] = gap, $2[42] = getItemKey, $2[43] = itemHeight, $2[44] = renderItem, $2[45] = space, $2[46] = t132) : t132 = $2[46], t122 = items.slice(fromIndex, toIndex).map(t132), $2[31] = fromIndex, $2[32] = gap, $2[33] = getItemKey, $2[34] = itemHeight, $2[35] = items, $2[36] = renderItem, $2[37] = space, $2[38] = toIndex, $2[39] = t122;
    } else
      t122 = $2[39];
    t11 = t122;
  }
  const children = t11;
  let t12, t13;
  $2[47] !== height ? (t13 = {
    height
  }, $2[47] = height, $2[48] = t13) : t13 = $2[48], t12 = t13;
  const wrapperStyle = t12;
  let t14;
  $2[49] !== children || $2[50] !== wrapperStyle ? (t14 = (0, import_jsx_runtime12.jsx)("div", { ref: wrapperRef, style: wrapperStyle, children }), $2[49] = children, $2[50] = wrapperStyle, $2[51] = t14) : t14 = $2[51];
  let t15;
  return $2[52] !== as || $2[53] !== restProps || $2[54] !== t14 ? (t15 = (0, import_jsx_runtime12.jsx)(StyledVirtualList, { as, "data-ui": "VirtualList", ...restProps, ref, children: t14 }), $2[52] = as, $2[53] = restProps, $2[54] = t14, $2[55] = t15) : t15 = $2[55], t15;
});
VirtualList.displayName = "ForwardRef(VirtualList)";
function findScrollable(parentNode) {
  let _scrollEl = parentNode;
  for (; _scrollEl && !_isScrollable(_scrollEl); )
    _scrollEl = _scrollEl.parentNode;
  return _scrollEl;
}
function getElementRef(element) {
  var _a, _b;
  let getter = (_a = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  return mayWarn ? element.ref : (getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get, mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning, mayWarn ? element.props.ref : element.props.ref || element.ref);
}
var DEFAULT_POPOVER_DISTANCE = 4;
var DEFAULT_POPOVER_PADDING = 4;
var DEFAULT_POPOVER_ARROW_WIDTH = 19;
var DEFAULT_POPOVER_ARROW_HEIGHT = 8;
var DEFAULT_POPOVER_ARROW_RADIUS = 2;
var DEFAULT_POPOVER_MARGINS = [0, 0, 0, 0];
var DEFAULT_FALLBACK_PLACEMENTS$1 = {
  top: ["bottom", "left", "right"],
  "top-start": ["bottom-start", "left-start", "right-start"],
  "top-end": ["bottom-end", "left-end", "right-end"],
  bottom: ["top", "left", "right"],
  "bottom-start": ["top-start", "left-start", "right-start"],
  "bottom-end": ["top-end", "left-end", "right-end"],
  left: ["right", "top", "bottom"],
  "left-start": ["right-start", "top-start", "bottom-start"],
  "left-end": ["right-end", "top-end", "bottom-end"],
  right: ["left", "top", "bottom"],
  "right-start": ["left-start", "top-start", "bottom-start"],
  "right-end": ["left-end", "top-end", "bottom-end"]
};
function size4(options) {
  const {
    apply,
    margins,
    padding = 0
  } = options;
  return {
    name: "@sanity/ui/size",
    async fn(args) {
      const {
        elements,
        placement,
        platform: platform2,
        rects
      } = args, {
        floating,
        reference
      } = rects, overflow = await detectOverflow2(args, {
        altBoundary: true,
        boundary: options.boundaryElement || void 0,
        elementContext: "floating",
        padding,
        rootBoundary: "viewport"
      });
      let maxWidth = 1 / 0, maxHeight = 1 / 0;
      const floatingW = floating.width, floatingH = floating.height;
      placement.includes("top") && (maxWidth = floatingW - (overflow.left + overflow.right), maxHeight = floatingH - overflow.top), placement.includes("right") && (maxWidth = floatingW - overflow.right, maxHeight = floatingH - (overflow.top + overflow.bottom)), placement.includes("bottom") && (maxWidth = floatingW - (overflow.left + overflow.right), maxHeight = floatingH - overflow.bottom), placement.includes("left") && (maxWidth = floatingW - overflow.left, maxHeight = floatingH - (overflow.top + overflow.bottom)), apply({
        availableWidth: maxWidth - margins[1] - margins[3],
        availableHeight: maxHeight - margins[0] - margins[2],
        elements,
        referenceWidth: reference.width - margins[1] - margins[3]
      });
      const nextDimensions = await platform2.getDimensions(elements.floating), targetH = nextDimensions.height, targetW = nextDimensions.width;
      return floatingW !== targetW || floatingH !== targetH ? {
        reset: {
          rects: true
        }
      } : {};
    }
  };
}
function calcCurrentWidth(params) {
  const {
    container: container2,
    mediaIndex,
    width
  } = params, w2 = width[mediaIndex], currentWidth = w2 === void 0 ? width[width.length - 1] : w2;
  return typeof currentWidth == "number" ? container2[currentWidth] : void 0;
}
function calcMaxWidth(params) {
  const {
    boundaryWidth,
    currentWidth
  } = params;
  if (!(currentWidth === void 0 && boundaryWidth === void 0))
    return Math.min(currentWidth ?? 1 / 0, (boundaryWidth || 1 / 0) - DEFAULT_POPOVER_PADDING * 2);
}
var MotionCard$1 = dt(motion.create(Card)).withConfig({
  displayName: "MotionCard",
  componentId: "sc-ihg31s-0"
})`&:not([hidden]){display:flex;}flex-direction:column;width:max-content;min-width:min-content;will-change:transform;`;
var MotionFlex = dt(motion.create(Flex)).withConfig({
  displayName: "MotionFlex",
  componentId: "sc-ihg31s-1"
})`will-change:opacity;`;
var PopoverCard = (0, import_react52.memo)((0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(66);
  let animate2, arrow22, arrowRef, arrowX, arrowY, children, marginsProp, originX, originY, overflow, padding, placement, radius, restProps, scheme, shadow, strategy, style, tone, width, xProp, yProp;
  $2[0] !== props ? ({
    __unstable_margins: marginsProp,
    animate: animate2,
    arrow: arrow22,
    arrowRef,
    arrowX,
    arrowY,
    children,
    padding,
    placement,
    originX,
    originY,
    overflow,
    radius,
    scheme,
    shadow,
    strategy,
    style,
    tone,
    width,
    x: xProp,
    y: yProp,
    ...restProps
  } = props, $2[0] = props, $2[1] = animate2, $2[2] = arrow22, $2[3] = arrowRef, $2[4] = arrowX, $2[5] = arrowY, $2[6] = children, $2[7] = marginsProp, $2[8] = originX, $2[9] = originY, $2[10] = overflow, $2[11] = padding, $2[12] = placement, $2[13] = radius, $2[14] = restProps, $2[15] = scheme, $2[16] = shadow, $2[17] = strategy, $2[18] = style, $2[19] = tone, $2[20] = width, $2[21] = xProp, $2[22] = yProp) : (animate2 = $2[1], arrow22 = $2[2], arrowRef = $2[3], arrowX = $2[4], arrowY = $2[5], children = $2[6], marginsProp = $2[7], originX = $2[8], originY = $2[9], overflow = $2[10], padding = $2[11], placement = $2[12], radius = $2[13], restProps = $2[14], scheme = $2[15], shadow = $2[16], strategy = $2[17], style = $2[18], tone = $2[19], width = $2[20], xProp = $2[21], yProp = $2[22]);
  const {
    zIndex
  } = useLayer();
  let t0;
  t0 = marginsProp || DEFAULT_POPOVER_MARGINS;
  const margins = t0, x2 = (xProp ?? 0) + margins[3], y2 = (yProp ?? 0) + margins[0];
  let t1;
  const t2 = animate2 ? "transform" : void 0;
  let t3;
  $2[23] !== originX || $2[24] !== originY || $2[25] !== strategy || $2[26] !== style || $2[27] !== t2 || $2[28] !== width || $2[29] !== x2 || $2[30] !== y2 || $2[31] !== zIndex ? (t3 = {
    left: x2,
    originX,
    originY,
    position: strategy,
    top: y2,
    width,
    zIndex,
    willChange: t2,
    ...style
  }, $2[23] = originX, $2[24] = originY, $2[25] = strategy, $2[26] = style, $2[27] = t2, $2[28] = width, $2[29] = x2, $2[30] = y2, $2[31] = zIndex, $2[32] = t3) : t3 = $2[32], t1 = t3;
  const rootStyle2 = t1;
  let t4;
  const t5 = arrowX !== null ? arrowX : void 0, t6 = arrowY !== null ? arrowY : void 0;
  let t7;
  $2[33] !== t5 || $2[34] !== t6 ? (t7 = {
    left: t5,
    top: t6,
    right: void 0,
    bottom: void 0
  }, $2[33] = t5, $2[34] = t6, $2[35] = t7) : t7 = $2[35], t4 = t7;
  const arrowStyle = t4, t8 = restProps;
  let t9;
  $2[36] !== animate2 ? (t9 = animate2 ? ["hidden", "initial"] : void 0, $2[36] = animate2, $2[37] = t9) : t9 = $2[37];
  let t10;
  $2[38] !== animate2 ? (t10 = animate2 ? ["visible", "scaleIn"] : void 0, $2[38] = animate2, $2[39] = t10) : t10 = $2[39];
  let t11;
  $2[40] !== animate2 ? (t11 = animate2 ? ["hidden", "scaleOut"] : void 0, $2[40] = animate2, $2[41] = t11) : t11 = $2[41];
  let t12;
  $2[42] !== children || $2[43] !== padding ? (t12 = (0, import_jsx_runtime12.jsx)(Flex, { direction: "column", flex: 1, padding, children }), $2[42] = children, $2[43] = padding, $2[44] = t12) : t12 = $2[44];
  let t13;
  $2[45] !== overflow || $2[46] !== t12 ? (t13 = (0, import_jsx_runtime12.jsx)(MotionFlex, { "data-ui": "Popover__wrapper", direction: "column", flex: 1, overflow, variants: POPOVER_MOTION_PROPS.children, transition: POPOVER_MOTION_PROPS.transition, children: t12 }), $2[45] = overflow, $2[46] = t12, $2[47] = t13) : t13 = $2[47];
  let t14;
  $2[48] !== arrow22 || $2[49] !== arrowRef || $2[50] !== arrowStyle ? (t14 = arrow22 && (0, import_jsx_runtime12.jsx)(Arrow, { ref: arrowRef, style: arrowStyle, width: DEFAULT_POPOVER_ARROW_WIDTH, height: DEFAULT_POPOVER_ARROW_HEIGHT, radius: DEFAULT_POPOVER_ARROW_RADIUS }), $2[48] = arrow22, $2[49] = arrowRef, $2[50] = arrowStyle, $2[51] = t14) : t14 = $2[51];
  let t15;
  return $2[52] !== placement || $2[53] !== radius || $2[54] !== ref || $2[55] !== rootStyle2 || $2[56] !== scheme || $2[57] !== shadow || $2[58] !== t10 || $2[59] !== t11 || $2[60] !== t13 || $2[61] !== t14 || $2[62] !== t8 || $2[63] !== t9 || $2[64] !== tone ? (t15 = (0, import_jsx_runtime12.jsxs)(MotionCard$1, { "data-ui": "Popover", ...t8, "data-placement": placement, radius, ref, scheme, shadow, sizing: "border", style: rootStyle2, tone, variants: POPOVER_MOTION_PROPS.card, transition: POPOVER_MOTION_PROPS.transition, initial: t9, animate: t10, exit: t11, children: [
    t13,
    t14
  ] }), $2[52] = placement, $2[53] = radius, $2[54] = ref, $2[55] = rootStyle2, $2[56] = scheme, $2[57] = shadow, $2[58] = t10, $2[59] = t11, $2[60] = t13, $2[61] = t14, $2[62] = t8, $2[63] = t9, $2[64] = tone, $2[65] = t15) : t15 = $2[65], t15;
}));
PopoverCard.displayName = "Memo(ForwardRef(PopoverCard))";
var ViewportOverlay = () => {
  const $2 = (0, import_react_compiler_runtime.c)(2), {
    zIndex
  } = useLayer();
  let t0;
  return $2[0] !== zIndex ? (t0 = (0, import_jsx_runtime12.jsx)("div", { style: {
    height: "100vh",
    inset: 0,
    position: "fixed",
    width: "100vw",
    zIndex
  } }), $2[0] = zIndex, $2[1] = t0) : t0 = $2[1], t0;
};
var Popover = (0, import_react52.memo)((0, import_react52.forwardRef)(function(props, forwardedRef) {
  var _a, _b, _c, _d, _e2, _f;
  const {
    container: container2,
    layer
  } = useTheme_v2(), boundaryElementContext = useBoundaryElement(), {
    __unstable_margins: margins = DEFAULT_POPOVER_MARGINS,
    animate: _animate = false,
    arrow: arrowProp = false,
    boundaryElement = boundaryElementContext.element,
    children: childProp,
    constrainSize = false,
    content: content2,
    disabled,
    fallbackPlacements = props.fallbackPlacements ?? DEFAULT_FALLBACK_PLACEMENTS$1[props.placement ?? "bottom"],
    matchReferenceWidth,
    floatingBoundary = props.boundaryElement ?? boundaryElementContext.element,
    modal,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onActivate,
    open,
    overflow = "hidden",
    padding: paddingProp,
    placement: placementProp = "bottom",
    portal,
    preventOverflow = true,
    radius: radiusProp = 3,
    referenceBoundary = props.boundaryElement ?? boundaryElementContext.element,
    referenceElement,
    scheme,
    shadow: shadowProp = 3,
    tone = "inherit",
    width: widthProp = "auto",
    zOffset: zOffsetProp = layer.popover.zOffset,
    updateRef,
    ...restProps
  } = props, animate2 = usePrefersReducedMotion() ? false : _animate, boundarySize = (_a = useElementSize(boundaryElement)) == null ? void 0 : _a.border, padding = useArrayProp(paddingProp), radius = useArrayProp(radiusProp), shadow = useArrayProp(shadowProp), widthArrayProp = useArrayProp(widthProp), zOffset = useArrayProp(zOffsetProp), ref = (0, import_react52.useRef)(null), arrowRef = (0, import_react52.useRef)(null), rootBoundary = "viewport";
  (0, import_react52.useImperativeHandle)(forwardedRef, () => ref.current);
  const mediaIndex = useMediaIndex(), boundaryWidth = constrainSize || preventOverflow ? boundarySize == null ? void 0 : boundarySize.width : void 0, width = calcCurrentWidth({
    container: container2,
    mediaIndex,
    width: widthArrayProp
  }), widthRef = (0, import_react52.useRef)(width);
  (0, import_react52.useEffect)(() => {
    widthRef.current = width;
  }, [width]);
  const maxWidth = calcMaxWidth({
    boundaryWidth,
    currentWidth: width
  }), maxWidthRef = (0, import_react52.useRef)(maxWidth);
  (0, import_react52.useEffect)(() => {
    maxWidthRef.current = maxWidth;
  }, [maxWidth]);
  const referenceWidthRef = (0, import_react52.useRef)(void 0);
  (0, import_react52.useEffect)(() => {
    const floatingElement = ref.current;
    if (!open || !floatingElement) return;
    const referenceWidth = referenceWidthRef.current;
    matchReferenceWidth ? referenceWidth !== void 0 && (floatingElement.style.width = `${referenceWidth}px`) : width !== void 0 && (floatingElement.style.width = `${width}px`), typeof maxWidth == "number" && (floatingElement.style.maxWidth = `${maxWidth}px`);
  }, [width, matchReferenceWidth, maxWidth, open]);
  const middleware2 = (0, import_react52.useMemo)(() => {
    const ret = [];
    return (constrainSize || preventOverflow) && ret.push(flip3({
      boundary: floatingBoundary || void 0,
      fallbackPlacements,
      padding: DEFAULT_POPOVER_PADDING,
      rootBoundary
    })), ret.push(offset3({
      mainAxis: DEFAULT_POPOVER_DISTANCE
    })), (constrainSize || matchReferenceWidth) && ret.push(size4({
      apply({
        availableWidth,
        availableHeight,
        elements,
        referenceWidth: referenceWidth_0
      }) {
        referenceWidthRef.current = referenceWidth_0;
        const _currentWidth = widthRef.current, _maxWidth = maxWidthRef.current;
        matchReferenceWidth ? elements.floating.style.width = `${referenceWidth_0}px` : _currentWidth !== void 0 && (elements.floating.style.width = `${_currentWidth}px`), constrainSize && (elements.floating.style.maxWidth = `${Math.min(availableWidth, _maxWidth ?? 1 / 0)}px`, elements.floating.style.maxHeight = `${availableHeight}px`);
      },
      boundaryElement: floatingBoundary || void 0,
      margins,
      padding: DEFAULT_POPOVER_PADDING
    })), preventOverflow && ret.push(shift3({
      boundary: floatingBoundary || void 0,
      rootBoundary,
      padding: DEFAULT_POPOVER_PADDING
    })), arrowProp && ret.push(arrow3({
      element: arrowRef,
      padding: DEFAULT_POPOVER_PADDING
    })), animate2 && ret.push(origin), ret.push(hide3({
      boundary: referenceBoundary || void 0,
      padding: DEFAULT_POPOVER_PADDING,
      strategy: "referenceHidden"
    })), ret;
  }, [animate2, arrowProp, constrainSize, fallbackPlacements, floatingBoundary, margins, matchReferenceWidth, preventOverflow, referenceBoundary]), {
    x: x2,
    y: y2,
    middlewareData,
    placement,
    refs,
    strategy,
    update
  } = useFloating({
    middleware: middleware2,
    placement: placementProp,
    whileElementsMounted: autoUpdate,
    elements: referenceElement ? {
      reference: referenceElement
    } : void 0
  }), referenceHidden = (_b = middlewareData.hide) == null ? void 0 : _b.referenceHidden, arrowX = (_c = middlewareData.arrow) == null ? void 0 : _c.x, arrowY = (_d = middlewareData.arrow) == null ? void 0 : _d.y, originX = (_e2 = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _e2.originX, originY = (_f = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _f.originY, setArrow = (0, import_react52.useCallback)((arrowEl) => {
    arrowRef.current = arrowEl;
  }, []), setFloating = (0, import_react52.useCallback)((node2) => {
    ref.current = node2, refs.setFloating(node2);
  }, [refs]), setReference = (0, import_react52.useCallback)((node_0) => {
    refs.setReference(node_0);
    const childRef = getElementRef(childProp);
    typeof childRef == "function" ? childRef(node_0) : childRef && (childRef.current = node_0);
  }, [childProp, refs]), child = (0, import_react52.useMemo)(() => referenceElement ? childProp : childProp ? (0, import_react52.cloneElement)(childProp, {
    ref: setReference
  }) : null, [childProp, referenceElement, setReference]);
  if ((0, import_react52.useEffect)(() => {
    updateRef && (typeof updateRef == "function" ? updateRef(update) : updateRef && (updateRef.current = update));
  }, [update, updateRef]), disabled)
    return childProp || (0, import_jsx_runtime12.jsx)(import_jsx_runtime12.Fragment, {});
  const popover = (0, import_jsx_runtime12.jsxs)(LayerProvider, { zOffset, children: [
    modal && (0, import_jsx_runtime12.jsx)(ViewportOverlay, {}),
    (0, import_jsx_runtime12.jsx)(PopoverCard, { ...restProps, __unstable_margins: margins, animate: animate2, arrow: arrowProp, arrowRef: setArrow, arrowX, arrowY, hidden: referenceHidden, overflow, padding, placement, radius, ref: setFloating, scheme, shadow, originX, originY, strategy, tone, width: matchReferenceWidth ? referenceWidthRef.current : width, x: x2, y: y2, children: content2 })
  ] }), children = open && (portal ? (0, import_jsx_runtime12.jsx)(Portal, { __unstable_name: typeof portal == "string" ? portal : void 0, children: popover }) : popover);
  return (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
    animate2 ? (0, import_jsx_runtime12.jsx)(AnimatePresence, { children }) : children,
    child
  ] });
}));
Popover.displayName = "Memo(ForwardRef(Popover))";
function radioBaseStyle() {
  return lt`
    position: relative;

    &:not([hidden]) {
      display: inline-block;
    }

    &[data-read-only] {
      outline: 1px solid red;
    }
  `;
}
function inputElementStyle(props) {
  const {
    color: color3,
    input
  } = getTheme_v2(props.theme), dist = (input.radio.size - input.radio.markSize) / 2;
  return lt`
    appearance: none;
    position: absolute;
    top: 0;
    left: 0;
    opacity: 0;
    height: 100%;
    width: 100%;
    outline: none;
    z-index: 1;
    padding: 0;
    margin: 0;
    border-radius: ${rem(input.radio.size / 2)};
    border: none;

    /* enabled */
    & + span {
      display: block;
      position: relative;
      height: ${rem(input.radio.size)};
      width: ${rem(input.radio.size)};
      border-radius: ${rem(input.radio.size / 2)};
      background: ${color3.input.default.enabled.bg};
      box-shadow: ${focusRingBorderStyle({
    color: color3.input.default.enabled.border,
    width: input.border.width
  })};

      &::after {
        content: '';
        position: absolute;
        top: ${rem(dist)};
        left: ${rem(dist)};
        height: ${rem(input.radio.markSize)};
        width: ${rem(input.radio.markSize)};
        border-radius: ${rem(input.radio.markSize / 2)};
        background: ${color3.input.default.enabled.fg};
        opacity: 0;
      }
    }

    /* focused */
    &:not(:disabled):focus + span {
      box-shadow: ${focusRingStyle({
    border: {
      width: input.border.width,
      color: color3.input.default.enabled.border
    },
    focusRing: input.radio.focusRing
  })};
    }

    &:not(:disabled):focus:not(:focus-visible) + span {
      box-shadow: ${focusRingBorderStyle({
    color: color3.input.default.enabled.border,
    width: input.border.width
  })};
    }

    &:checked + span::after {
      opacity: 1;
    }

    /* customValidity */
    &[data-error] + span {
      background-color: ${color3.input.invalid.enabled.border};
      box-shadow: ${focusRingBorderStyle({
    width: input.border.width,
    color: color3.input.invalid.enabled.muted.bg
  })};
      &::after {
        background: ${color3.input.invalid.enabled.muted.bg};
      }
    }

    /* read only */
    &[data-read-only] + span {
      box-shadow: 0 0 0 1px ${color3.input.default.readOnly.border};
      background: ${color3.input.default.readOnly.bg};

      &::after {
        background: ${color3.input.default.readOnly.border};
      }
    }

    /* disabled */
    &:not([data-read-only]):disabled + span {
      box-shadow: 0 0 0 1px ${color3.input.default.disabled.border};
      background: ${color3.input.default.disabled.bg};

      &::after {
        background: ${color3.input.default.disabled.border};
      }
    }
  `;
}
var StyledRadio = dt.div.withConfig({
  displayName: "StyledRadio",
  componentId: "sc-ccrwkf-0"
})(radioBaseStyle);
var Input$4 = dt.input.withConfig({
  displayName: "Input",
  componentId: "sc-ccrwkf-1"
})(inputElementStyle);
var Radio = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(19);
  let className, customValidity, disabled, readOnly, restProps, style;
  $2[0] !== props ? ({
    className,
    disabled,
    style,
    customValidity,
    readOnly,
    ...restProps
  } = props, $2[0] = props, $2[1] = className, $2[2] = customValidity, $2[3] = disabled, $2[4] = readOnly, $2[5] = restProps, $2[6] = style) : (className = $2[1], customValidity = $2[2], disabled = $2[3], readOnly = $2[4], restProps = $2[5], style = $2[6]);
  const ref = (0, import_react52.useRef)(null);
  let t0;
  $2[7] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $2[7] = t0) : t0 = $2[7], (0, import_react52.useImperativeHandle)(forwardedRef, t0), useCustomValidity(ref, customValidity);
  const t1 = !disabled && readOnly ? "" : void 0, t2 = customValidity ? "" : void 0, t3 = disabled || readOnly;
  let t4;
  $2[8] !== readOnly || $2[9] !== restProps || $2[10] !== t1 || $2[11] !== t2 || $2[12] !== t3 ? (t4 = (0, import_jsx_runtime12.jsx)(Input$4, { "data-read-only": t1, "data-error": t2, ...restProps, disabled: t3, readOnly, ref, type: "radio" }), $2[8] = readOnly, $2[9] = restProps, $2[10] = t1, $2[11] = t2, $2[12] = t3, $2[13] = t4) : t4 = $2[13];
  let t5;
  $2[14] === Symbol.for("react.memo_cache_sentinel") ? (t5 = (0, import_jsx_runtime12.jsx)("span", {}), $2[14] = t5) : t5 = $2[14];
  let t6;
  return $2[15] !== className || $2[16] !== style || $2[17] !== t4 ? (t6 = (0, import_jsx_runtime12.jsxs)(StyledRadio, { className, "data-ui": "Radio", style, children: [
    t4,
    t5
  ] }), $2[15] = className, $2[16] = style, $2[17] = t4, $2[18] = t6) : t6 = $2[18], t6;
});
Radio.displayName = "ForwardRef(Radio)";
function rootStyle() {
  return lt`
    position: relative;
    width: -moz-available;
    width: -webkit-fill-available;
    width: stretch;

    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
function inputBaseStyle(props) {
  const {
    font
  } = getTheme_v2(props.theme);
  return lt`
    -webkit-font-smoothing: antialiased;
    appearance: none;
    border: 0;
    font-family: ${font.text.family};
    color: inherit;
    width: 100%;
    outline: none;
    margin: 0;

    &:disabled {
      opacity: 1;
    }
  `;
}
function inputColorStyle(props) {
  const {
    color: color3,
    input
  } = getTheme_v2(props.theme);
  return lt`
    /* enabled */
    background-color: ${color3.input.default.enabled.bg};
    color: ${color3.input.default.enabled.fg};
    box-shadow: ${focusRingBorderStyle({
    color: color3.input.default.enabled.border,
    width: input.border.width
  })};

    /* hovered */
    @media (hover: hover) {
      &:not(:disabled):hover {
        background-color: ${color3.input.default.hovered.bg};
        color: ${color3.input.default.hovered.fg};
        box-shadow: ${focusRingBorderStyle({
    color: color3.input.default.hovered.border,
    width: input.border.width
  })};
      }
    }

    /* focused */
    &:not(:disabled):focus {
      box-shadow: ${focusRingStyle({
    border: {
      width: input.border.width,
      color: color3.input.default.enabled.border
    },
    focusRing: input.select.focusRing
  })};
    }

    /* read-only */
    &[data-read-only] {
      background-color: ${color3.input.default.readOnly.bg};
      color: ${color3.input.default.readOnly.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color3.input.default.readOnly.border,
    width: input.border.width
  })};
    }

    /* disabled */
    &:not([data-read-only]):disabled {
      background-color: ${color3.input.default.disabled.bg};
      color: ${color3.input.default.disabled.fg};
      box-shadow: ${focusRingBorderStyle({
    color: color3.input.default.disabled.border,
    width: input.border.width
  })};
    }
  `;
}
function textSize(size22) {
  return {
    fontSize: rem(size22.fontSize),
    lineHeight: rem(size22.lineHeight)
  };
}
function inputTextSizeStyle(props) {
  const {
    $fontSize
  } = props, {
    font,
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, $fontSize, (sizeIndex) => textSize(font.text.sizes[sizeIndex] || font.text.sizes[2]));
}
function inputStyle() {
  return [responsiveRadiusStyle, inputBaseStyle, inputColorStyle, inputTextSizeStyle, responsiveInputPaddingIconRightStyle];
}
function iconBoxStyle(props) {
  const {
    color: color3
  } = getTheme_v2(props.theme);
  return lt`
    pointer-events: none;
    position: absolute;
    top: 0;
    right: 0;

    /* enabled */
    --card-fg-color: ${color3.input.default.enabled.fg};

    /* hover */
    @media (hover: hover) {
      select:not(disabled):not(:read-only):hover + && {
        --card-fg-color: ${color3.input.default.hovered.fg};
      }
    }

    /* disabled */
    select:disabled + && {
      --card-fg-color: ${color3.input.default.disabled.fg};
    }

    /* read-only */
    select[data-read-only] + && {
      --card-fg-color: ${color3.input.default.readOnly.fg};
    }
  `;
}
var selectStyle = {
  root: rootStyle,
  input: inputStyle,
  iconBox: iconBoxStyle
};
var StyledSelect = dt.div.withConfig({
  displayName: "StyledSelect",
  componentId: "sc-5mxno7-0"
})(selectStyle.root);
var Input$3 = dt.select.withConfig({
  displayName: "Input",
  componentId: "sc-5mxno7-1"
})(selectStyle.input);
var IconBox = dt(Box).withConfig({
  displayName: "IconBox",
  componentId: "sc-5mxno7-2"
})(selectStyle.iconBox);
var Select = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(29);
  let children, customValidity, disabled, readOnly, restProps, t0, t1, t2, t3;
  $2[0] !== props ? ({
    children,
    customValidity,
    disabled,
    fontSize: t0,
    padding: t1,
    radius: t2,
    readOnly,
    space: t3,
    ...restProps
  } = props, $2[0] = props, $2[1] = children, $2[2] = customValidity, $2[3] = disabled, $2[4] = readOnly, $2[5] = restProps, $2[6] = t0, $2[7] = t1, $2[8] = t2, $2[9] = t3) : (children = $2[1], customValidity = $2[2], disabled = $2[3], readOnly = $2[4], restProps = $2[5], t0 = $2[6], t1 = $2[7], t2 = $2[8], t3 = $2[9]);
  const fontSize2 = t0 === void 0 ? 2 : t0, padding = t1 === void 0 ? 3 : t1, radius = t2 === void 0 ? 2 : t2, space = t3 === void 0 ? 3 : t3, ref = (0, import_react52.useRef)(null);
  let t4;
  $2[10] === Symbol.for("react.memo_cache_sentinel") ? (t4 = () => ref.current, $2[10] = t4) : t4 = $2[10], (0, import_react52.useImperativeHandle)(forwardedRef, t4), useCustomValidity(ref, customValidity);
  const t5 = !disabled && readOnly ? "" : void 0, t6 = useArrayProp(fontSize2), t7 = useArrayProp(padding), t8 = useArrayProp(radius), t9 = useArrayProp(space), t10 = disabled || readOnly;
  let t11;
  $2[11] !== children || $2[12] !== restProps || $2[13] !== t10 || $2[14] !== t5 || $2[15] !== t6 || $2[16] !== t7 || $2[17] !== t8 || $2[18] !== t9 ? (t11 = (0, import_jsx_runtime12.jsx)(Input$3, { "data-read-only": t5, "data-ui": "Select", ...restProps, $fontSize: t6, $padding: t7, $radius: t8, $space: t9, disabled: t10, ref, children }), $2[11] = children, $2[12] = restProps, $2[13] = t10, $2[14] = t5, $2[15] = t6, $2[16] = t7, $2[17] = t8, $2[18] = t9, $2[19] = t11) : t11 = $2[19];
  let t12;
  $2[20] === Symbol.for("react.memo_cache_sentinel") ? (t12 = (0, import_jsx_runtime12.jsx)(ChevronDownIcon, {}), $2[20] = t12) : t12 = $2[20];
  let t13;
  $2[21] !== fontSize2 ? (t13 = (0, import_jsx_runtime12.jsx)(Text, { size: fontSize2, children: t12 }), $2[21] = fontSize2, $2[22] = t13) : t13 = $2[22];
  let t14;
  $2[23] !== padding || $2[24] !== t13 ? (t14 = (0, import_jsx_runtime12.jsx)(IconBox, { padding, children: t13 }), $2[23] = padding, $2[24] = t13, $2[25] = t14) : t14 = $2[25];
  let t15;
  return $2[26] !== t11 || $2[27] !== t14 ? (t15 = (0, import_jsx_runtime12.jsxs)(StyledSelect, { "data-ui": "Select", children: [
    t11,
    t14
  ] }), $2[26] = t11, $2[27] = t14, $2[28] = t15) : t15 = $2[28], t15;
});
Select.displayName = "ForwardRef(Select)";
var BASE_STYLE = {
  "&&:not([hidden])": {
    display: "grid"
  },
  '&[data-as="ul"],&[data-as="ol"]': {
    listStyle: "none"
  },
  gridTemplateColumns: "minmax(0, 1fr)",
  gridAutoRows: "min-content"
};
function stackBaseStyle() {
  return BASE_STYLE;
}
function responsiveStackSpaceStyle(props) {
  const {
    media,
    space
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$space, (spaceIndex) => ({
    gridGap: rem(space[spaceIndex])
  }));
}
var StyledStack = dt(Box).withConfig({
  displayName: "StyledStack",
  componentId: "sc-8dpfq2-0"
})(stackBaseStyle, responsiveStackSpaceStyle);
var Stack = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(10);
  let as, restProps, space;
  $2[0] !== props ? ({
    as,
    space,
    ...restProps
  } = props, $2[0] = props, $2[1] = as, $2[2] = restProps, $2[3] = space) : (as = $2[1], restProps = $2[2], space = $2[3]);
  const t0 = typeof as == "string" ? as : void 0, t1 = useArrayProp(space);
  let t2;
  return $2[4] !== as || $2[5] !== ref || $2[6] !== restProps || $2[7] !== t0 || $2[8] !== t1 ? (t2 = (0, import_jsx_runtime12.jsx)(StyledStack, { "data-as": t0, "data-ui": "Stack", ...restProps, $space: t1, forwardedAs: as, ref }), $2[4] = as, $2[5] = ref, $2[6] = restProps, $2[7] = t0, $2[8] = t1, $2[9] = t2) : t2 = $2[9], t2;
});
Stack.displayName = "ForwardRef(Stack)";
function switchBaseStyles() {
  return lt`
    position: relative;
    &:not([hidden]) {
      display: inline-block;
    }
  `;
}
function switchInputStyles() {
  return lt`
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    opacity: 0;
    height: 100%;
    width: 100%;
    outline: none;
    padding: 0;
    margin: 0;

    /* Place the input element above the representation element */
    z-index: 1;
  `;
}
function switchRepresentationStyles(props) {
  const {
    color: color3,
    input
  } = getTheme_v2(props.theme);
  return lt`
    --switch-bg-color: ${color3.input.default.enabled.border};
    --switch-fg-color: ${color3.input.default.enabled.bg};
    --switch-box-shadow: none;

    &:not([hidden]) {
      display: block;
    }
    position: relative;
    width: ${rem(input.switch.width)};
    height: ${rem(input.switch.height)};
    border-radius: ${rem(input.switch.height / 2)};

    /* Make sure it’s not possible to interact with the wrapper element */
    pointer-events: none;

    &:after {
      content: '';
      display: block;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1;
      box-shadow: var(--switch-box-shadow);
      border-radius: inherit;
    }

    /* Focus styles */
    input:focus + && {
      --switch-box-shadow: ${focusRingStyle({
    focusRing: input.switch.focusRing
  })};
    }

    input:focus:not(:focus-visible) + && {
      --switch-box-shadow: none;
    }

    input:checked + && {
      --switch-bg-color: ${color3.input.default.enabled.fg};
      --switch-fg-color: ${color3.input.default.enabled.bg};
    }

    @media (hover: hover) {
      input:not(:disabled):hover + && {
        --switch-bg-color: ${color3.input.default.hovered.border};
        --switch-fg-color: ${color3.input.default.hovered.bg};
      }

      input:not(:disabled):checked:hover + && {
        --switch-bg-color: ${color3.input.default.enabled.fg};
        --switch-fg-color: ${color3.input.default.enabled.bg};
      }
    }

    input:not([data-read-only]):disabled + && {
      --switch-bg-color: ${color3.input.default.disabled.border};
      --switch-fg-color: ${color3.input.default.disabled.bg};
    }

    input[data-read-only]:disabled + && {
      --switch-bg-color: ${color3.input.default.readOnly.border};
      --switch-fg-color: ${color3.input.default.readOnly.bg};
    }

    input:checked[data-read-only]:disabled + && {
      --switch-bg-color: ${color3.input.default.readOnly.fg};
      --switch-fg-color: ${color3.input.default.readOnly.bg};
    }
  `;
}
function switchTrackStyles(props) {
  const {
    input
  } = getTheme_v2(props.theme);
  return lt`
    &:not([hidden]) {
      display: block;
    }
    background-color: var(--switch-bg-color);
    position: absolute;
    left: 0;
    top: 0;
    width: ${rem(input.switch.width)};
    height: ${rem(input.switch.height)};
    border-radius: ${rem(input.switch.height / 2)};
  `;
}
function switchThumbStyles(props) {
  const {
    $indeterminate
  } = props, {
    input
  } = getTheme_v2(props.theme), trackWidth = input.switch.width, trackHeight = input.switch.height, trackPadding = input.switch.padding, size22 = trackHeight - input.switch.padding * 2, checkedOffset = trackWidth - trackPadding * 2 - size22, indeterminateOffset = trackWidth / 2 - size22 / 2 - trackPadding, checked = $indeterminate !== true && props.$checked === true;
  return lt`
    &:not([hidden]) {
      display: block;
    }
    position: absolute;
    left: ${rem(trackPadding)};
    top: ${rem(trackPadding)};
    height: ${rem(size22)};
    width: ${rem(size22)};
    border-radius: ${rem(size22 / 2)};
    transition-property: transform;
    transition-duration: ${input.switch.transitionDurationMs}ms;
    transition-timing-function: ${input.switch.transitionTimingFunction};
    background: var(--switch-fg-color);
    transform: translate3d(0, 0, 0);
    box-shadow: 0px 1px 0px 0px rgba(0, 0, 0, 0.05);

    ${checked && lt`
      transform: translate3d(${checkedOffset}px, 0, 0);
    `}

    ${$indeterminate && lt`
      transform: translate3d(${indeterminateOffset}px, 0, 0);
    `}
  `;
}
var StyledSwitch = dt.span.withConfig({
  displayName: "StyledSwitch",
  componentId: "sc-dw1foe-0"
})(switchBaseStyles);
var Input$2 = dt.input.withConfig({
  displayName: "Input",
  componentId: "sc-dw1foe-1"
})(switchInputStyles);
var Representation = dt.span.withConfig({
  displayName: "Representation",
  componentId: "sc-dw1foe-2"
})(switchRepresentationStyles);
var Track = dt.span.withConfig({
  displayName: "Track",
  componentId: "sc-dw1foe-3"
})(switchTrackStyles);
var Thumb = dt.span.withConfig({
  displayName: "Thumb",
  componentId: "sc-dw1foe-4"
})(switchThumbStyles);
var Switch = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(26);
  let checked, className, disabled, indeterminate, readOnly, restProps, style;
  $2[0] !== props ? ({
    checked,
    className,
    disabled,
    indeterminate,
    readOnly,
    style,
    ...restProps
  } = props, $2[0] = props, $2[1] = checked, $2[2] = className, $2[3] = disabled, $2[4] = indeterminate, $2[5] = readOnly, $2[6] = restProps, $2[7] = style) : (checked = $2[1], className = $2[2], disabled = $2[3], indeterminate = $2[4], readOnly = $2[5], restProps = $2[6], style = $2[7]);
  const ref = (0, import_react52.useRef)(null);
  let t0;
  $2[8] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $2[8] = t0) : t0 = $2[8], (0, import_react52.useImperativeHandle)(forwardedRef, t0);
  let t1, t2;
  $2[9] !== indeterminate ? (t1 = () => {
    ref.current && (ref.current.indeterminate = indeterminate || false);
  }, t2 = [indeterminate], $2[9] = indeterminate, $2[10] = t1, $2[11] = t2) : (t1 = $2[10], t2 = $2[11]), (0, import_react52.useEffect)(t1, t2);
  const t3 = !disabled && readOnly ? "" : void 0, t4 = indeterminate !== true && checked, t5 = disabled || readOnly;
  let t6;
  $2[12] !== restProps || $2[13] !== t3 || $2[14] !== t4 || $2[15] !== t5 ? (t6 = (0, import_jsx_runtime12.jsx)(Input$2, { "data-read-only": t3, ...restProps, checked: t4, disabled: t5, type: "checkbox", ref }), $2[12] = restProps, $2[13] = t3, $2[14] = t4, $2[15] = t5, $2[16] = t6) : t6 = $2[16];
  let t7;
  $2[17] === Symbol.for("react.memo_cache_sentinel") ? (t7 = (0, import_jsx_runtime12.jsx)(Track, {}), $2[17] = t7) : t7 = $2[17];
  let t8;
  $2[18] !== checked || $2[19] !== indeterminate ? (t8 = (0, import_jsx_runtime12.jsxs)(Representation, { "aria-hidden": true, "data-name": "representation", children: [
    t7,
    (0, import_jsx_runtime12.jsx)(Thumb, { $checked: checked, $indeterminate: indeterminate })
  ] }), $2[18] = checked, $2[19] = indeterminate, $2[20] = t8) : t8 = $2[20];
  let t9;
  return $2[21] !== className || $2[22] !== style || $2[23] !== t6 || $2[24] !== t8 ? (t9 = (0, import_jsx_runtime12.jsxs)(StyledSwitch, { className, "data-ui": "Switch", style, children: [
    t6,
    t8
  ] }), $2[21] = className, $2[22] = style, $2[23] = t6, $2[24] = t8, $2[25] = t9) : t9 = $2[25], t9;
});
Switch.displayName = "ForwardRef(Switch)";
var StyledTextArea = dt.span.withConfig({
  displayName: "StyledTextArea",
  componentId: "sc-1d6h1o8-0"
})(textInputRootStyle);
var InputRoot$1 = dt.span.withConfig({
  displayName: "InputRoot",
  componentId: "sc-1d6h1o8-1"
})`flex:1;min-width:0;display:block;position:relative;`;
var Input$1 = dt.textarea.withConfig({
  displayName: "Input",
  componentId: "sc-1d6h1o8-2"
})(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
var Presentation$1 = dt.div.withConfig({
  displayName: "Presentation",
  componentId: "sc-1d6h1o8-3"
})(responsiveRadiusStyle, textInputRepresentationStyle);
var TextArea = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(29);
  let __unstable_disableFocusRing, customValidity, restProps, t0, t1, t2, t3, t4, weight;
  $2[0] !== props ? ({
    border: t0,
    customValidity,
    disabled: t1,
    fontSize: t2,
    padding: t3,
    radius: t4,
    weight,
    __unstable_disableFocusRing,
    ...restProps
  } = props, $2[0] = props, $2[1] = __unstable_disableFocusRing, $2[2] = customValidity, $2[3] = restProps, $2[4] = t0, $2[5] = t1, $2[6] = t2, $2[7] = t3, $2[8] = t4, $2[9] = weight) : (__unstable_disableFocusRing = $2[1], customValidity = $2[2], restProps = $2[3], t0 = $2[4], t1 = $2[5], t2 = $2[6], t3 = $2[7], t4 = $2[8], weight = $2[9]);
  const border2 = t0 === void 0 ? true : t0, disabled = t1 === void 0 ? false : t1, fontSize2 = t2 === void 0 ? 2 : t2, padding = t3 === void 0 ? 3 : t3, radius = t4 === void 0 ? 2 : t4, ref = (0, import_react52.useRef)(null), rootTheme = useRootTheme();
  let t5;
  $2[10] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => ref.current, $2[10] = t5) : t5 = $2[10], (0, import_react52.useImperativeHandle)(forwardedRef, t5), useCustomValidity(ref, customValidity);
  const t6 = rootTheme.scheme, t7 = rootTheme.tone, t8 = useArrayProp(fontSize2), t9 = useArrayProp(padding), t10 = rootTheme.scheme, t11 = useArrayProp(0);
  let t12;
  $2[11] !== disabled || $2[12] !== restProps || $2[13] !== rootTheme.scheme || $2[14] !== rootTheme.tone || $2[15] !== t11 || $2[16] !== t8 || $2[17] !== t9 || $2[18] !== weight ? (t12 = (0, import_jsx_runtime12.jsx)(Input$1, { "data-as": "textarea", "data-scheme": t6, "data-tone": t7, ...restProps, $fontSize: t8, $padding: t9, $scheme: t10, $space: t11, $tone: rootTheme.tone, $weight: weight, disabled, ref }), $2[11] = disabled, $2[12] = restProps, $2[13] = rootTheme.scheme, $2[14] = rootTheme.tone, $2[15] = t11, $2[16] = t8, $2[17] = t9, $2[18] = weight, $2[19] = t12) : t12 = $2[19];
  const t13 = useArrayProp(radius), t14 = border2 ? "" : void 0;
  let t15;
  $2[20] !== __unstable_disableFocusRing || $2[21] !== rootTheme.scheme || $2[22] !== rootTheme.tone || $2[23] !== t13 || $2[24] !== t14 ? (t15 = (0, import_jsx_runtime12.jsx)(Presentation$1, { $radius: t13, $unstableDisableFocusRing: __unstable_disableFocusRing, $scheme: rootTheme.scheme, $tone: rootTheme.tone, "data-border": t14, "data-scheme": rootTheme.scheme, "data-tone": rootTheme.tone }), $2[20] = __unstable_disableFocusRing, $2[21] = rootTheme.scheme, $2[22] = rootTheme.tone, $2[23] = t13, $2[24] = t14, $2[25] = t15) : t15 = $2[25];
  let t16;
  return $2[26] !== t12 || $2[27] !== t15 ? (t16 = (0, import_jsx_runtime12.jsx)(StyledTextArea, { "data-ui": "TextArea", children: (0, import_jsx_runtime12.jsxs)(InputRoot$1, { children: [
    t12,
    t15
  ] }) }), $2[26] = t12, $2[27] = t15, $2[28] = t16) : t16 = $2[28], t16;
});
TextArea.displayName = "ForwardRef(TextArea)";
var CLEAR_BUTTON_BOX_STYLE = {
  zIndex: 2
};
var StyledTextInput = dt(Card).attrs({
  forwardedAs: "span"
}).withConfig({
  displayName: "StyledTextInput",
  componentId: "sc-h62wco-0"
})(textInputRootStyle);
var InputRoot = dt.span.withConfig({
  displayName: "InputRoot",
  componentId: "sc-h62wco-1"
})`flex:1;min-width:0;display:block;position:relative;`;
var Prefix = dt(Card).attrs({
  forwardedAs: "span"
}).withConfig({
  displayName: "Prefix",
  componentId: "sc-h62wco-2"
})`border-top-right-radius:0;border-bottom-right-radius:0;& > span{display:block;margin:-1px;}`;
var Suffix = dt(Card).attrs({
  forwardedAs: "span"
}).withConfig({
  displayName: "Suffix",
  componentId: "sc-h62wco-3"
})`border-top-left-radius:0;border-bottom-left-radius:0;& > span{display:block;margin:-1px;}`;
var Input = dt.input.withConfig({
  displayName: "Input",
  componentId: "sc-h62wco-4"
})(responsiveInputPaddingStyle, textInputBaseStyle, textInputFontSizeStyle);
var Presentation = dt.span.withConfig({
  displayName: "Presentation",
  componentId: "sc-h62wco-5"
})(responsiveRadiusStyle, textInputRepresentationStyle);
var LeftBox = dt(Box).withConfig({
  displayName: "LeftBox",
  componentId: "sc-h62wco-6"
})`position:absolute;top:0;left:0;`;
var RightBox = dt(Box).withConfig({
  displayName: "RightBox",
  componentId: "sc-h62wco-7"
})`position:absolute;top:0;right:0;`;
var RightCard = dt(Card).withConfig({
  displayName: "RightCard",
  componentId: "sc-h62wco-8"
})`background-color:transparent;position:absolute;top:0;right:0;`;
var TextInputClearButton = dt(Button).withConfig({
  displayName: "TextInputClearButton",
  componentId: "sc-h62wco-9"
})({
  "&:not([hidden])": {
    display: "block"
  }
});
var TextInput = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(84);
  let IconComponent, IconRightComponent, __unstable_disableFocusRing, clearButton, customValidity, onClear, prefix2, readOnly, restProps, suffix, t0, t1, t2, t3, t4, t5, t6, weight;
  $2[0] !== props ? ({
    __unstable_disableFocusRing,
    border: t0,
    clearButton,
    disabled: t1,
    fontSize: t2,
    icon: IconComponent,
    iconRight: IconRightComponent,
    onClear,
    padding: t3,
    prefix: prefix2,
    radius: t4,
    readOnly,
    space: t5,
    suffix,
    customValidity,
    type: t6,
    weight,
    ...restProps
  } = props, $2[0] = props, $2[1] = IconComponent, $2[2] = IconRightComponent, $2[3] = __unstable_disableFocusRing, $2[4] = clearButton, $2[5] = customValidity, $2[6] = onClear, $2[7] = prefix2, $2[8] = readOnly, $2[9] = restProps, $2[10] = suffix, $2[11] = t0, $2[12] = t1, $2[13] = t2, $2[14] = t3, $2[15] = t4, $2[16] = t5, $2[17] = t6, $2[18] = weight) : (IconComponent = $2[1], IconRightComponent = $2[2], __unstable_disableFocusRing = $2[3], clearButton = $2[4], customValidity = $2[5], onClear = $2[6], prefix2 = $2[7], readOnly = $2[8], restProps = $2[9], suffix = $2[10], t0 = $2[11], t1 = $2[12], t2 = $2[13], t3 = $2[14], t4 = $2[15], t5 = $2[16], t6 = $2[17], weight = $2[18]);
  const border2 = t0 === void 0 ? true : t0, disabled = t1 === void 0 ? false : t1, fontSizeProp = t2 === void 0 ? 2 : t2, paddingProp = t3 === void 0 ? 3 : t3, radiusProp = t4 === void 0 ? 2 : t4, spaceProp = t5 === void 0 ? 3 : t5, type = t6 === void 0 ? "text" : t6, ref = (0, import_react52.useRef)(null), rootTheme = useRootTheme(), fontSize2 = useArrayProp(fontSizeProp), padding = useArrayProp(paddingProp), radius = useArrayProp(radiusProp), space = useArrayProp(spaceProp), $hasClearButton = !!clearButton, $hasIcon = !!IconComponent, $hasIconRight = !!IconRightComponent, $hasSuffix = !!suffix, $hasPrefix = !!prefix2;
  let t7;
  $2[19] === Symbol.for("react.memo_cache_sentinel") ? (t7 = () => ref.current, $2[19] = t7) : t7 = $2[19], (0, import_react52.useImperativeHandle)(forwardedRef, t7), useCustomValidity(ref, customValidity);
  const handleClearMouseDown = _temp$1;
  let t8;
  $2[20] !== onClear ? (t8 = (event_0) => {
    var _a;
    event_0.preventDefault(), event_0.stopPropagation(), onClear && onClear(), (_a = ref.current) == null ? void 0 : _a.focus();
  }, $2[20] = onClear, $2[21] = t8) : t8 = $2[21];
  const handleClearClick = t8;
  let t9, t10;
  $2[22] !== prefix2 || $2[23] !== radius ? (t10 = prefix2 && (0, import_jsx_runtime12.jsx)(Prefix, { borderTop: true, borderLeft: true, borderBottom: true, radius, sizing: "border", tone: "inherit", children: (0, import_jsx_runtime12.jsx)("span", { children: prefix2 }) }), $2[22] = prefix2, $2[23] = radius, $2[24] = t10) : t10 = $2[24], t9 = t10;
  const prefixNode = t9;
  let t11;
  const t12 = border2 ? "" : void 0;
  let t13;
  $2[25] !== IconComponent || $2[26] !== fontSize2 || $2[27] !== padding ? (t13 = IconComponent && (0, import_jsx_runtime12.jsx)(LeftBox, { padding, children: (0, import_jsx_runtime12.jsxs)(Text, { size: fontSize2, children: [
    (0, import_react52.isValidElement)(IconComponent) && IconComponent,
    (0, import_react_is.isValidElementType)(IconComponent) && (0, import_jsx_runtime12.jsx)(IconComponent, {})
  ] }) }), $2[25] = IconComponent, $2[26] = fontSize2, $2[27] = padding, $2[28] = t13) : t13 = $2[28];
  let t14;
  $2[29] !== $hasClearButton || $2[30] !== IconRightComponent || $2[31] !== fontSize2 || $2[32] !== padding ? (t14 = !$hasClearButton && IconRightComponent && (0, import_jsx_runtime12.jsx)(RightBox, { padding, children: (0, import_jsx_runtime12.jsxs)(Text, { size: fontSize2, children: [
    (0, import_react52.isValidElement)(IconRightComponent) && IconRightComponent,
    (0, import_react_is.isValidElementType)(IconRightComponent) && (0, import_jsx_runtime12.jsx)(IconRightComponent, {})
  ] }) }), $2[29] = $hasClearButton, $2[30] = IconRightComponent, $2[31] = fontSize2, $2[32] = padding, $2[33] = t14) : t14 = $2[33];
  let t15;
  $2[34] !== $hasPrefix || $2[35] !== $hasSuffix || $2[36] !== __unstable_disableFocusRing || $2[37] !== radius || $2[38] !== rootTheme.scheme || $2[39] !== rootTheme.tone || $2[40] !== t12 || $2[41] !== t13 || $2[42] !== t14 ? (t15 = (0, import_jsx_runtime12.jsxs)(Presentation, { $hasPrefix, $unstableDisableFocusRing: __unstable_disableFocusRing, $hasSuffix, $radius: radius, $scheme: rootTheme.scheme, $tone: rootTheme.tone, "data-border": t12, "data-scheme": rootTheme.scheme, "data-tone": rootTheme.tone, children: [
    t13,
    t14
  ] }), $2[34] = $hasPrefix, $2[35] = $hasSuffix, $2[36] = __unstable_disableFocusRing, $2[37] = radius, $2[38] = rootTheme.scheme, $2[39] = rootTheme.tone, $2[40] = t12, $2[41] = t13, $2[42] = t14, $2[43] = t15) : t15 = $2[43], t11 = t15;
  const presentationNode = t11;
  let t16, t17;
  $2[44] !== padding ? (t17 = padding.map(_temp2), $2[44] = padding, $2[45] = t17) : t17 = $2[45], t16 = t17;
  const clearButtonBoxPadding = t16;
  let t18, t19;
  $2[46] !== padding ? (t19 = padding.map(_temp3), $2[46] = padding, $2[47] = t19) : t19 = $2[47], t18 = t19;
  const clearButtonPadding = t18;
  let t20;
  t20 = typeof clearButton == "object" ? clearButton : EMPTY_RECORD;
  const clearButtonProps = t20;
  let t21, t22;
  $2[48] !== clearButton || $2[49] !== clearButtonBoxPadding || $2[50] !== clearButtonPadding || $2[51] !== clearButtonProps || $2[52] !== customValidity || $2[53] !== disabled || $2[54] !== fontSize2 || $2[55] !== handleClearClick || $2[56] !== radius || $2[57] !== readOnly ? (t22 = !disabled && !readOnly && clearButton && (0, import_jsx_runtime12.jsx)(RightCard, { forwardedAs: "span", padding: clearButtonBoxPadding, style: CLEAR_BUTTON_BOX_STYLE, tone: customValidity ? "critical" : "inherit", children: (0, import_jsx_runtime12.jsx)(TextInputClearButton, { "aria-label": "Clear", "data-qa": "clear-button", fontSize: fontSize2, icon: CloseIcon, mode: "bleed", padding: clearButtonPadding, radius, ...clearButtonProps, onClick: handleClearClick, onMouseDown: handleClearMouseDown }) }), $2[48] = clearButton, $2[49] = clearButtonBoxPadding, $2[50] = clearButtonPadding, $2[51] = clearButtonProps, $2[52] = customValidity, $2[53] = disabled, $2[54] = fontSize2, $2[55] = handleClearClick, $2[56] = radius, $2[57] = readOnly, $2[58] = t22) : t22 = $2[58], t21 = t22;
  const clearButtonNode = t21;
  let t23, t24;
  $2[59] !== radius || $2[60] !== suffix ? (t24 = suffix && (0, import_jsx_runtime12.jsx)(Suffix, { borderTop: true, borderRight: true, borderBottom: true, radius, sizing: "border", tone: "inherit", children: (0, import_jsx_runtime12.jsx)("span", { children: suffix }) }), $2[59] = radius, $2[60] = suffix, $2[61] = t24) : t24 = $2[61], t23 = t24;
  const suffixNode = t23, t25 = $hasIconRight || $hasClearButton;
  let t26;
  $2[62] !== $hasIcon || $2[63] !== disabled || $2[64] !== fontSize2 || $2[65] !== padding || $2[66] !== readOnly || $2[67] !== restProps || $2[68] !== rootTheme.scheme || $2[69] !== rootTheme.tone || $2[70] !== space || $2[71] !== t25 || $2[72] !== type || $2[73] !== weight ? (t26 = (0, import_jsx_runtime12.jsx)(Input, { "data-as": "input", "data-scheme": rootTheme.scheme, "data-tone": rootTheme.tone, ...restProps, $fontSize: fontSize2, $iconLeft: $hasIcon, $iconRight: t25, $padding: padding, $scheme: rootTheme.scheme, $space: space, $tone: rootTheme.tone, $weight: weight, disabled, readOnly, ref, type }), $2[62] = $hasIcon, $2[63] = disabled, $2[64] = fontSize2, $2[65] = padding, $2[66] = readOnly, $2[67] = restProps, $2[68] = rootTheme.scheme, $2[69] = rootTheme.tone, $2[70] = space, $2[71] = t25, $2[72] = type, $2[73] = weight, $2[74] = t26) : t26 = $2[74];
  let t27;
  $2[75] !== clearButtonNode || $2[76] !== presentationNode || $2[77] !== t26 ? (t27 = (0, import_jsx_runtime12.jsxs)(InputRoot, { children: [
    t26,
    presentationNode,
    clearButtonNode
  ] }), $2[75] = clearButtonNode, $2[76] = presentationNode, $2[77] = t26, $2[78] = t27) : t27 = $2[78];
  let t28;
  return $2[79] !== prefixNode || $2[80] !== rootTheme.tone || $2[81] !== suffixNode || $2[82] !== t27 ? (t28 = (0, import_jsx_runtime12.jsxs)(StyledTextInput, { "data-ui": "TextInput", tone: rootTheme.tone, children: [
    prefixNode,
    t27,
    suffixNode
  ] }), $2[79] = prefixNode, $2[80] = rootTheme.tone, $2[81] = suffixNode, $2[82] = t27, $2[83] = t28) : t28 = $2[83], t28;
});
TextInput.displayName = "ForwardRef(TextInput)";
function _temp$1(event) {
  event.preventDefault(), event.stopPropagation();
}
function _temp2(v2) {
  return v2 === 0 ? 0 : v2 === 1 || v2 === 2 ? 1 : v2 - 2;
}
function _temp3(v_0) {
  return v_0 === 0 || v_0 === 1 ? 0 : v_0 === 2 ? 1 : v_0 - 1;
}
function useDelayedState(initialState) {
  const $2 = (0, import_react_compiler_runtime.c)(3), [state, setState] = (0, import_react52.useState)(initialState), delayedAction = (0, import_react52.useRef)(void 0);
  let t0;
  $2[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = (nextState, delay2) => {
    const action = () => {
      setState(nextState);
    };
    if (delayedAction.current && (clearTimeout(delayedAction.current), delayedAction.current = void 0), !delay2)
      return action();
    delayedAction.current = setTimeout(action, delay2);
  }, $2[0] = t0) : t0 = $2[0];
  const onStateChange = t0;
  let t1;
  return $2[1] !== state ? (t1 = [state, onStateChange], $2[1] = state, $2[2] = t1) : t1 = $2[2], t1;
}
var DEFAULT_TOOLTIP_ARROW_WIDTH = 15;
var DEFAULT_TOOLTIP_ARROW_HEIGHT = 6;
var DEFAULT_TOOLTIP_ARROW_RADIUS = 2;
var DEFAULT_TOOLTIP_DISTANCE = 4;
var DEFAULT_TOOLTIP_PADDING = 4;
var DEFAULT_FALLBACK_PLACEMENTS = {
  top: ["top-end", "top-start", "bottom", "left", "right"],
  "top-start": ["top", "top-end", "bottom-start", "left-start", "right-start"],
  "top-end": ["top", "top-start", "bottom-end", "left-end", "right-end"],
  bottom: ["bottom-end", "bottom-start", "top", "left", "right"],
  "bottom-start": ["bottom", "bottom-end", "top-start", "left-start", "right-start"],
  "bottom-end": ["bottom", "bottom-start", "top-end", "left-end", "right-end"],
  left: ["left-end", "left-start", "right", "top", "bottom"],
  "left-start": ["left", "left-end", "right-start", "top-start", "bottom-start"],
  "left-end": ["left", "left-start", "right-end", "top-end", "bottom-end"],
  right: ["right-end", "right-start", "left", "top", "bottom"],
  "right-start": ["right", "right-end", "left-start", "top-start", "bottom-start"],
  "right-end": ["right", "right-start", "left-end", "top-end", "bottom-end"]
};
var MotionCard = dt(motion.create(Card)).withConfig({
  displayName: "MotionCard",
  componentId: "sc-1xn138w-0"
})`will-change:transform;`;
var TooltipCard = (0, import_react52.memo)((0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(48);
  let animate2, arrow22, arrowRef, arrowX, arrowY, children, originX, originY, padding, placement, radius, restProps, scheme, shadow, style;
  $2[0] !== props ? ({
    animate: animate2,
    arrow: arrow22,
    arrowRef,
    arrowX,
    arrowY,
    children,
    originX,
    originY,
    padding,
    placement,
    radius,
    scheme,
    shadow,
    style,
    ...restProps
  } = props, $2[0] = props, $2[1] = animate2, $2[2] = arrow22, $2[3] = arrowRef, $2[4] = arrowX, $2[5] = arrowY, $2[6] = children, $2[7] = originX, $2[8] = originY, $2[9] = padding, $2[10] = placement, $2[11] = radius, $2[12] = restProps, $2[13] = scheme, $2[14] = shadow, $2[15] = style) : (animate2 = $2[1], arrow22 = $2[2], arrowRef = $2[3], arrowX = $2[4], arrowY = $2[5], children = $2[6], originX = $2[7], originY = $2[8], padding = $2[9], placement = $2[10], radius = $2[11], restProps = $2[12], scheme = $2[13], shadow = $2[14], style = $2[15]);
  let t0;
  const t1 = animate2 ? "transform" : void 0;
  let t2;
  $2[16] !== originX || $2[17] !== originY || $2[18] !== style || $2[19] !== t1 ? (t2 = {
    originX,
    originY,
    willChange: t1,
    ...style
  }, $2[16] = originX, $2[17] = originY, $2[18] = style, $2[19] = t1, $2[20] = t2) : t2 = $2[20], t0 = t2;
  const rootStyle2 = t0;
  let t3;
  const t4 = arrowX !== null ? arrowX : void 0, t5 = arrowY !== null ? arrowY : void 0;
  let t6;
  $2[21] !== t4 || $2[22] !== t5 ? (t6 = {
    left: t4,
    top: t5,
    right: void 0,
    bottom: void 0
  }, $2[21] = t4, $2[22] = t5, $2[23] = t6) : t6 = $2[23], t3 = t6;
  const arrowStyle = t3, t7 = restProps;
  let t8;
  $2[24] !== animate2 ? (t8 = animate2 ? ["hidden", "initial"] : void 0, $2[24] = animate2, $2[25] = t8) : t8 = $2[25];
  let t9;
  $2[26] !== animate2 ? (t9 = animate2 ? ["visible", "scaleIn"] : void 0, $2[26] = animate2, $2[27] = t9) : t9 = $2[27];
  let t10;
  $2[28] !== animate2 ? (t10 = animate2 ? ["hidden", "scaleOut"] : void 0, $2[28] = animate2, $2[29] = t10) : t10 = $2[29];
  let t11;
  $2[30] !== arrow22 || $2[31] !== arrowRef || $2[32] !== arrowStyle ? (t11 = arrow22 && (0, import_jsx_runtime12.jsx)(Arrow, { ref: arrowRef, style: arrowStyle, width: DEFAULT_TOOLTIP_ARROW_WIDTH, height: DEFAULT_TOOLTIP_ARROW_HEIGHT, radius: DEFAULT_TOOLTIP_ARROW_RADIUS }), $2[30] = arrow22, $2[31] = arrowRef, $2[32] = arrowStyle, $2[33] = t11) : t11 = $2[33];
  let t12;
  return $2[34] !== children || $2[35] !== padding || $2[36] !== placement || $2[37] !== radius || $2[38] !== ref || $2[39] !== rootStyle2 || $2[40] !== scheme || $2[41] !== shadow || $2[42] !== t10 || $2[43] !== t11 || $2[44] !== t7 || $2[45] !== t8 || $2[46] !== t9 ? (t12 = (0, import_jsx_runtime12.jsxs)(MotionCard, { "data-ui": "Tooltip__card", ...t7, "data-placement": placement, padding, radius, ref, scheme, shadow, style: rootStyle2, variants: POPOVER_MOTION_PROPS.card, transition: POPOVER_MOTION_PROPS.transition, initial: t8, animate: t9, exit: t10, children: [
    children,
    t11
  ] }), $2[34] = children, $2[35] = padding, $2[36] = placement, $2[37] = radius, $2[38] = ref, $2[39] = rootStyle2, $2[40] = scheme, $2[41] = shadow, $2[42] = t10, $2[43] = t11, $2[44] = t7, $2[45] = t8, $2[46] = t9, $2[47] = t12) : t12 = $2[47], t12;
}));
TooltipCard.displayName = "Memo(ForwardRef(TooltipCard))";
var TooltipDelayGroupContext = createGlobalScopedContext("@sanity/ui/context/tooltipDelayGroup", null);
function TooltipDelayGroupProvider(props) {
  const $2 = (0, import_react_compiler_runtime.c)(9), {
    children,
    delay: delay2
  } = props, [isGroupActive, setIsGroupActive] = useDelayedState(false), [openTooltipId, setOpenTooltipId] = useDelayedState(null), openDelay = typeof delay2 == "number" ? delay2 : (delay2 == null ? void 0 : delay2.open) || 0, closeDelay = typeof delay2 == "number" ? delay2 : (delay2 == null ? void 0 : delay2.close) || 0;
  let t0;
  const t1 = isGroupActive ? 1 : openDelay;
  let t2;
  $2[0] !== closeDelay || $2[1] !== openTooltipId || $2[2] !== setIsGroupActive || $2[3] !== setOpenTooltipId || $2[4] !== t1 ? (t2 = {
    setIsGroupActive,
    openTooltipId,
    setOpenTooltipId,
    openDelay: t1,
    closeDelay
  }, $2[0] = closeDelay, $2[1] = openTooltipId, $2[2] = setIsGroupActive, $2[3] = setOpenTooltipId, $2[4] = t1, $2[5] = t2) : t2 = $2[5], t0 = t2;
  const value = t0;
  let t3;
  return $2[6] !== children || $2[7] !== value ? (t3 = (0, import_jsx_runtime12.jsx)(TooltipDelayGroupContext.Provider, { value, children }), $2[6] = children, $2[7] = value, $2[8] = t3) : t3 = $2[8], t3;
}
TooltipDelayGroupProvider.displayName = "TooltipDelayGroupProvider";
function useTooltipDelayGroup() {
  return (0, import_react52.useContext)(TooltipDelayGroupContext);
}
var StyledTooltip = dt(Layer).withConfig({
  displayName: "StyledTooltip",
  componentId: "sc-13f2zvh-0"
})`pointer-events:none;`;
var Tooltip = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  var _a, _b, _c, _d, _e2;
  const boundaryElementContext = useBoundaryElement(), {
    layer
  } = useTheme_v2(), {
    animate: _animate = false,
    arrow: arrowProp = false,
    boundaryElement = boundaryElementContext == null ? void 0 : boundaryElementContext.element,
    children: childProp,
    content: content2,
    disabled,
    fallbackPlacements: fallbackPlacementsProp = props.fallbackPlacements ?? DEFAULT_FALLBACK_PLACEMENTS[props.placement ?? "bottom"],
    padding = 2,
    placement: placementProp = "bottom",
    portal: portalProp,
    radius = 2,
    scheme,
    shadow = 2,
    zOffset = layer.tooltip.zOffset,
    delay: delay2,
    ...restProps
  } = props, animate2 = usePrefersReducedMotion() ? false : _animate, fallbackPlacements = useArrayProp(fallbackPlacementsProp), ref = (0, import_react52.useRef)(null), [referenceElement, setReferenceElement] = (0, import_react52.useState)(null), arrowRef = (0, import_react52.useRef)(null), rootBoundary = "viewport", [tooltipMaxWidth, setTooltipMaxWidth] = (0, import_react52.useState)(0);
  (0, import_react52.useImperativeHandle)(forwardedRef, () => ref.current);
  const portal = usePortal(), portalElement = typeof portalProp == "string" ? ((_a = portal.elements) == null ? void 0 : _a[portalProp]) || null : portal.element, middleware2 = (0, import_react52.useMemo)(() => {
    const ret = [];
    return ret.push(flip3({
      boundary: boundaryElement || void 0,
      fallbackPlacements,
      padding: DEFAULT_TOOLTIP_PADDING,
      rootBoundary
    })), ret.push(offset3({
      mainAxis: DEFAULT_TOOLTIP_DISTANCE
    })), ret.push(shift3({
      boundary: boundaryElement || void 0,
      rootBoundary,
      padding: DEFAULT_TOOLTIP_PADDING
    })), arrowProp && ret.push(arrow3({
      element: arrowRef,
      padding: DEFAULT_TOOLTIP_PADDING
    })), animate2 && ret.push(origin), ret;
  }, [animate2, arrowProp, boundaryElement, fallbackPlacements]), {
    floatingStyles,
    placement,
    middlewareData,
    refs,
    update
  } = useFloating({
    middleware: middleware2,
    placement: placementProp,
    whileElementsMounted: autoUpdate,
    elements: {
      reference: referenceElement
    }
  }), arrowX = (_b = middlewareData.arrow) == null ? void 0 : _b.x, arrowY = (_c = middlewareData.arrow) == null ? void 0 : _c.y, originX = (_d = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _d.originX, originY = (_e2 = middlewareData["@sanity/ui/origin"]) == null ? void 0 : _e2.originY, tooltipId = (0, import_react52.useId)(), [isOpen, setIsOpen] = useDelayedState(false), delayGroupContext = useTooltipDelayGroup(), {
    setIsGroupActive,
    setOpenTooltipId
  } = delayGroupContext || {}, showTooltip = isOpen || (delayGroupContext == null ? void 0 : delayGroupContext.openTooltipId) === tooltipId, isInsideGroup = delayGroupContext !== null, openDelayProp = typeof delay2 == "number" ? delay2 : (delay2 == null ? void 0 : delay2.open) || 0, closeDelayProp = typeof delay2 == "number" ? delay2 : (delay2 == null ? void 0 : delay2.close) || 0, openDelay = isInsideGroup ? delayGroupContext.openDelay : openDelayProp, closeDelay = isInsideGroup ? delayGroupContext.closeDelay : closeDelayProp, handleIsOpenChange = (0, import_react52.useCallback)((open, immediate) => {
    if (isInsideGroup)
      if (open) {
        const groupedOpenDelay = immediate ? 0 : openDelay;
        setIsGroupActive == null ? void 0 : setIsGroupActive(open, groupedOpenDelay), setOpenTooltipId == null ? void 0 : setOpenTooltipId(tooltipId, groupedOpenDelay);
      } else {
        const groupDeactivateDelay = closeDelay > 200 ? closeDelay : 200;
        setIsGroupActive == null ? void 0 : setIsGroupActive(open, groupDeactivateDelay), setOpenTooltipId == null ? void 0 : setOpenTooltipId(null, immediate ? 0 : closeDelay);
      }
    else
      setIsOpen(open, immediate ? 0 : open ? openDelay : closeDelay);
  }, [isInsideGroup, openDelay, setIsGroupActive, setOpenTooltipId, tooltipId, closeDelay, setIsOpen]), handleBlur = (0, import_react52.useCallback)((e) => {
    var _a2, _b2;
    handleIsOpenChange(false), (_b2 = (_a2 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a2.onBlur) == null ? void 0 : _b2.call(_a2, e);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]), handleClick = (0, import_react52.useCallback)((e_0) => {
    var _a2, _b2;
    handleIsOpenChange(false, true), (_b2 = childProp == null ? void 0 : (_a2 = childProp.props).onClick) == null ? void 0 : _b2.call(_a2, e_0);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]), handleContextMenu = (0, import_react52.useCallback)((e_1) => {
    var _a2, _b2;
    handleIsOpenChange(false, true), (_b2 = childProp == null ? void 0 : (_a2 = childProp.props).onContextMenu) == null ? void 0 : _b2.call(_a2, e_1);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]), handleFocus = (0, import_react52.useCallback)((e_2) => {
    var _a2, _b2;
    handleIsOpenChange(true), (_b2 = (_a2 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a2.onFocus) == null ? void 0 : _b2.call(_a2, e_2);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]), handleMouseEnter = (0, import_react52.useCallback)((e_3) => {
    var _a2, _b2;
    handleIsOpenChange(true), (_b2 = (_a2 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a2.onMouseEnter) == null ? void 0 : _b2.call(_a2, e_3);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]), handleMouseLeave = (0, import_react52.useCallback)((e_4) => {
    var _a2, _b2;
    handleIsOpenChange(false), (_b2 = (_a2 = childProp == null ? void 0 : childProp.props) == null ? void 0 : _a2.onMouseLeave) == null ? void 0 : _b2.call(_a2, e_4);
  }, [childProp == null ? void 0 : childProp.props, handleIsOpenChange]);
  useCloseOnMouseLeave({
    handleIsOpenChange,
    referenceElement,
    showTooltip,
    isInsideGroup
  }), (0, import_react52.useEffect)(() => {
    disabled && showTooltip && handleIsOpenChange(false);
  }, [disabled, handleIsOpenChange, showTooltip]), (0, import_react52.useEffect)(() => {
    !content2 && showTooltip && handleIsOpenChange(false);
  }, [content2, handleIsOpenChange, showTooltip]), (0, import_react52.useEffect)(() => {
    if (!showTooltip) return;
    function handleWindowKeyDown(event) {
      event.key === "Escape" && handleIsOpenChange(false, true);
    }
    return window.addEventListener("keydown", handleWindowKeyDown), () => {
      window.removeEventListener("keydown", handleWindowKeyDown);
    };
  }, [handleIsOpenChange, showTooltip]), (0, import_react52.useLayoutEffect)(() => {
    const availableWidths = [...boundaryElement ? [boundaryElement.offsetWidth] : [], (portalElement == null ? void 0 : portalElement.offsetWidth) || document.body.offsetWidth];
    setTooltipMaxWidth(Math.min(...availableWidths) - DEFAULT_TOOLTIP_PADDING * 2);
  }, [boundaryElement, portalElement]);
  const setArrow = (0, import_react52.useCallback)((arrowEl) => {
    arrowRef.current = arrowEl, update();
  }, [update]), setFloating = (0, import_react52.useCallback)((node2) => {
    ref.current = node2, refs.setFloating(node2);
  }, [refs]), child = (0, import_react52.useMemo)(() => childProp ? (0, import_react52.cloneElement)(childProp, {
    onBlur: handleBlur,
    onFocus: handleFocus,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onClick: handleClick,
    onContextMenu: handleContextMenu,
    ref: setReferenceElement
  }) : null, [childProp, handleBlur, handleClick, handleContextMenu, handleFocus, handleMouseEnter, handleMouseLeave]);
  if ((0, import_react52.useImperativeHandle)(childProp ? getElementRef(childProp) : null, () => referenceElement, [referenceElement]), !child) return (0, import_jsx_runtime12.jsx)(import_jsx_runtime12.Fragment, {});
  if (disabled) return child;
  const tooltip = (0, import_jsx_runtime12.jsx)(StyledTooltip, { "data-ui": "Tooltip", ...restProps, ref: setFloating, style: {
    ...floatingStyles,
    maxWidth: tooltipMaxWidth > 0 ? `${tooltipMaxWidth}px` : void 0
  }, zOffset, children: (0, import_jsx_runtime12.jsx)(TooltipCard, { ...restProps, animate: animate2, arrow: arrowProp, arrowRef: setArrow, arrowX, arrowY, originX, originY, padding, placement, radius, ref: setFloating, scheme, shadow, children: content2 }) }), children = showTooltip && (portalProp ? (0, import_jsx_runtime12.jsx)(Portal, { __unstable_name: typeof portalProp == "string" ? portalProp : void 0, children: tooltip }) : tooltip);
  return (0, import_jsx_runtime12.jsxs)(import_jsx_runtime12.Fragment, { children: [
    animate2 ? (0, import_jsx_runtime12.jsx)(AnimatePresence, { children }) : children,
    child
  ] });
});
Tooltip.displayName = "ForwardRef(Tooltip)";
function useCloseOnMouseLeave(t0) {
  const $2 = (0, import_react_compiler_runtime.c)(10), {
    handleIsOpenChange,
    referenceElement,
    showTooltip,
    isInsideGroup
  } = t0;
  let t1;
  $2[0] !== handleIsOpenChange || $2[1] !== referenceElement ? (t1 = (target, teardown) => {
    referenceElement && (referenceElement === target || target instanceof Node && referenceElement.contains(target) || (handleIsOpenChange(false), teardown()));
  }, $2[0] = handleIsOpenChange, $2[1] = referenceElement, $2[2] = t1) : t1 = $2[2];
  const onMouseMove = useEffectEvent(t1);
  let t2;
  $2[3] !== isInsideGroup || $2[4] !== onMouseMove || $2[5] !== showTooltip ? (t2 = () => {
    if (!showTooltip || isInsideGroup)
      return;
    const handleMouseMove = (event) => {
      onMouseMove(event.target, () => window.removeEventListener("mousemove", handleMouseMove));
    };
    return window.addEventListener("mousemove", handleMouseMove), () => window.removeEventListener("mousemove", handleMouseMove);
  }, $2[3] = isInsideGroup, $2[4] = onMouseMove, $2[5] = showTooltip, $2[6] = t2) : t2 = $2[6];
  let t3;
  $2[7] !== isInsideGroup || $2[8] !== showTooltip ? (t3 = [isInsideGroup, showTooltip], $2[7] = isInsideGroup, $2[8] = showTooltip, $2[9] = t3) : t3 = $2[9], (0, import_react52.useEffect)(t2, t3);
}
var StyledHotkeys = dt.kbd.withConfig({
  displayName: "StyledHotkeys",
  componentId: "sc-b37mge-0"
})`font:inherit;padding:1px;&:not([hidden]){display:block;}`;
var Key = dt(KBD).withConfig({
  displayName: "Key",
  componentId: "sc-b37mge-1"
})`&:not([hidden]){display:block;}`;
var Hotkeys = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(24);
  let fontSize2, keys, padding, radius, restProps, t0;
  $2[0] !== props ? ({
    fontSize: fontSize2,
    keys,
    padding,
    radius,
    space: t0,
    ...restProps
  } = props, $2[0] = props, $2[1] = fontSize2, $2[2] = keys, $2[3] = padding, $2[4] = radius, $2[5] = restProps, $2[6] = t0) : (fontSize2 = $2[1], keys = $2[2], padding = $2[3], radius = $2[4], restProps = $2[5], t0 = $2[6]);
  const space = useArrayProp(t0 === void 0 ? 0.5 : t0);
  if (!keys || keys.length === 0) {
    let t12;
    return $2[7] === Symbol.for("react.memo_cache_sentinel") ? (t12 = (0, import_jsx_runtime12.jsx)(import_jsx_runtime12.Fragment, {}), $2[7] = t12) : t12 = $2[7], t12;
  }
  let t1;
  if ($2[8] !== fontSize2 || $2[9] !== keys || $2[10] !== padding || $2[11] !== radius) {
    let t22;
    $2[13] !== fontSize2 || $2[14] !== padding || $2[15] !== radius ? (t22 = (key2, i2) => (0, import_jsx_runtime12.jsx)(Key, { fontSize: fontSize2, padding, radius, children: key2 }, i2), $2[13] = fontSize2, $2[14] = padding, $2[15] = radius, $2[16] = t22) : t22 = $2[16], t1 = keys.map(t22), $2[8] = fontSize2, $2[9] = keys, $2[10] = padding, $2[11] = radius, $2[12] = t1;
  } else
    t1 = $2[12];
  let t2;
  $2[17] !== space || $2[18] !== t1 ? (t2 = (0, import_jsx_runtime12.jsx)(Inline, { as: "span", space, children: t1 }), $2[17] = space, $2[18] = t1, $2[19] = t2) : t2 = $2[19];
  let t3;
  return $2[20] !== ref || $2[21] !== restProps || $2[22] !== t2 ? (t3 = (0, import_jsx_runtime12.jsx)(StyledHotkeys, { "data-ui": "Hotkeys", ...restProps, ref, children: t2 }), $2[20] = ref, $2[21] = restProps, $2[22] = t2, $2[23] = t3) : t3 = $2[23], t3;
});
Hotkeys.displayName = "ForwardRef(Hotkeys)";
var MenuContext = createGlobalScopedContext("@sanity/ui/context/menu", null);
function _isFocusable(element) {
  return isHTMLAnchorElement(element) && element.getAttribute("data-disabled") !== "true" || isHTMLButtonElement(element) && !element.disabled;
}
function _getFocusableElements(elements) {
  return elements.filter(_isFocusable);
}
function _getDOMPath(rootElement, el) {
  const path = [];
  let e = el;
  for (; e !== rootElement; ) {
    const parentElement = e.parentElement;
    if (!parentElement) return path;
    const index2 = Array.from(parentElement.childNodes).indexOf(e);
    if (path.unshift(index2), parentElement === rootElement)
      return path;
    e = parentElement;
  }
  return path;
}
var EMPTY_PATH = [];
function _sortElements(rootElement, elements) {
  if (!rootElement) return;
  const map = /* @__PURE__ */ new WeakMap();
  for (const el of elements)
    map.set(el, _getDOMPath(rootElement, el));
  const _sort = (a2, b2) => {
    const _a = map.get(a2) || EMPTY_PATH, _b = map.get(b2) || EMPTY_PATH, len = Math.max(_a.length, _b.length);
    for (let i2 = 0; i2 < len; i2 += 1) {
      const aIndex = _a[i2] || -1, bIndex = _b[i2] || -1;
      if (aIndex !== bIndex)
        return aIndex - bIndex;
    }
    return 0;
  };
  elements.sort(_sort);
}
function useMenuController(props) {
  const {
    onKeyDown,
    originElement,
    shouldFocus,
    rootElementRef
  } = props, elementsRef = (0, import_react52.useRef)([]), [activeIndex, _setActiveIndex] = (0, import_react52.useState)(-1), activeIndexRef = (0, import_react52.useRef)(activeIndex), activeElement = (0, import_react52.useMemo)(() => elementsRef.current[activeIndex] || null, [activeIndex]), mounted = !!rootElementRef.current, setActiveIndex = (0, import_react52.useCallback)((nextActiveIndex) => {
    _setActiveIndex(nextActiveIndex), activeIndexRef.current = nextActiveIndex;
  }, []), mount = (0, import_react52.useCallback)((element, selected) => {
    if (!element) return () => {
    };
    if (elementsRef.current.indexOf(element) === -1 && (elementsRef.current.push(element), _sortElements(rootElementRef.current, elementsRef.current)), selected) {
      const selectedIndex = elementsRef.current.indexOf(element);
      setActiveIndex(selectedIndex);
    }
    return () => {
      const idx = elementsRef.current.indexOf(element);
      idx > -1 && elementsRef.current.splice(idx, 1);
    };
  }, [rootElementRef, setActiveIndex]), handleKeyDown = (0, import_react52.useCallback)((event) => {
    if (event.key === "Tab") {
      originElement && originElement.focus();
      return;
    }
    if (event.key === "Home") {
      event.preventDefault(), event.stopPropagation();
      const el = _getFocusableElements(elementsRef.current)[0];
      if (!el) return;
      const currentIndex = elementsRef.current.indexOf(el);
      setActiveIndex(currentIndex);
      return;
    }
    if (event.key === "End") {
      event.preventDefault(), event.stopPropagation();
      const focusableElements_0 = _getFocusableElements(elementsRef.current), el_0 = focusableElements_0[focusableElements_0.length - 1];
      if (!el_0) return;
      const currentIndex_0 = elementsRef.current.indexOf(el_0);
      setActiveIndex(currentIndex_0);
      return;
    }
    if (event.key === "ArrowUp") {
      event.preventDefault(), event.stopPropagation();
      const focusableElements_1 = _getFocusableElements(elementsRef.current), focusableLen = focusableElements_1.length;
      if (focusableLen === 0) return;
      const focusedElement = elementsRef.current[activeIndexRef.current];
      let focusedIndex = focusableElements_1.indexOf(focusedElement);
      focusedIndex = (focusedIndex - 1 + focusableLen) % focusableLen;
      const el_1 = focusableElements_1[focusedIndex], currentIndex_1 = elementsRef.current.indexOf(el_1);
      setActiveIndex(currentIndex_1);
      return;
    }
    if (event.key === "ArrowDown") {
      event.preventDefault(), event.stopPropagation();
      const focusableElements_2 = _getFocusableElements(elementsRef.current), focusableLen_0 = focusableElements_2.length;
      if (focusableLen_0 === 0) return;
      const focusedElement_0 = elementsRef.current[activeIndexRef.current];
      let focusedIndex_0 = focusableElements_2.indexOf(focusedElement_0);
      focusedIndex_0 = (focusedIndex_0 + 1) % focusableLen_0;
      const el_2 = focusableElements_2[focusedIndex_0], currentIndex_2 = elementsRef.current.indexOf(el_2);
      setActiveIndex(currentIndex_2);
      return;
    }
    onKeyDown && onKeyDown(event);
  }, [onKeyDown, originElement, setActiveIndex]), handleItemMouseEnter = (0, import_react52.useCallback)((event_0) => {
    const element_0 = event_0.currentTarget, currentIndex_3 = elementsRef.current.indexOf(element_0);
    setActiveIndex(currentIndex_3);
  }, [setActiveIndex]), handleItemMouseLeave = (0, import_react52.useCallback)(() => {
    var _a;
    setActiveIndex(-2), (_a = rootElementRef.current) == null ? void 0 : _a.focus();
  }, [rootElementRef, setActiveIndex]);
  return (0, import_react52.useEffect)(() => {
    if (!mounted) return;
    const rafId = requestAnimationFrame(() => {
      var _a;
      if (activeIndex === -1) {
        if (shouldFocus === "first") {
          const el_3 = _getFocusableElements(elementsRef.current)[0];
          if (el_3) {
            const currentIndex_4 = elementsRef.current.indexOf(el_3);
            setActiveIndex(currentIndex_4);
          }
        }
        if (shouldFocus === "last") {
          const focusableElements_4 = _getFocusableElements(elementsRef.current), el_4 = focusableElements_4[focusableElements_4.length - 1];
          if (el_4) {
            const currentIndex_5 = elementsRef.current.indexOf(el_4);
            setActiveIndex(currentIndex_5);
          }
        }
        return;
      }
      (_a = elementsRef.current[activeIndex] || null) == null ? void 0 : _a.focus();
    });
    return () => cancelAnimationFrame(rafId);
  }, [activeIndex, mounted, setActiveIndex, shouldFocus]), {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount
  };
}
var StyledMenu = dt(Box).withConfig({
  displayName: "StyledMenu",
  componentId: "sc-xt0tnv-0"
})`outline:none;overflow:auto;`;
var Menu = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(50);
  let _shouldFocus, children, onClickOutside, onEscape, onItemClick, onItemSelect, onKeyDown, originElement, registerElement, restProps, t0, t1;
  if ($2[0] !== props) {
    const {
      children: t22,
      focusFirst,
      focusLast,
      onClickOutside: t32,
      onEscape: t42,
      onItemClick: t52,
      onItemSelect: t62,
      onKeyDown: t72,
      originElement: t82,
      padding: t92,
      registerElement: t102,
      shouldFocus: t112,
      space: t122,
      ...t132
    } = props;
    children = t22, onClickOutside = t32, onEscape = t42, onItemClick = t52, onItemSelect = t62, onKeyDown = t72, originElement = t82, t0 = t92, registerElement = t102, _shouldFocus = t112, t1 = t122, restProps = t132, $2[0] = props, $2[1] = _shouldFocus, $2[2] = children, $2[3] = onClickOutside, $2[4] = onEscape, $2[5] = onItemClick, $2[6] = onItemSelect, $2[7] = onKeyDown, $2[8] = originElement, $2[9] = registerElement, $2[10] = restProps, $2[11] = t0, $2[12] = t1;
  } else
    _shouldFocus = $2[1], children = $2[2], onClickOutside = $2[3], onEscape = $2[4], onItemClick = $2[5], onItemSelect = $2[6], onKeyDown = $2[7], originElement = $2[8], registerElement = $2[9], restProps = $2[10], t0 = $2[11], t1 = $2[12];
  const padding = t0 === void 0 ? 1 : t0, space = t1 === void 0 ? 1 : t1, shouldFocus = _shouldFocus ?? (props.focusFirst && "first" || props.focusLast && "last" || null), ref = (0, import_react52.useRef)(null);
  let t2;
  $2[13] === Symbol.for("react.memo_cache_sentinel") ? (t2 = () => ref.current, $2[13] = t2) : t2 = $2[13], (0, import_react52.useImperativeHandle)(forwardedRef, t2);
  const {
    isTopLayer: isTopLayer2
  } = useLayer();
  let t3;
  $2[14] !== onKeyDown || $2[15] !== originElement || $2[16] !== shouldFocus ? (t3 = {
    onKeyDown,
    originElement,
    shouldFocus,
    rootElementRef: ref
  }, $2[14] = onKeyDown, $2[15] = originElement, $2[16] = shouldFocus, $2[17] = t3) : t3 = $2[17];
  const {
    activeElement,
    activeIndex,
    handleItemMouseEnter,
    handleItemMouseLeave,
    handleKeyDown,
    mount
  } = useMenuController(t3), unregisterElementRef = (0, import_react52.useRef)(null);
  let t4;
  $2[18] !== registerElement ? (t4 = (el) => {
    unregisterElementRef.current && (unregisterElementRef.current(), unregisterElementRef.current = null), ref.current = el, ref.current && registerElement && (unregisterElementRef.current = registerElement(ref.current));
  }, $2[18] = registerElement, $2[19] = t4) : t4 = $2[19];
  const handleRefChange = t4;
  let t5, t6;
  $2[20] !== activeIndex || $2[21] !== onItemSelect ? (t5 = () => {
    onItemSelect && onItemSelect(activeIndex);
  }, t6 = [activeIndex, onItemSelect], $2[20] = activeIndex, $2[21] = onItemSelect, $2[22] = t5, $2[23] = t6) : (t5 = $2[22], t6 = $2[23]), (0, import_react52.useEffect)(t5, t6);
  let t7;
  $2[24] === Symbol.for("react.memo_cache_sentinel") ? (t7 = () => [ref.current], $2[24] = t7) : t7 = $2[24], useClickOutsideEvent(isTopLayer2 && onClickOutside, t7);
  let t8;
  $2[25] !== isTopLayer2 || $2[26] !== onEscape ? (t8 = (event) => {
    isTopLayer2 && event.key === "Escape" && (event.stopPropagation(), onEscape && onEscape());
  }, $2[25] = isTopLayer2, $2[26] = onEscape, $2[27] = t8) : t8 = $2[27], useGlobalKeyDown(t8);
  let t9, t10;
  $2[28] !== activeElement || $2[29] !== activeIndex || $2[30] !== handleItemMouseEnter || $2[31] !== handleItemMouseLeave || $2[32] !== mount || $2[33] !== onClickOutside || $2[34] !== onEscape || $2[35] !== onItemClick || $2[36] !== registerElement ? (t10 = {
    version: 0,
    activeElement,
    activeIndex,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter: handleItemMouseEnter,
    onItemMouseLeave: handleItemMouseLeave,
    registerElement,
    onMouseEnter: handleItemMouseEnter,
    onMouseLeave: handleItemMouseLeave
  }, $2[28] = activeElement, $2[29] = activeIndex, $2[30] = handleItemMouseEnter, $2[31] = handleItemMouseLeave, $2[32] = mount, $2[33] = onClickOutside, $2[34] = onEscape, $2[35] = onItemClick, $2[36] = registerElement, $2[37] = t10) : t10 = $2[37], t9 = t10;
  const value = t9;
  let t11;
  $2[38] !== children || $2[39] !== space ? (t11 = (0, import_jsx_runtime12.jsx)(Stack, { space, children }), $2[38] = children, $2[39] = space, $2[40] = t11) : t11 = $2[40];
  let t12;
  $2[41] !== handleKeyDown || $2[42] !== handleRefChange || $2[43] !== padding || $2[44] !== restProps || $2[45] !== t11 ? (t12 = (0, import_jsx_runtime12.jsx)(StyledMenu, { "data-ui": "Menu", ...restProps, onKeyDown: handleKeyDown, padding, ref: handleRefChange, role: "menu", tabIndex: -1, children: t11 }), $2[41] = handleKeyDown, $2[42] = handleRefChange, $2[43] = padding, $2[44] = restProps, $2[45] = t11, $2[46] = t12) : t12 = $2[46];
  let t13;
  return $2[47] !== t12 || $2[48] !== value ? (t13 = (0, import_jsx_runtime12.jsx)(MenuContext.Provider, { value, children: t12 }), $2[47] = t12, $2[48] = value, $2[49] = t13) : t13 = $2[49], t13;
});
Menu.displayName = "ForwardRef(Menu)";
var MenuDivider = dt.hr.withConfig({
  displayName: "MenuDivider",
  componentId: "sc-uhoxwu-0"
})`height:1px;border:0;background:var(--card-hairline-soft-color);margin:0;`;
MenuDivider.displayName = "MenuDivider";
function selectableBaseStyle() {
  return lt`
    background-color: inherit;
    color: inherit;

    &[data-as='button'] {
      -webkit-font-smoothing: inherit;
      appearance: none;
      outline: none;
      font: inherit;
      text-align: inherit;
      border: 0;
      width: -moz-available;
      width: -webkit-fill-available;
      width: stretch;
    }

    /* &:is(a) */
    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function selectableColorStyle(props) {
  var _a;
  const {
    $tone
  } = props, {
    color: color3,
    style
  } = getTheme_v2(props.theme), tone = color3.selectable[$tone];
  return lt`
    ${_cardColorStyle(color3, tone.enabled)}

    background-color: var(--card-bg-color);
    color: var(--card-fg-color);
    outline: none;

    /* &:is(button) */
    &[data-as='button'] {
      &:disabled {
        ${_cardColorStyle(color3, tone.disabled)}
      }

      &:not(:disabled) {
        &[aria-pressed='true'] {
          ${_cardColorStyle(color3, tone.pressed)}
        }

        &[data-selected],
        &[aria-selected='true'] > & {
          ${_cardColorStyle(color3, tone.selected)}
        }

        @media (hover: hover) {
          &:not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color3, tone.hovered)}
            }

            &:active {
              ${_cardColorStyle(color3, tone.pressed)}
            }
          }
        }
      }
    }

    /* &:is(a) */
    &[data-as='a'] {
      &[data-disabled] {
        ${_cardColorStyle(color3, tone.disabled)}
      }

      &:not([data-disabled]) {
        &[data-pressed] {
          ${_cardColorStyle(color3, tone.pressed)}
        }

        &[data-selected] {
          ${_cardColorStyle(color3, tone.selected)}
        }

        @media (hover: hover) {
          &:not([data-selected]) {
            &[data-hovered],
            &:hover {
              ${_cardColorStyle(color3, tone.hovered)}
            }
            &:active {
              ${_cardColorStyle(color3, tone.pressed)}
            }
          }
        }
      }
    }

    ${(_a = style == null ? void 0 : style.card) == null ? void 0 : _a.root}
  `;
}
var Selectable = dt(Box).withConfig({
  displayName: "Selectable",
  componentId: "sc-1w01ang-0"
})(responsiveRadiusStyle, selectableBaseStyle, selectableColorStyle);
Selectable.displayName = "Selectable";
function useMenu() {
  const value = (0, import_react52.useContext)(MenuContext);
  if (!value)
    throw new Error("useMenu(): missing context value");
  if (!isRecord2(value) || value.version !== 0)
    throw new Error("useMenu(): the context value is not compatible");
  return value;
}
function MenuGroup(props) {
  const $2 = (0, import_react_compiler_runtime.c)(79);
  let IconComponent, children, menuProps, onClick, popover, restProps, t0, t1, t2, t3, t4, t5, text;
  $2[0] !== props ? ({
    as: t0,
    children,
    fontSize: t1,
    icon: IconComponent,
    menu: menuProps,
    onClick,
    padding: t2,
    popover,
    radius: t3,
    space: t4,
    text,
    tone: t5,
    ...restProps
  } = props, $2[0] = props, $2[1] = IconComponent, $2[2] = children, $2[3] = menuProps, $2[4] = onClick, $2[5] = popover, $2[6] = restProps, $2[7] = t0, $2[8] = t1, $2[9] = t2, $2[10] = t3, $2[11] = t4, $2[12] = t5, $2[13] = text) : (IconComponent = $2[1], children = $2[2], menuProps = $2[3], onClick = $2[4], popover = $2[5], restProps = $2[6], t0 = $2[7], t1 = $2[8], t2 = $2[9], t3 = $2[10], t4 = $2[11], t5 = $2[12], text = $2[13]);
  const as = t0 === void 0 ? "button" : t0, fontSize2 = t1 === void 0 ? 1 : t1, padding = t2 === void 0 ? 3 : t2, radius = t3 === void 0 ? 2 : t3, space = t4 === void 0 ? 3 : t4, tone = t5 === void 0 ? "default" : t5, menu = useMenu(), {
    scheme
  } = useRootTheme(), {
    activeElement,
    mount,
    onClickOutside,
    onEscape,
    onItemClick,
    onItemMouseEnter: _onItemMouseEnter,
    registerElement
  } = menu, onItemMouseEnter = _onItemMouseEnter ?? menu.onMouseEnter, [rootElement, setRootElement] = (0, import_react52.useState)(null), [open, setOpen] = (0, import_react52.useState)(false), [shouldFocus, setShouldFocus] = (0, import_react52.useState)(null), active = !!activeElement && activeElement === rootElement, [withinMenu, setWithinMenu] = (0, import_react52.useState)(false);
  let t6;
  $2[14] !== onItemMouseEnter ? (t6 = (event) => {
    setWithinMenu(false), onItemMouseEnter(event), setOpen(true);
  }, $2[14] = onItemMouseEnter, $2[15] = t6) : t6 = $2[15];
  const handleMouseEnter = t6;
  let t7;
  $2[16] !== rootElement ? (t7 = (event_0) => {
    event_0.key === "ArrowLeft" && (event_0.stopPropagation(), setOpen(false), requestAnimationFrame(() => {
      rootElement == null ? void 0 : rootElement.focus();
    }));
  }, $2[16] = rootElement, $2[17] = t7) : t7 = $2[17];
  const handleMenuKeyDown = t7;
  let t8;
  $2[18] !== onClick ? (t8 = (event_1) => {
    onClick == null ? void 0 : onClick(event_1), setShouldFocus("first"), setOpen(true);
  }, $2[18] = onClick, $2[19] = t8) : t8 = $2[19];
  const handleClick = t8;
  let t9;
  $2[20] !== onItemClick ? (t9 = () => {
    setOpen(false), onItemClick == null ? void 0 : onItemClick();
  }, $2[20] = onItemClick, $2[21] = t9) : t9 = $2[21];
  const handleChildItemClick = t9;
  let t10;
  $2[22] === Symbol.for("react.memo_cache_sentinel") ? (t10 = () => setWithinMenu(true), $2[22] = t10) : t10 = $2[22];
  const handleMenuMouseEnter = t10;
  let t11, t12;
  $2[23] !== mount || $2[24] !== rootElement ? (t11 = () => mount(rootElement), t12 = [mount, rootElement], $2[23] = mount, $2[24] = rootElement, $2[25] = t11, $2[26] = t12) : (t11 = $2[25], t12 = $2[26]), (0, import_react52.useEffect)(t11, t12);
  let t13, t14;
  $2[27] !== active ? (t13 = () => {
    active || setOpen(false);
  }, t14 = [active], $2[27] = active, $2[28] = t13, $2[29] = t14) : (t13 = $2[28], t14 = $2[29]), (0, import_react52.useEffect)(t13, t14);
  let t15, t16;
  $2[30] !== open ? (t15 = () => {
    open || setWithinMenu(false);
  }, t16 = [open], $2[30] = open, $2[31] = t15, $2[32] = t16) : (t15 = $2[31], t16 = $2[32]), (0, import_react52.useEffect)(t15, t16);
  let t17, t18;
  $2[33] !== shouldFocus ? (t17 = () => {
    if (!shouldFocus)
      return;
    const rafId = requestAnimationFrame(() => setShouldFocus(null));
    return () => cancelAnimationFrame(rafId);
  }, t18 = [shouldFocus], $2[33] = shouldFocus, $2[34] = t17, $2[35] = t18) : (t17 = $2[34], t18 = $2[35]), (0, import_react52.useEffect)(t17, t18);
  let t19;
  $2[36] !== children || $2[37] !== handleChildItemClick || $2[38] !== handleMenuKeyDown || $2[39] !== menuProps || $2[40] !== onClickOutside || $2[41] !== onEscape || $2[42] !== registerElement || $2[43] !== shouldFocus ? (t19 = (0, import_jsx_runtime12.jsx)(Menu, { ...menuProps, onClickOutside, onEscape, onItemClick: handleChildItemClick, onKeyDown: handleMenuKeyDown, onMouseEnter: handleMenuMouseEnter, registerElement, shouldFocus, children }), $2[36] = children, $2[37] = handleChildItemClick, $2[38] = handleMenuKeyDown, $2[39] = menuProps, $2[40] = onClickOutside, $2[41] = onEscape, $2[42] = registerElement, $2[43] = shouldFocus, $2[44] = t19) : t19 = $2[44];
  const childMenu = t19;
  let t20;
  $2[45] === Symbol.for("react.memo_cache_sentinel") ? (t20 = (event_2) => {
    const target = event_2.currentTarget;
    if (document.activeElement === target && event_2.key === "ArrowRight") {
      setShouldFocus("first"), setOpen(true), setWithinMenu(true);
      return;
    }
  }, $2[45] = t20) : t20 = $2[45];
  const handleKeyDown = t20, t21 = as === "button" ? withinMenu : void 0, t22 = as !== "button" ? withinMenu : void 0, t23 = !withinMenu && active ? "" : void 0, t24 = useArrayProp(radius), t25 = as === "button" ? "button" : void 0;
  let t26;
  $2[46] !== IconComponent || $2[47] !== fontSize2 ? (t26 = IconComponent && (0, import_jsx_runtime12.jsxs)(Text, { size: fontSize2, children: [
    (0, import_react52.isValidElement)(IconComponent) && IconComponent,
    (0, import_react_is.isValidElementType)(IconComponent) && (0, import_jsx_runtime12.jsx)(IconComponent, {})
  ] }), $2[46] = IconComponent, $2[47] = fontSize2, $2[48] = t26) : t26 = $2[48];
  let t27;
  $2[49] !== fontSize2 || $2[50] !== text ? (t27 = (0, import_jsx_runtime12.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime12.jsx)(Text, { size: fontSize2, textOverflow: "ellipsis", weight: "medium", children: text }) }), $2[49] = fontSize2, $2[50] = text, $2[51] = t27) : t27 = $2[51];
  let t28;
  $2[52] === Symbol.for("react.memo_cache_sentinel") ? (t28 = (0, import_jsx_runtime12.jsx)(ChevronRightIcon, {}), $2[52] = t28) : t28 = $2[52];
  let t29;
  $2[53] !== fontSize2 ? (t29 = (0, import_jsx_runtime12.jsx)(Text, { size: fontSize2, children: t28 }), $2[53] = fontSize2, $2[54] = t29) : t29 = $2[54];
  let t30;
  $2[55] !== padding || $2[56] !== space || $2[57] !== t26 || $2[58] !== t27 || $2[59] !== t29 ? (t30 = (0, import_jsx_runtime12.jsxs)(Flex, { gap: space, padding, children: [
    t26,
    t27,
    t29
  ] }), $2[55] = padding, $2[56] = space, $2[57] = t26, $2[58] = t27, $2[59] = t29, $2[60] = t30) : t30 = $2[60];
  let t31;
  $2[61] !== as || $2[62] !== handleClick || $2[63] !== handleMouseEnter || $2[64] !== restProps || $2[65] !== scheme || $2[66] !== t21 || $2[67] !== t22 || $2[68] !== t23 || $2[69] !== t24 || $2[70] !== t25 || $2[71] !== t30 || $2[72] !== tone ? (t31 = (0, import_jsx_runtime12.jsx)(Selectable, { "data-as": as, "data-ui": "MenuGroup", forwardedAs: as, ...restProps, "aria-pressed": t21, "data-pressed": t22, "data-selected": t23, $radius: t24, $tone: tone, $scheme: scheme, onClick: handleClick, onKeyDown: handleKeyDown, onMouseEnter: handleMouseEnter, ref: setRootElement, tabIndex: -1, type: t25, children: t30 }), $2[61] = as, $2[62] = handleClick, $2[63] = handleMouseEnter, $2[64] = restProps, $2[65] = scheme, $2[66] = t21, $2[67] = t22, $2[68] = t23, $2[69] = t24, $2[70] = t25, $2[71] = t30, $2[72] = tone, $2[73] = t31) : t31 = $2[73];
  let t32;
  return $2[74] !== childMenu || $2[75] !== open || $2[76] !== popover || $2[77] !== t31 ? (t32 = (0, import_jsx_runtime12.jsx)(Popover, { ...popover, content: childMenu, "data-ui": "MenuGroup__popover", open, children: t31 }), $2[74] = childMenu, $2[75] = open, $2[76] = popover, $2[77] = t31, $2[78] = t32) : t32 = $2[78], t32;
}
MenuGroup.displayName = "MenuGroup";
var MenuItem = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(73);
  let IconComponent, IconRightComponent, children, disabled, hotkeys, onClick, paddingBottom, paddingLeft, paddingRight, paddingTop, paddingX, paddingY, pressed, restProps, selectedProp, t0, t1, t2, t3, t4, t5, text;
  $2[0] !== props ? ({
    as: t0,
    children,
    disabled,
    fontSize: t1,
    hotkeys,
    icon: IconComponent,
    iconRight: IconRightComponent,
    onClick,
    padding: t2,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft,
    pressed,
    radius: t3,
    selected: selectedProp,
    space: t4,
    text,
    tone: t5,
    ...restProps
  } = props, $2[0] = props, $2[1] = IconComponent, $2[2] = IconRightComponent, $2[3] = children, $2[4] = disabled, $2[5] = hotkeys, $2[6] = onClick, $2[7] = paddingBottom, $2[8] = paddingLeft, $2[9] = paddingRight, $2[10] = paddingTop, $2[11] = paddingX, $2[12] = paddingY, $2[13] = pressed, $2[14] = restProps, $2[15] = selectedProp, $2[16] = t0, $2[17] = t1, $2[18] = t2, $2[19] = t3, $2[20] = t4, $2[21] = t5, $2[22] = text) : (IconComponent = $2[1], IconRightComponent = $2[2], children = $2[3], disabled = $2[4], hotkeys = $2[5], onClick = $2[6], paddingBottom = $2[7], paddingLeft = $2[8], paddingRight = $2[9], paddingTop = $2[10], paddingX = $2[11], paddingY = $2[12], pressed = $2[13], restProps = $2[14], selectedProp = $2[15], t0 = $2[16], t1 = $2[17], t2 = $2[18], t3 = $2[19], t4 = $2[20], t5 = $2[21], text = $2[22]);
  const as = t0 === void 0 ? "button" : t0, fontSize2 = t1 === void 0 ? 1 : t1, padding = t2 === void 0 ? 3 : t2, radius = t3 === void 0 ? 2 : t3, space = t4 === void 0 ? 3 : t4, tone = t5 === void 0 ? "default" : t5, {
    scheme
  } = useRootTheme(), menu = useMenu(), {
    activeElement,
    mount,
    onItemClick,
    onItemMouseEnter: _onItemMouseEnter,
    onItemMouseLeave: _onItemMouseLeave
  } = menu, onItemMouseEnter = _onItemMouseEnter ?? menu.onMouseEnter, onItemMouseLeave = _onItemMouseLeave ?? menu.onMouseLeave, [rootElement, setRootElement] = (0, import_react52.useState)(null), active = !!activeElement && activeElement === rootElement, ref = (0, import_react52.useRef)(null);
  let t6;
  $2[23] === Symbol.for("react.memo_cache_sentinel") ? (t6 = () => ref.current, $2[23] = t6) : t6 = $2[23], (0, import_react52.useImperativeHandle)(forwardedRef, t6);
  let t7, t8;
  $2[24] !== mount || $2[25] !== rootElement || $2[26] !== selectedProp ? (t7 = () => mount(rootElement, selectedProp), t8 = [mount, rootElement, selectedProp], $2[24] = mount, $2[25] = rootElement, $2[26] = selectedProp, $2[27] = t7, $2[28] = t8) : (t7 = $2[27], t8 = $2[28]), (0, import_react52.useEffect)(t7, t8);
  let t9;
  $2[29] !== disabled || $2[30] !== onClick || $2[31] !== onItemClick ? (t9 = (event) => {
    disabled || (onClick && onClick(event), onItemClick && onItemClick());
  }, $2[29] = disabled, $2[30] = onClick, $2[31] = onItemClick, $2[32] = t9) : t9 = $2[32];
  const handleClick = t9;
  let t10, t11;
  $2[33] !== padding || $2[34] !== paddingBottom || $2[35] !== paddingLeft || $2[36] !== paddingRight || $2[37] !== paddingTop || $2[38] !== paddingX || $2[39] !== paddingY ? (t11 = {
    padding,
    paddingX,
    paddingY,
    paddingTop,
    paddingRight,
    paddingBottom,
    paddingLeft
  }, $2[33] = padding, $2[34] = paddingBottom, $2[35] = paddingLeft, $2[36] = paddingRight, $2[37] = paddingTop, $2[38] = paddingX, $2[39] = paddingY, $2[40] = t11) : t11 = $2[40], t10 = t11;
  const paddingProps = t10, t12 = useArrayProp(fontSize2);
  let t13;
  $2[41] !== t12 ? (t13 = t12.map(_temp), $2[41] = t12, $2[42] = t13) : t13 = $2[42];
  const hotkeysFontSize = t13;
  let t14;
  $2[43] === Symbol.for("react.memo_cache_sentinel") ? (t14 = (el) => {
    ref.current = el, setRootElement(el);
  }, $2[43] = t14) : t14 = $2[43];
  const setRef = t14, t15 = as !== "button" && pressed ? "" : void 0, t16 = active ? "" : void 0, t17 = disabled ? "" : void 0, t18 = useArrayProp(radius), t19 = useArrayProp(0), t20 = disabled ? "default" : tone, t21 = as === "button" ? "button" : void 0;
  let t22;
  $2[44] !== IconComponent || $2[45] !== IconRightComponent || $2[46] !== fontSize2 || $2[47] !== hotkeys || $2[48] !== hotkeysFontSize || $2[49] !== paddingProps || $2[50] !== space || $2[51] !== text ? (t22 = (IconComponent || text || IconRightComponent) && (0, import_jsx_runtime12.jsxs)(Flex, { as: "span", gap: space, align: "center", ...paddingProps, children: [
    IconComponent && (0, import_jsx_runtime12.jsxs)(Text, { size: fontSize2, children: [
      (0, import_react52.isValidElement)(IconComponent) && IconComponent,
      (0, import_react_is.isValidElementType)(IconComponent) && (0, import_jsx_runtime12.jsx)(IconComponent, {})
    ] }),
    text && (0, import_jsx_runtime12.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime12.jsx)(Text, { size: fontSize2, textOverflow: "ellipsis", weight: "medium", children: text }) }),
    hotkeys && (0, import_jsx_runtime12.jsx)(Hotkeys, { fontSize: hotkeysFontSize, keys: hotkeys, style: {
      marginTop: -4,
      marginBottom: -4
    } }),
    IconRightComponent && (0, import_jsx_runtime12.jsxs)(Text, { size: fontSize2, children: [
      (0, import_react52.isValidElement)(IconRightComponent) && IconRightComponent,
      (0, import_react_is.isValidElementType)(IconRightComponent) && (0, import_jsx_runtime12.jsx)(IconRightComponent, {})
    ] })
  ] }), $2[44] = IconComponent, $2[45] = IconRightComponent, $2[46] = fontSize2, $2[47] = hotkeys, $2[48] = hotkeysFontSize, $2[49] = paddingProps, $2[50] = space, $2[51] = text, $2[52] = t22) : t22 = $2[52];
  let t23;
  $2[53] !== children || $2[54] !== paddingProps ? (t23 = children && (0, import_jsx_runtime12.jsx)(Box, { as: "span", ...paddingProps, children }), $2[53] = children, $2[54] = paddingProps, $2[55] = t23) : t23 = $2[55];
  let t24;
  return $2[56] !== as || $2[57] !== disabled || $2[58] !== handleClick || $2[59] !== onItemMouseEnter || $2[60] !== onItemMouseLeave || $2[61] !== restProps || $2[62] !== scheme || $2[63] !== t15 || $2[64] !== t16 || $2[65] !== t17 || $2[66] !== t18 || $2[67] !== t19 || $2[68] !== t20 || $2[69] !== t21 || $2[70] !== t22 || $2[71] !== t23 ? (t24 = (0, import_jsx_runtime12.jsxs)(Selectable, { "data-ui": "MenuItem", role: "menuitem", ...restProps, "data-pressed": t15, "data-selected": t16, "data-disabled": t17, forwardedAs: as, $radius: t18, $padding: t19, $tone: t20, $scheme: scheme, disabled, onClick: handleClick, onMouseEnter: onItemMouseEnter, onMouseLeave: onItemMouseLeave, ref: setRef, tabIndex: -1, type: t21, children: [
    t22,
    t23
  ] }), $2[56] = as, $2[57] = disabled, $2[58] = handleClick, $2[59] = onItemMouseEnter, $2[60] = onItemMouseLeave, $2[61] = restProps, $2[62] = scheme, $2[63] = t15, $2[64] = t16, $2[65] = t17, $2[66] = t18, $2[67] = t19, $2[68] = t20, $2[69] = t21, $2[70] = t22, $2[71] = t23, $2[72] = t24) : t24 = $2[72], t24;
});
MenuItem.displayName = "ForwardRef(MenuItem)";
function _temp(s2) {
  return s2 - 1;
}
var CustomButton = dt(Button).withConfig({
  displayName: "CustomButton",
  componentId: "sc-1kns779-0"
})`max-width:100%;`;
var Tab = (0, import_react52.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime.c)(30);
  let focused, icon, id3, label, onClick, onFocus, restProps, selected, t0, t1;
  $2[0] !== props ? ({
    icon,
    id: id3,
    focused,
    fontSize: t0,
    label,
    onClick,
    onFocus,
    padding: t1,
    selected,
    ...restProps
  } = props, $2[0] = props, $2[1] = focused, $2[2] = icon, $2[3] = id3, $2[4] = label, $2[5] = onClick, $2[6] = onFocus, $2[7] = restProps, $2[8] = selected, $2[9] = t0, $2[10] = t1) : (focused = $2[1], icon = $2[2], id3 = $2[3], label = $2[4], onClick = $2[5], onFocus = $2[6], restProps = $2[7], selected = $2[8], t0 = $2[9], t1 = $2[10]);
  const fontSize2 = t0 === void 0 ? 1 : t0, padding = t1 === void 0 ? 2 : t1, ref = (0, import_react52.useRef)(null), focusedRef = (0, import_react52.useRef)(false);
  let t2;
  $2[11] === Symbol.for("react.memo_cache_sentinel") ? (t2 = () => ref.current, $2[11] = t2) : t2 = $2[11], (0, import_react52.useImperativeHandle)(forwardedRef, t2);
  let t3;
  $2[12] === Symbol.for("react.memo_cache_sentinel") ? (t3 = () => {
    focusedRef.current = false;
  }, $2[12] = t3) : t3 = $2[12];
  const handleBlur = t3;
  let t4;
  $2[13] !== onFocus ? (t4 = (event) => {
    focusedRef.current = true, onFocus && onFocus(event);
  }, $2[13] = onFocus, $2[14] = t4) : t4 = $2[14];
  const handleFocus = t4;
  let t5, t6;
  $2[15] !== focused ? (t5 = () => {
    focused && !focusedRef.current && (ref.current && ref.current.focus(), focusedRef.current = true);
  }, t6 = [focused], $2[15] = focused, $2[16] = t5, $2[17] = t6) : (t5 = $2[16], t6 = $2[17]), (0, import_react52.useEffect)(t5, t6);
  const t7 = selected ? "true" : "false", t8 = selected ? 0 : -1;
  let t9;
  return $2[18] !== fontSize2 || $2[19] !== handleFocus || $2[20] !== icon || $2[21] !== id3 || $2[22] !== label || $2[23] !== onClick || $2[24] !== padding || $2[25] !== restProps || $2[26] !== selected || $2[27] !== t7 || $2[28] !== t8 ? (t9 = (0, import_jsx_runtime12.jsx)(CustomButton, { "data-ui": "Tab", ...restProps, "aria-selected": t7, fontSize: fontSize2, icon, id: id3, mode: "bleed", onClick, onBlur: handleBlur, onFocus: handleFocus, padding, ref, role: "tab", selected, tabIndex: t8, text: label, type: "button" }), $2[18] = fontSize2, $2[19] = handleFocus, $2[20] = icon, $2[21] = id3, $2[22] = label, $2[23] = onClick, $2[24] = padding, $2[25] = restProps, $2[26] = selected, $2[27] = t7, $2[28] = t8, $2[29] = t9) : t9 = $2[29], t9;
});
Tab.displayName = "ForwardRef(Tab)";
var CustomInline = dt(Inline).withConfig({
  displayName: "CustomInline",
  componentId: "sc-5cm04m-0"
})`& > div{display:inline-block;vertical-align:middle;max-width:100%;box-sizing:border-box;}`;
var TabList = (0, import_react52.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime.c)(15);
  let childrenProp, restProps;
  $2[0] !== props ? ({
    children: childrenProp,
    ...restProps
  } = props, $2[0] = props, $2[1] = childrenProp, $2[2] = restProps) : (childrenProp = $2[1], restProps = $2[2]);
  const [focusedIndex, setFocusedIndex] = (0, import_react52.useState)(-1);
  let t0;
  if ($2[3] !== childrenProp || $2[4] !== focusedIndex) {
    const children = import_react52.Children.toArray(childrenProp).filter(import_react52.isValidElement);
    let t12;
    $2[6] !== focusedIndex ? (t12 = (child, childIndex) => (0, import_react52.cloneElement)(child, {
      focused: focusedIndex === childIndex,
      key: childIndex,
      onFocus: () => setFocusedIndex(childIndex)
    }), $2[6] = focusedIndex, $2[7] = t12) : t12 = $2[7], t0 = children.map(t12), $2[3] = childrenProp, $2[4] = focusedIndex, $2[5] = t0;
  } else
    t0 = $2[5];
  const tabs = t0, numTabs = tabs.length;
  let t1;
  $2[8] !== numTabs ? (t1 = (event) => {
    event.key === "ArrowLeft" && setFocusedIndex((prevIndex) => (prevIndex + numTabs - 1) % numTabs), event.key === "ArrowRight" && setFocusedIndex((prevIndex_0) => (prevIndex_0 + 1) % numTabs);
  }, $2[8] = numTabs, $2[9] = t1) : t1 = $2[9];
  const handleKeyDown = t1;
  let t2;
  return $2[10] !== handleKeyDown || $2[11] !== ref || $2[12] !== restProps || $2[13] !== tabs ? (t2 = (0, import_jsx_runtime12.jsx)(CustomInline, { "data-ui": "TabList", ...restProps, onKeyDown: handleKeyDown, ref, role: "tablist", children: tabs }), $2[10] = handleKeyDown, $2[11] = ref, $2[12] = restProps, $2[13] = tabs, $2[14] = t2) : t2 = $2[14], t2;
});
TabList.displayName = "ForwardRef(TabList)";

// ../node_modules/@sanity/ui/dist/index.mjs
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var import_react_compiler_runtime2 = __toESM(require_dist(), 1);
function _raf(fn) {
  const frameId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _hasFocus(element) {
  return !!document.activeElement && element.contains(document.activeElement);
}
function isFocusable(element) {
  return element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null ? true : isHTMLAnchorElement(element) ? !!element.href && element.rel !== "ignore" : isHTMLInputElement(element) ? element.type !== "hidden" && element.type !== "file" && !element.disabled : isHTMLButtonElement(element) || isHTMLSelectElement(element) || isHTMLTextAreaElement(element) ? !element.disabled : false;
}
function attemptFocus(element) {
  if (!isFocusable(element))
    return false;
  try {
    element.focus();
  } catch {
  }
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i2 = 0; i2 < element.childNodes.length; i2++) {
    const child = element.childNodes[i2];
    if (isHTMLElement3(child) && (attemptFocus(child) || focusFirstDescendant(child)))
      return true;
  }
  return false;
}
function focusLastDescendant(element) {
  for (let i2 = element.childNodes.length - 1; i2 >= 0; i2--) {
    const child = element.childNodes[i2];
    if (isHTMLElement3(child) && (attemptFocus(child) || focusLastDescendant(child)))
      return true;
  }
  return false;
}
function useElementRect(element) {
  var _a;
  return ((_a = useElementSize(element)) == null ? void 0 : _a._contentRect) || null;
}
var ErrorBoundary = class extends import_react53.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "state", {
      error: null
    });
  }
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, info) {
    this.props.onCatch({
      error,
      info
    });
  }
  render() {
    const {
      error
    } = this.state;
    if (error) {
      const message = typeof (error == null ? void 0 : error.message) == "string" ? error.message : "Error";
      return (0, import_jsx_runtime13.jsx)(Code, { children: message });
    }
    return this.props.children;
  }
};
var StyledAutocomplete = dt.div.withConfig({
  displayName: "StyledAutocomplete",
  componentId: "sc-1igauft-0"
})`line-height:0;`;
var ListBox = dt(Box).withConfig({
  displayName: "ListBox",
  componentId: "sc-1igauft-1"
})`& > ul{list-style:none;padding:0;margin:0;}`;
var rotate3 = mt`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`;
var AnimatedSpinnerIcon = dt(SpinnerIcon).withConfig({
  displayName: "AnimatedSpinnerIcon",
  componentId: "sc-1igauft-2"
})`animation:${rotate3} 500ms linear infinite;`;
function AutocompleteOption(props) {
  const $2 = (0, import_react_compiler_runtime2.c)(11), {
    children,
    id: id3,
    onSelect,
    selected,
    value
  } = props;
  let t0;
  $2[0] !== onSelect || $2[1] !== value ? (t0 = () => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, $2[0] = onSelect, $2[1] = value, $2[2] = t0) : t0 = $2[2];
  const handleClick = t0;
  let t1;
  $2[3] !== handleClick ? (t1 = (event) => {
    event.key === "Enter" && !_isEnterToClickElement(event.currentTarget) && handleClick();
  }, $2[3] = handleClick, $2[4] = t1) : t1 = $2[4];
  const handleKeyDown = t1;
  let t2;
  return $2[5] !== children || $2[6] !== handleClick || $2[7] !== handleKeyDown || $2[8] !== id3 || $2[9] !== selected ? (t2 = (0, import_jsx_runtime13.jsx)("li", { "aria-selected": selected, "data-ui": "AutocompleteOption", id: id3, role: "option", onClick: handleClick, onKeyDown: handleKeyDown, children }), $2[5] = children, $2[6] = handleClick, $2[7] = handleKeyDown, $2[8] = id3, $2[9] = selected, $2[10] = t2) : t2 = $2[10], t2;
}
function autocompleteReducer(state, msg2) {
  return msg2.type === "input/change" ? {
    ...state,
    activeValue: null,
    focused: true,
    query: msg2.query
  } : msg2.type === "input/focus" ? {
    ...state,
    focused: true
  } : msg2.type === "root/blur" ? {
    ...state,
    focused: false,
    query: null
  } : msg2.type === "root/clear" ? {
    ...state,
    activeValue: null,
    query: null,
    value: null
  } : msg2.type === "root/escape" ? {
    ...state,
    focused: false,
    query: null
  } : msg2.type === "root/open" ? {
    ...state,
    query: state.query || msg2.query
  } : msg2.type === "root/setActiveValue" ? {
    ...state,
    activeValue: msg2.value,
    listFocused: msg2.listFocused || state.listFocused
  } : msg2.type === "root/setListFocused" ? {
    ...state,
    listFocused: msg2.listFocused
  } : msg2.type === "value/change" ? {
    ...state,
    activeValue: msg2.value,
    query: null,
    value: msg2.value
  } : state;
}
var AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = ["Control", "Shift", "Alt", "Enter", "Home", "End", "PageUp", "PageDown", "Meta", "Tab", "CapsLock"];
var AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start";
var AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"];
var DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value;
var DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1;
var InnerAutocomplete = (0, import_react53.forwardRef)(function(props, forwardedRef) {
  const {
    border: border2 = true,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize: fontSize2 = 2,
    icon,
    id: id3,
    listBox = EMPTY_RECORD,
    loading,
    onBlur,
    onChange,
    onFocus,
    onQueryChange,
    onSelect,
    openButton,
    openOnFocus,
    options: optionsProp,
    padding: paddingProp = 3,
    popover = EMPTY_RECORD,
    prefix: prefix2,
    radius = 2,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue = DEFAULT_RENDER_VALUE,
    suffix,
    value: valueProp,
    ...restProps
  } = props, [state, dispatch] = (0, import_react53.useReducer)(autocompleteReducer, {
    activeValue: valueProp || null,
    focused: false,
    listFocused: false,
    query: null,
    value: valueProp || null
  }), {
    activeValue,
    focused,
    listFocused,
    query,
    value
  } = state, defaultRenderOption = (0, import_react53.useCallback)(({
    value: value_0
  }) => (0, import_jsx_runtime13.jsx)(Card, { "data-as": "button", padding: paddingProp, radius: 2, tone: "inherit", children: (0, import_jsx_runtime13.jsx)(Text, { size: fontSize2, textOverflow: "ellipsis", children: value_0 }) }), [fontSize2, paddingProp]), renderOption = typeof renderOptionProp == "function" ? renderOptionProp : defaultRenderOption, filterOption = typeof filterOptionProp == "function" ? filterOptionProp : DEFAULT_FILTER_OPTION, rootElementRef = (0, import_react53.useRef)(null), resultsPopoverElementRef = (0, import_react53.useRef)(null), inputElementRef = (0, import_react53.useRef)(null), listBoxElementRef = (0, import_react53.useRef)(null), listFocusedRef = (0, import_react53.useRef)(false), valueRef = (0, import_react53.useRef)(value), valuePropRef = (0, import_react53.useRef)(valueProp), popoverMouseWithinRef = (0, import_react53.useRef)(false);
  (0, import_react53.useImperativeHandle)(forwardedRef, () => inputElementRef.current);
  const listBoxId = `${id3}-listbox`, options = Array.isArray(optionsProp) ? optionsProp : EMPTY_ARRAY, padding = useArrayProp(paddingProp), currentOption = (0, import_react53.useMemo)(() => value !== null ? options.find((o2) => o2.value === value) : void 0, [options, value]), filteredOptions = (0, import_react53.useMemo)(() => options.filter((option) => query ? filterOption(query, option) : true), [filterOption, options, query]), filteredOptionsLen = filteredOptions.length, activeItemId = activeValue ? `${id3}-option-${activeValue}` : void 0, expanded = query !== null && loading || focused && query !== null, handleRootBlur = (0, import_react53.useCallback)((event) => {
    setTimeout(() => {
      if (popoverMouseWithinRef.current)
        return;
      const elements = (relatedElements || []).concat(rootElementRef.current ? [rootElementRef.current] : [], resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []);
      let focusInside = false;
      if (document.activeElement) {
        for (const e of elements)
          if (e === document.activeElement || e.contains(document.activeElement)) {
            focusInside = true;
            break;
          }
      }
      focusInside === false && (dispatch({
        type: "root/blur"
      }), popoverMouseWithinRef.current = false, onQueryChange && onQueryChange(null), onBlur && onBlur(event));
    }, 0);
  }, [onBlur, onQueryChange, relatedElements]), handleRootFocus = (0, import_react53.useCallback)((event_0) => {
    const listBoxElement = listBoxElementRef.current, focusedElement = event_0.target instanceof HTMLElement ? event_0.target : null, listFocused_0 = (listBoxElement == null ? void 0 : listBoxElement.contains(focusedElement)) || false;
    listFocused_0 !== listFocusedRef.current && (listFocusedRef.current = listFocused_0, dispatch({
      type: "root/setListFocused",
      listFocused: listFocused_0
    }));
  }, []), handleOptionSelect = (0, import_react53.useCallback)((v2) => {
    var _a;
    dispatch({
      type: "value/change",
      value: v2
    }), popoverMouseWithinRef.current = false, onSelect && onSelect(v2), valueRef.current = v2, onChange && onChange(v2), onQueryChange && onQueryChange(null), (_a = inputElementRef.current) == null ? void 0 : _a.focus();
  }, [onChange, onSelect, onQueryChange]), handleRootKeyDown = (0, import_react53.useCallback)((event_1) => {
    var _a, _b;
    if (event_1.key === "ArrowDown") {
      if (event_1.preventDefault(), !filteredOptionsLen) return;
      const activeOption = filteredOptions.find((o_0) => o_0.value === activeValue), activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1, nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
      nextActiveOption && dispatch({
        type: "root/setActiveValue",
        value: nextActiveOption.value,
        listFocused: true
      });
      return;
    }
    if (event_1.key === "ArrowUp") {
      if (event_1.preventDefault(), !filteredOptionsLen) return;
      const activeOption_0 = filteredOptions.find((o_1) => o_1.value === activeValue), activeIndex_0 = activeOption_0 ? filteredOptions.indexOf(activeOption_0) : -1, nextActiveOption_0 = filteredOptions[activeIndex_0 === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex_0 - 1) % filteredOptionsLen];
      nextActiveOption_0 && dispatch({
        type: "root/setActiveValue",
        value: nextActiveOption_0.value,
        listFocused: true
      });
      return;
    }
    if (event_1.key === "Escape") {
      dispatch({
        type: "root/escape"
      }), popoverMouseWithinRef.current = false, onQueryChange && onQueryChange(null), (_a = inputElementRef.current) == null ? void 0 : _a.focus();
      return;
    }
    const target = event_1.target, listEl = listBoxElementRef.current;
    if ((listEl === target || (listEl == null ? void 0 : listEl.contains(target))) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event_1.key)) {
      (_b = inputElementRef.current) == null ? void 0 : _b.focus();
      return;
    }
  }, [activeValue, filteredOptions, filteredOptionsLen, onQueryChange]), handleInputChange = (0, import_react53.useCallback)((event_2) => {
    const nextQuery = event_2.currentTarget.value;
    dispatch({
      type: "input/change",
      query: nextQuery
    }), onQueryChange && onQueryChange(nextQuery);
  }, [onQueryChange]), dispatchOpen = (0, import_react53.useCallback)(() => {
    dispatch({
      type: "root/open",
      query: value ? renderValue(value, currentOption) : ""
    });
  }, [currentOption, renderValue, value]), handleInputFocus = (0, import_react53.useCallback)((event_3) => {
    focused || (dispatch({
      type: "input/focus"
    }), onFocus && onFocus(event_3), openOnFocus && dispatchOpen());
  }, [focused, onFocus, openOnFocus, dispatchOpen]), handlePopoverMouseEnter = (0, import_react53.useCallback)(() => {
    popoverMouseWithinRef.current = true;
  }, []), handlePopoverMouseLeave = (0, import_react53.useCallback)(() => {
    popoverMouseWithinRef.current = false;
  }, []), handleClearButtonClick = (0, import_react53.useCallback)(() => {
    var _a;
    dispatch({
      type: "root/clear"
    }), valueRef.current = "", onChange && onChange(""), onQueryChange && onQueryChange(null), (_a = inputElementRef.current) == null ? void 0 : _a.focus();
  }, [onChange, onQueryChange]), handleClearButtonFocus = (0, import_react53.useCallback)(() => {
    dispatch({
      type: "input/focus"
    });
  }, []);
  (0, import_react53.useEffect)(() => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp, valueProp !== void 0 && (dispatch({
        type: "value/change",
        value: valueProp
      }), valueRef.current = valueProp);
      return;
    }
    valueProp !== valueRef.current && (valueRef.current = valueProp || null, dispatch({
      type: "value/change",
      value: valueProp || null
    }));
  }, [valueProp]), (0, import_react53.useEffect)(() => {
    !focused && valueRef.current && dispatch({
      type: "root/setActiveValue",
      value: valueRef.current
    });
  }, [focused]), (0, import_react53.useEffect)(() => {
    const listElement = listBoxElementRef.current;
    if (!listElement) return;
    const activeOption_1 = filteredOptions.find((o_2) => o_2.value === activeValue);
    if (activeOption_1) {
      const activeIndex_1 = filteredOptions.indexOf(activeOption_1), activeItemElement = listElement.childNodes[activeIndex_1];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement))
          return;
        focusFirstDescendant(activeItemElement);
      }
    }
  }, [activeValue, filteredOptions]);
  const clearButton = (0, import_react53.useMemo)(() => {
    if (!loading && !disabled && value)
      return {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      };
  }, [disabled, handleClearButtonFocus, loading, value]), openButtonBoxPadding = (0, import_react53.useMemo)(() => padding.map((v_0) => v_0 === 0 ? 0 : v_0 === 1 || v_0 === 2 ? 1 : v_0 - 2), [padding]), openButtonPadding = (0, import_react53.useMemo)(() => padding.map((v_1) => Math.max(v_1 - 1, 0)), [padding]), openButtonProps = (0, import_react53.useMemo)(() => typeof openButton == "object" ? openButton : EMPTY_RECORD, [openButton]), handleOpenClick = (0, import_react53.useCallback)((event_4) => {
    dispatchOpen(), openButtonProps.onClick && openButtonProps.onClick(event_4), _raf(() => {
      var _a;
      return (_a = inputElementRef.current) == null ? void 0 : _a.focus();
    });
  }, [openButtonProps, dispatchOpen]), openButtonNode = (0, import_react53.useMemo)(() => !disabled && !readOnly && openButton ? (0, import_jsx_runtime13.jsx)(Box, { "aria-hidden": expanded, padding: openButtonBoxPadding, children: (0, import_jsx_runtime13.jsx)(Button, { "aria-label": "Open", disabled: expanded, fontSize: fontSize2, icon: ChevronDownIcon, mode: "bleed", padding: openButtonPadding, ...openButtonProps, onClick: handleOpenClick }) }) : void 0, [disabled, expanded, fontSize2, handleOpenClick, openButton, openButtonBoxPadding, openButtonPadding, openButtonProps, readOnly]), inputValue = (0, import_react53.useMemo)(() => query === null ? value !== null ? renderValue(value, currentOption) : "" : query, [currentOption, query, renderValue, value]), input = (0, import_jsx_runtime13.jsx)(TextInput, { ...restProps, "aria-activedescendant": activeItemId, "aria-autocomplete": "list", "aria-expanded": expanded, "aria-owns": listBoxId, autoCapitalize: "off", autoComplete: "off", autoCorrect: "off", border: border2, clearButton, customValidity, disabled, fontSize: fontSize2, icon, iconRight: loading && AnimatedSpinnerIcon, id: id3, inputMode: "search", onChange: handleInputChange, onClear: handleClearButtonClick, onFocus: handleInputFocus, padding, prefix: prefix2, radius, readOnly, ref: inputElementRef, role: "combobox", spellCheck: false, suffix: suffix || openButtonNode, value: inputValue }), handleListBoxKeyDown = (0, import_react53.useCallback)((event_5) => {
    var _a;
    event_5.key === "Tab" && listFocused && ((_a = inputElementRef.current) == null ? void 0 : _a.focus());
  }, [listFocused]), content2 = (0, import_react53.useMemo)(() => filteredOptions.length === 0 ? null : (0, import_jsx_runtime13.jsx)(ListBox, { "data-ui": "AutoComplete__results", onKeyDown: handleListBoxKeyDown, padding: 1, ...listBox, tabIndex: -1, children: (0, import_jsx_runtime13.jsx)(Stack, { as: "ul", "aria-multiselectable": false, "data-ui": "AutoComplete__resultsList", id: listBoxId, ref: listBoxElementRef, role: "listbox", space: 1, children: filteredOptions.map((option_0) => {
    const active = activeValue !== null ? option_0.value === activeValue : currentOption === option_0;
    return (0, import_jsx_runtime13.jsx)(AutocompleteOption, { id: `${id3}-option-${option_0.value}`, onSelect: handleOptionSelect, selected: active, value: option_0.value, children: (0, import_react53.cloneElement)(renderOption(option_0), {
      disabled: loading,
      selected: active,
      tabIndex: listFocused && active ? 0 : -1
    }) }, option_0.value);
  }) }) }), [activeValue, currentOption, filteredOptions, handleOptionSelect, handleListBoxKeyDown, id3, listBox, listBoxId, listFocused, loading, renderOption]), results = (0, import_react53.useMemo)(() => renderPopover ? renderPopover({
    content: content2,
    hidden: !expanded,
    inputElement: inputElementRef.current,
    onMouseEnter: handlePopoverMouseEnter,
    onMouseLeave: handlePopoverMouseLeave
  }, resultsPopoverElementRef) : filteredOptionsLen === 0 ? null : (0, import_jsx_runtime13.jsx)(Popover, { arrow: false, constrainSize: true, content: content2, fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS, matchReferenceWidth: true, onMouseEnter: handlePopoverMouseEnter, onMouseLeave: handlePopoverMouseLeave, open: expanded, overflow: "auto", placement: AUTOCOMPLETE_POPOVER_PLACEMENT, portal: true, radius, ref: resultsPopoverElementRef, referenceElement: inputElementRef.current, ...popover }), [content2, expanded, filteredOptionsLen, handlePopoverMouseEnter, handlePopoverMouseLeave, popover, radius, renderPopover]);
  return (0, import_jsx_runtime13.jsxs)(StyledAutocomplete, { "data-ui": "Autocomplete", onBlur: handleRootBlur, onFocus: handleRootFocus, onKeyDown: handleRootKeyDown, ref: rootElementRef, children: [
    input,
    results
  ] });
});
InnerAutocomplete.displayName = "ForwardRef(Autocomplete)";
var Autocomplete = InnerAutocomplete;
var StyledBreadcrumbs = dt.ol.withConfig({
  displayName: "StyledBreadcrumbs",
  componentId: "sc-1es8h8q-0"
})`margin:0;padding:0;display:flex;list-style:none;align-items:center;white-space:nowrap;line-height:0;`;
var ExpandButton = dt(Button).withConfig({
  displayName: "ExpandButton",
  componentId: "sc-1es8h8q-1"
})`appearance:none;margin:-4px;`;
var Breadcrumbs = (0, import_react53.forwardRef)(function(props, ref) {
  const {
    children,
    maxLength,
    separator,
    space: spaceRaw = 2,
    ...restProps
  } = props, space = useArrayProp(spaceRaw), [open, setOpen] = (0, import_react53.useState)(false), expandElementRef = (0, import_react53.useRef)(null), popoverElementRef = (0, import_react53.useRef)(null), collapse = (0, import_react53.useCallback)(() => setOpen(false), []), expand = (0, import_react53.useCallback)(() => setOpen(true), []);
  useClickOutsideEvent(collapse, () => [expandElementRef.current, popoverElementRef.current]);
  const rawItems = (0, import_react53.useMemo)(() => import_react53.Children.toArray(children).filter(import_react53.isValidElement), [children]), items = (0, import_react53.useMemo)(() => {
    const len = rawItems.length;
    if (maxLength && len > maxLength) {
      const beforeLength = Math.ceil(maxLength / 2), afterLength = Math.floor(maxLength / 2);
      return [...rawItems.slice(0, beforeLength - 1), (0, import_jsx_runtime13.jsx)(Popover, { constrainSize: true, content: (0, import_jsx_runtime13.jsx)(Stack, { as: "ol", overflow: "auto", padding: space, space, children: rawItems.slice(beforeLength - 1, len - afterLength) }), open, placement: "top", portal: true, ref: popoverElementRef, children: (0, import_jsx_runtime13.jsx)(ExpandButton, { fontSize: 1, mode: "bleed", onClick: open ? collapse : expand, padding: 1, ref: expandElementRef, selected: open, text: "…" }) }, "button"), ...rawItems.slice(len - afterLength)];
    }
    return rawItems;
  }, [collapse, expand, maxLength, open, rawItems, space]);
  return (0, import_jsx_runtime13.jsx)(StyledBreadcrumbs, { "data-ui": "Breadcrumbs", ...restProps, ref, children: items.map((item, itemIndex) => (0, import_jsx_runtime13.jsxs)(import_react53.Fragment, { children: [
    itemIndex > 0 && (0, import_jsx_runtime13.jsx)(Box, { "aria-hidden": true, as: "li", paddingX: space, children: separator || (0, import_jsx_runtime13.jsx)(Text, { muted: true, children: "/" }) }),
    (0, import_jsx_runtime13.jsx)(Box, { as: "li", children: item })
  ] }, itemIndex)) });
});
Breadcrumbs.displayName = "ForwardRef(Breadcrumbs)";
function dialogStyle({
  theme
}) {
  const {
    color: color3
  } = getTheme_v2(theme);
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color3.backdrop
  };
}
function responsiveDialogPositionStyle(props) {
  const {
    media
  } = getTheme_v2(props.theme);
  return _responsive(media, props.$position, (position2) => ({
    "&&": {
      position: position2
    }
  }));
}
function animationDialogStyle(props) {
  return props.$animate ? lt`
    @keyframes zoomIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    animation: fadeIn 200ms ease-out;
    // Animates the dialog card.
    & > [data-ui='DialogCard'] {
      animation: zoomIn 200ms ease-out;
    }
  ` : lt``;
}
var DialogContext = createGlobalScopedContext("@sanity/ui/context/dialog", {
  version: 0
});
function useDialog() {
  return (0, import_react53.useContext)(DialogContext);
}
function isTargetWithinScope(boundaryElement, portalElement, target) {
  return !boundaryElement || !portalElement ? true : containsOrEqualsElement(boundaryElement, target) || containsOrEqualsElement(portalElement, target);
}
var StyledDialog = dt(Layer).withConfig({
  displayName: "StyledDialog",
  componentId: "sc-4n4xb3-0"
})(responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle, animationDialogStyle);
var DialogContainer = dt(Container).withConfig({
  displayName: "DialogContainer",
  componentId: "sc-4n4xb3-1"
})`&:not([hidden]){display:flex;}width:100%;height:100%;flex-direction:column;align-items:center;justify-content:center;`;
var DialogCardRoot = dt(Card).withConfig({
  displayName: "DialogCardRoot",
  componentId: "sc-4n4xb3-2"
})`&:not([hidden]){display:flex;}width:100%;min-height:0;max-height:100%;overflow:hidden;overflow:clip;`;
var DialogLayout = dt(Flex).withConfig({
  displayName: "DialogLayout",
  componentId: "sc-4n4xb3-3"
})`flex:1;min-height:0;width:100%;`;
var DialogHeader = dt(Box).withConfig({
  displayName: "DialogHeader",
  componentId: "sc-4n4xb3-4"
})`position:relative;z-index:2;`;
var DialogContent = dt(Box).withConfig({
  displayName: "DialogContent",
  componentId: "sc-4n4xb3-5"
})`position:relative;z-index:1;overflow:auto;outline:none;`;
var DialogFooter = dt(Box).withConfig({
  displayName: "DialogFooter",
  componentId: "sc-4n4xb3-6"
})`position:relative;z-index:3;`;
var DialogCard = (0, import_react53.forwardRef)(function(props, forwardedRef) {
  var _a;
  const $2 = (0, import_react_compiler_runtime2.c)(38), {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef: forwardedContentRef,
    footer,
    header,
    id: id3,
    onClickOutside,
    onClose,
    portal: portalProp,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props, portal = usePortal(), portalElement = portalProp ? ((_a = portal.elements) == null ? void 0 : _a[portalProp]) || null : portal.element, boundaryElement = useBoundaryElement().element, radius = useArrayProp(radiusProp), shadow = useArrayProp(shadowProp), width = useArrayProp(widthProp), ref = (0, import_react53.useRef)(null), contentRef = (0, import_react53.useRef)(null), layer = useLayer(), {
    isTopLayer: isTopLayer2
  } = layer, labelId = `${id3}_label`, showCloseButton = !!onClose && hideCloseButton === false, showHeader = !!header || showCloseButton;
  let t0;
  $2[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $2[0] = t0) : t0 = $2[0], (0, import_react53.useImperativeHandle)(forwardedRef, t0);
  let t1;
  $2[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => contentRef.current, $2[1] = t1) : t1 = $2[1], (0, import_react53.useImperativeHandle)(forwardedContentRef, t1);
  let t2, t3;
  $2[2] !== autoFocus ? (t2 = () => {
    autoFocus && ref.current && focusFirstDescendant(ref.current);
  }, t3 = [autoFocus, ref], $2[2] = autoFocus, $2[3] = t2, $2[4] = t3) : (t2 = $2[3], t3 = $2[4]), (0, import_react53.useEffect)(t2, t3);
  let t4;
  $2[5] !== boundaryElement || $2[6] !== isTopLayer2 || $2[7] !== onClose || $2[8] !== portalElement ? (t4 = (event) => {
    if (!isTopLayer2 || !onClose)
      return;
    const target = document.activeElement;
    target && !isTargetWithinScope(boundaryElement, portalElement, target) || event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), onClose());
  }, $2[5] = boundaryElement, $2[6] = isTopLayer2, $2[7] = onClose, $2[8] = portalElement, $2[9] = t4) : t4 = $2[9], useGlobalKeyDown(t4);
  let t5;
  $2[10] !== boundaryElement || $2[11] !== isTopLayer2 || $2[12] !== onClickOutside || $2[13] !== portalElement ? (t5 = isTopLayer2 && onClickOutside && ((event_0) => {
    const target_0 = event_0.target;
    target_0 && !isTargetWithinScope(boundaryElement, portalElement, target_0) || onClickOutside();
  }), $2[10] = boundaryElement, $2[11] = isTopLayer2, $2[12] = onClickOutside, $2[13] = portalElement, $2[14] = t5) : t5 = $2[14];
  let t6;
  $2[15] === Symbol.for("react.memo_cache_sentinel") ? (t6 = () => [ref.current], $2[15] = t6) : t6 = $2[15], useClickOutsideEvent(t5, t6);
  let t7;
  $2[16] !== header || $2[17] !== labelId || $2[18] !== onClose || $2[19] !== showCloseButton || $2[20] !== showHeader ? (t7 = showHeader && (0, import_jsx_runtime13.jsx)(DialogHeader, { children: (0, import_jsx_runtime13.jsxs)(Flex, { align: "flex-start", padding: 3, children: [
    (0, import_jsx_runtime13.jsx)(Box, { flex: 1, padding: 2, children: header && (0, import_jsx_runtime13.jsx)(Text, { id: labelId, size: 1, weight: "semibold", children: header }) }),
    showCloseButton && (0, import_jsx_runtime13.jsx)(Box, { flex: "none", children: (0, import_jsx_runtime13.jsx)(Button, { "aria-label": "Close dialog", disabled: !onClose, icon: CloseIcon, mode: "bleed", onClick: onClose, padding: 2 }) })
  ] }) }), $2[16] = header, $2[17] = labelId, $2[18] = onClose, $2[19] = showCloseButton, $2[20] = showHeader, $2[21] = t7) : t7 = $2[21];
  let t8;
  $2[22] !== children ? (t8 = (0, import_jsx_runtime13.jsx)(DialogContent, { flex: 1, ref: contentRef, tabIndex: -1, children }), $2[22] = children, $2[23] = t8) : t8 = $2[23];
  let t9;
  $2[24] !== footer ? (t9 = footer && (0, import_jsx_runtime13.jsx)(DialogFooter, { children: footer }), $2[24] = footer, $2[25] = t9) : t9 = $2[25];
  let t10;
  $2[26] !== t7 || $2[27] !== t8 || $2[28] !== t9 ? (t10 = (0, import_jsx_runtime13.jsxs)(DialogLayout, { direction: "column", children: [
    t7,
    t8,
    t9
  ] }), $2[26] = t7, $2[27] = t8, $2[28] = t9, $2[29] = t10) : t10 = $2[29];
  let t11;
  $2[30] !== radius || $2[31] !== scheme || $2[32] !== shadow || $2[33] !== t10 ? (t11 = (0, import_jsx_runtime13.jsx)(DialogCardRoot, { radius, ref, scheme, shadow, children: t10 }), $2[30] = radius, $2[31] = scheme, $2[32] = shadow, $2[33] = t10, $2[34] = t11) : t11 = $2[34];
  let t12;
  return $2[35] !== t11 || $2[36] !== width ? (t12 = (0, import_jsx_runtime13.jsx)(DialogContainer, { "data-ui": "DialogCard", width, children: t11 }), $2[35] = t11, $2[36] = width, $2[37] = t12) : t12 = $2[37], t12;
});
DialogCard.displayName = "ForwardRef(DialogCard)";
var Dialog = (0, import_react53.forwardRef)(function(props, ref) {
  var _a;
  const $2 = (0, import_react_compiler_runtime2.c)(60), dialog = useDialog(), {
    layer
  } = useTheme_v2();
  let _positionProp, _zOffsetProp, children, contentRef, footer, header, id3, onActivate, onClickOutside, onClose, onFocus, portalProp, restProps, scheme, t0, t1, t2, t3, t4, t5, t6;
  $2[0] !== props ? ({
    __unstable_autoFocus: t0,
    __unstable_hideCloseButton: t1,
    cardRadius: t2,
    cardShadow: t3,
    children,
    contentRef,
    footer,
    header,
    id: id3,
    onActivate,
    onClickOutside,
    onClose,
    onFocus,
    padding: t4,
    portal: portalProp,
    position: _positionProp,
    scheme,
    width: t5,
    zOffset: _zOffsetProp,
    animate: t6,
    ...restProps
  } = props, $2[0] = props, $2[1] = _positionProp, $2[2] = _zOffsetProp, $2[3] = children, $2[4] = contentRef, $2[5] = footer, $2[6] = header, $2[7] = id3, $2[8] = onActivate, $2[9] = onClickOutside, $2[10] = onClose, $2[11] = onFocus, $2[12] = portalProp, $2[13] = restProps, $2[14] = scheme, $2[15] = t0, $2[16] = t1, $2[17] = t2, $2[18] = t3, $2[19] = t4, $2[20] = t5, $2[21] = t6) : (_positionProp = $2[1], _zOffsetProp = $2[2], children = $2[3], contentRef = $2[4], footer = $2[5], header = $2[6], id3 = $2[7], onActivate = $2[8], onClickOutside = $2[9], onClose = $2[10], onFocus = $2[11], portalProp = $2[12], restProps = $2[13], scheme = $2[14], t0 = $2[15], t1 = $2[16], t2 = $2[17], t3 = $2[18], t4 = $2[19], t5 = $2[20], t6 = $2[21]);
  const autoFocus = t0 === void 0 ? true : t0, hideCloseButton = t1 === void 0 ? false : t1, cardRadiusProp = t2 === void 0 ? 4 : t2, cardShadow = t3 === void 0 ? 3 : t3, paddingProp = t4 === void 0 ? 3 : t4, widthProp = t5 === void 0 ? 0 : t5, _animate = t6 === void 0 ? false : t6, positionProp = _positionProp ?? (dialog.position || "fixed"), zOffsetProp = _zOffsetProp ?? (dialog.zOffset || layer.dialog.zOffset), animate2 = usePrefersReducedMotion() ? false : _animate, portal = usePortal(), portalElement = portalProp ? ((_a = portal.elements) == null ? void 0 : _a[portalProp]) || null : portal.element, boundaryElement = useBoundaryElement().element, cardRadius = useArrayProp(cardRadiusProp), padding = useArrayProp(paddingProp), position2 = useArrayProp(positionProp), width = useArrayProp(widthProp), zOffset = useArrayProp(zOffsetProp), preDivRef = (0, import_react53.useRef)(null), postDivRef = (0, import_react53.useRef)(null), cardRef = (0, import_react53.useRef)(null), focusedElementRef = (0, import_react53.useRef)(null);
  let t7;
  $2[22] !== onFocus ? (t7 = (event) => {
    onFocus == null ? void 0 : onFocus(event);
    const target = event.target, cardElement = cardRef.current;
    if (cardElement && target === preDivRef.current) {
      focusLastDescendant(cardElement);
      return;
    }
    if (cardElement && target === postDivRef.current) {
      focusFirstDescendant(cardElement);
      return;
    }
    isHTMLElement3(event.target) && (focusedElementRef.current = event.target);
  }, $2[22] = onFocus, $2[23] = t7) : t7 = $2[23];
  const handleFocus = t7, labelId = `${id3}_label`, rootClickTimeoutRef = (0, import_react53.useRef)(void 0);
  let t8;
  $2[24] !== boundaryElement || $2[25] !== portalElement ? (t8 = () => {
    rootClickTimeoutRef.current && clearTimeout(rootClickTimeoutRef.current), rootClickTimeoutRef.current = setTimeout(() => {
      const activeElement = document.activeElement;
      if (activeElement && !isTargetWithinScope(boundaryElement, portalElement, activeElement)) {
        const target_0 = focusedElementRef.current;
        if (!target_0 || !document.body.contains(target_0)) {
          const cardElement_0 = cardRef.current;
          cardElement_0 && focusFirstDescendant(cardElement_0);
          return;
        }
        target_0.focus();
      }
    }, 0);
  }, $2[24] = boundaryElement, $2[25] = portalElement, $2[26] = t8) : t8 = $2[26];
  const handleRootClick = t8;
  let t9;
  $2[27] === Symbol.for("react.memo_cache_sentinel") ? (t9 = (0, import_jsx_runtime13.jsx)("div", { ref: preDivRef, tabIndex: 0 }), $2[27] = t9) : t9 = $2[27];
  let t10;
  $2[28] !== autoFocus || $2[29] !== cardRadius || $2[30] !== cardShadow || $2[31] !== children || $2[32] !== contentRef || $2[33] !== footer || $2[34] !== header || $2[35] !== hideCloseButton || $2[36] !== id3 || $2[37] !== onClickOutside || $2[38] !== onClose || $2[39] !== portalProp || $2[40] !== scheme || $2[41] !== width ? (t10 = (0, import_jsx_runtime13.jsx)(DialogCard, { __unstable_autoFocus: autoFocus, __unstable_hideCloseButton: hideCloseButton, contentRef, footer, header, id: id3, onClickOutside, onClose, portal: portalProp, radius: cardRadius, ref: cardRef, scheme, shadow: cardShadow, width, children }), $2[28] = autoFocus, $2[29] = cardRadius, $2[30] = cardShadow, $2[31] = children, $2[32] = contentRef, $2[33] = footer, $2[34] = header, $2[35] = hideCloseButton, $2[36] = id3, $2[37] = onClickOutside, $2[38] = onClose, $2[39] = portalProp, $2[40] = scheme, $2[41] = width, $2[42] = t10) : t10 = $2[42];
  let t11;
  $2[43] === Symbol.for("react.memo_cache_sentinel") ? (t11 = (0, import_jsx_runtime13.jsx)("div", { ref: postDivRef, tabIndex: 0 }), $2[43] = t11) : t11 = $2[43];
  let t12;
  $2[44] !== animate2 || $2[45] !== handleFocus || $2[46] !== handleRootClick || $2[47] !== id3 || $2[48] !== labelId || $2[49] !== onActivate || $2[50] !== padding || $2[51] !== position2 || $2[52] !== ref || $2[53] !== restProps || $2[54] !== t10 || $2[55] !== zOffset ? (t12 = (0, import_jsx_runtime13.jsxs)(StyledDialog, { ...restProps, $animate: animate2, $padding: padding, $position: position2, "aria-labelledby": labelId, "aria-modal": true, "data-ui": "Dialog", id: id3, onActivate, onClick: handleRootClick, onFocus: handleFocus, ref, role: "dialog", zOffset, children: [
    t9,
    t10,
    t11
  ] }), $2[44] = animate2, $2[45] = handleFocus, $2[46] = handleRootClick, $2[47] = id3, $2[48] = labelId, $2[49] = onActivate, $2[50] = padding, $2[51] = position2, $2[52] = ref, $2[53] = restProps, $2[54] = t10, $2[55] = zOffset, $2[56] = t12) : t12 = $2[56];
  let t13;
  return $2[57] !== portalProp || $2[58] !== t12 ? (t13 = (0, import_jsx_runtime13.jsx)(Portal, { __unstable_name: portalProp, children: t12 }), $2[57] = portalProp, $2[58] = t12, $2[59] = t13) : t13 = $2[59], t13;
});
Dialog.displayName = "ForwardRef(Dialog)";
function DialogProvider(props) {
  const $2 = (0, import_react_compiler_runtime2.c)(6), {
    children,
    position: position2,
    zOffset
  } = props;
  let t0, t1;
  $2[0] !== position2 || $2[1] !== zOffset ? (t1 = {
    version: 0,
    position: position2,
    zOffset
  }, $2[0] = position2, $2[1] = zOffset, $2[2] = t1) : t1 = $2[2], t0 = t1;
  const contextValue = t0;
  let t2;
  return $2[3] !== children || $2[4] !== contextValue ? (t2 = (0, import_jsx_runtime13.jsx)(DialogContext.Provider, { value: contextValue, children }), $2[3] = children, $2[4] = contextValue, $2[5] = t2) : t2 = $2[5], t2;
}
DialogProvider.displayName = "DialogProvider";
var MenuButton = (0, import_react53.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime2.c)(62), {
    __unstable_disableRestoreFocusOnClose: t0,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id: id3,
    menu: menuProp,
    onClose,
    onOpen,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: t1,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props, disableRestoreFocusOnClose = t0 === void 0 ? false : t0, deprecated_portal = t1 === void 0 ? true : t1, [open, setOpen] = (0, import_react53.useState)(false), [shouldFocus, setShouldFocus] = (0, import_react53.useState)(null), [buttonElement, setButtonElement] = (0, import_react53.useState)(null);
  let t2;
  $2[0] === Symbol.for("react.memo_cache_sentinel") ? (t2 = [], $2[0] = t2) : t2 = $2[0];
  const [menuElements, setChildMenuElements] = (0, import_react53.useState)(t2), openRef = (0, import_react53.useRef)(open);
  let t3, t4;
  $2[1] !== onOpen || $2[2] !== open ? (t3 = () => {
    onOpen && open && !openRef.current && onOpen();
  }, t4 = [onOpen, open], $2[1] = onOpen, $2[2] = open, $2[3] = t3, $2[4] = t4) : (t3 = $2[3], t4 = $2[4]), (0, import_react53.useEffect)(t3, t4);
  let t5, t6;
  $2[5] !== onClose || $2[6] !== open ? (t5 = () => {
    onClose && !open && openRef.current && onClose();
  }, t6 = [onClose, open], $2[5] = onClose, $2[6] = open, $2[7] = t5, $2[8] = t6) : (t5 = $2[7], t6 = $2[8]), (0, import_react53.useEffect)(t5, t6);
  let t7, t8;
  $2[9] !== open ? (t7 = () => {
    openRef.current = open;
  }, t8 = [open], $2[9] = open, $2[10] = t7, $2[11] = t8) : (t7 = $2[10], t8 = $2[11]), (0, import_react53.useEffect)(t7, t8);
  let t9;
  $2[12] === Symbol.for("react.memo_cache_sentinel") ? (t9 = () => {
    setOpen(_temp$22), setShouldFocus(null);
  }, $2[12] = t9) : t9 = $2[12];
  const handleButtonClick = t9;
  let t10;
  $2[13] !== open ? (t10 = (event) => {
    open && event.preventDefault();
  }, $2[13] = open, $2[14] = t10) : t10 = $2[14];
  const handleMouseDown = t10;
  let t11;
  $2[15] === Symbol.for("react.memo_cache_sentinel") ? (t11 = (event_0) => {
    if (event_0.key === "ArrowDown" || event_0.key === "Enter" || event_0.key === " ") {
      event_0.preventDefault(), setOpen(true), setShouldFocus("first");
      return;
    }
    if (event_0.key === "ArrowUp") {
      event_0.preventDefault(), setOpen(true), setShouldFocus("last");
      return;
    }
  }, $2[15] = t11) : t11 = $2[15];
  const handleButtonKeyDown = t11;
  let t12;
  $2[16] !== buttonElement || $2[17] !== menuElements ? (t12 = (event_1) => {
    const target = event_1.target;
    if (target instanceof Node && !(buttonElement && (target === buttonElement || buttonElement.contains(target)))) {
      for (const el of menuElements)
        if (target === el || el.contains(target))
          return;
      setOpen(false);
    }
  }, $2[16] = buttonElement, $2[17] = menuElements, $2[18] = t12) : t12 = $2[18];
  const handleMenuClickOutside = t12;
  let t13;
  $2[19] !== buttonElement || $2[20] !== disableRestoreFocusOnClose ? (t13 = () => {
    setOpen(false), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, $2[19] = buttonElement, $2[20] = disableRestoreFocusOnClose, $2[21] = t13) : t13 = $2[21];
  const handleMenuEscape = t13;
  let t14;
  $2[22] !== menuElements ? (t14 = (event_2) => {
    const target_0 = event_2.relatedTarget;
    if (target_0 instanceof Node) {
      for (const el_0 of menuElements)
        if (el_0 === target_0 || el_0.contains(target_0))
          return;
      setOpen(false);
    }
  }, $2[22] = menuElements, $2[23] = t14) : t14 = $2[23];
  const handleBlur = t14;
  let t15;
  $2[24] !== buttonElement || $2[25] !== disableRestoreFocusOnClose ? (t15 = () => {
    setOpen(false), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, $2[24] = buttonElement, $2[25] = disableRestoreFocusOnClose, $2[26] = t15) : t15 = $2[26];
  const handleItemClick = t15;
  let t16;
  $2[27] === Symbol.for("react.memo_cache_sentinel") ? (t16 = (el_1) => (setChildMenuElements((els) => els.concat([el_1])), () => setChildMenuElements((els_0) => els_0.filter((_el) => _el !== el_1))), $2[27] = t16) : t16 = $2[27];
  const registerElement = t16;
  let t17;
  $2[28] !== buttonElement || $2[29] !== handleBlur || $2[30] !== handleItemClick || $2[31] !== handleMenuClickOutside || $2[32] !== handleMenuEscape || $2[33] !== id3 || $2[34] !== menuProp || $2[35] !== shouldFocus ? (t17 = menuProp && (0, import_react53.cloneElement)(menuProp, {
    "aria-labelledby": id3,
    onBlurCapture: handleBlur,
    onClickOutside: handleMenuClickOutside,
    onEscape: handleMenuEscape,
    onItemClick: handleItemClick,
    originElement: buttonElement,
    registerElement,
    shouldFocus
  }), $2[28] = buttonElement, $2[29] = handleBlur, $2[30] = handleItemClick, $2[31] = handleMenuClickOutside, $2[32] = handleMenuEscape, $2[33] = id3, $2[34] = menuProp, $2[35] = shouldFocus, $2[36] = t17) : t17 = $2[36];
  const menu = t17;
  let t18, t19;
  $2[37] !== buttonProp || $2[38] !== handleMouseDown || $2[39] !== id3 || $2[40] !== open ? (t19 = buttonProp && (0, import_react53.cloneElement)(buttonProp, {
    "data-ui": "MenuButton",
    id: id3,
    onClick: handleButtonClick,
    onKeyDown: handleButtonKeyDown,
    onMouseDown: handleMouseDown,
    "aria-haspopup": true,
    "aria-expanded": open,
    ref: setButtonElement,
    selected: buttonProp.props.selected ?? open
  }), $2[37] = buttonProp, $2[38] = handleMouseDown, $2[39] = id3, $2[40] = open, $2[41] = t19) : t19 = $2[41], t18 = t19;
  const button = t18;
  let t20, t21;
  $2[42] !== buttonElement ? (t20 = () => buttonElement, t21 = [buttonElement], $2[42] = buttonElement, $2[43] = t20, $2[44] = t21) : (t20 = $2[43], t21 = $2[44]), (0, import_react53.useImperativeHandle)(forwardedRef, t20, t21);
  let t22, t23;
  $2[45] !== popover ? (t23 = popover || {}, $2[45] = popover, $2[46] = t23) : t23 = $2[46];
  let t24;
  $2[47] !== deprecated_boundaryElement || $2[48] !== deprecated_placement || $2[49] !== deprecated_popoverRadius || $2[50] !== deprecated_popoverScheme || $2[51] !== deprecated_portal || $2[52] !== deprecated_preventOverflow || $2[53] !== t23 ? (t24 = {
    boundaryElement: deprecated_boundaryElement,
    overflow: "auto",
    placement: deprecated_placement,
    portal: deprecated_portal,
    preventOverflow: deprecated_preventOverflow,
    radius: deprecated_popoverRadius,
    scheme: deprecated_popoverScheme,
    ...t23
  }, $2[47] = deprecated_boundaryElement, $2[48] = deprecated_placement, $2[49] = deprecated_popoverRadius, $2[50] = deprecated_popoverScheme, $2[51] = deprecated_portal, $2[52] = deprecated_preventOverflow, $2[53] = t23, $2[54] = t24) : t24 = $2[54], t22 = t24;
  const popoverProps = t22;
  let t25;
  $2[55] !== button ? (t25 = button || (0, import_jsx_runtime13.jsx)(import_jsx_runtime13.Fragment, {}), $2[55] = button, $2[56] = t25) : t25 = $2[56];
  let t26;
  return $2[57] !== menu || $2[58] !== open || $2[59] !== popoverProps || $2[60] !== t25 ? (t26 = (0, import_jsx_runtime13.jsx)(Popover, { "data-ui": "MenuButton__popover", ...popoverProps, content: menu, open, children: t25 }), $2[57] = menu, $2[58] = open, $2[59] = popoverProps, $2[60] = t25, $2[61] = t26) : t26 = $2[61], t26;
});
MenuButton.displayName = "ForwardRef(MenuButton)";
function _temp$22(v2) {
  return !v2;
}
var keyframe = mt`
  0% {
    background-position: 100%;
  }
  100% {
    background-position: -100%;
  }
`;
var animation = lt`
  background-image: linear-gradient(
    to right,
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-to),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from)
  );
  background-position: 100%;
  background-size: 200% 100%;
  background-attachment: fixed;
  animation-name: ${keyframe};
  animation-timing-function: ease-in-out;
  animation-iteration-count: infinite;
  animation-duration: 2000ms;
`;
var skeletonStyle = lt`
  opacity: ${({
  $visible
}) => $visible ? 1 : 0};
  transition: opacity 200ms ease-in;

  @media screen and (prefers-reduced-motion: no-preference) {
    ${({
  $animated
}) => $animated ? animation : lt`
            background-color: var(--card-skeleton-color-from);
          `}
  }

  @media screen and (prefers-reduced-motion: reduce) {
    background-color: var(--card-skeleton-color-from);
  }
`;
var StyledSkeleton$1 = dt(Box).withConfig({
  displayName: "StyledSkeleton",
  componentId: "sc-ebtpni-0"
})(responsiveRadiusStyle, skeletonStyle);
var Skeleton = (0, import_react53.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime2.c)(14);
  let delay2, radius, restProps, t0;
  $2[0] !== props ? ({
    animated: t0,
    delay: delay2,
    radius,
    ...restProps
  } = props, $2[0] = props, $2[1] = delay2, $2[2] = radius, $2[3] = restProps, $2[4] = t0) : (delay2 = $2[1], radius = $2[2], restProps = $2[3], t0 = $2[4]);
  const animated = t0 === void 0 ? false : t0, [visible, setVisible] = (0, import_react53.useState)(!delay2);
  let t1, t2;
  $2[5] !== delay2 ? (t1 = () => {
    if (!delay2)
      return setVisible(true);
    const timeout = setTimeout(() => {
      setVisible(true);
    }, delay2);
    return () => {
      clearTimeout(timeout);
    };
  }, t2 = [delay2], $2[5] = delay2, $2[6] = t1, $2[7] = t2) : (t1 = $2[6], t2 = $2[7]), (0, import_react53.useEffect)(t1, t2);
  const t3 = useArrayProp(radius);
  let t4;
  return $2[8] !== animated || $2[9] !== ref || $2[10] !== restProps || $2[11] !== t3 || $2[12] !== visible ? (t4 = (0, import_jsx_runtime13.jsx)(StyledSkeleton$1, { ...restProps, $animated: animated, $radius: t3, $visible: visible, ref }), $2[8] = animated, $2[9] = ref, $2[10] = restProps, $2[11] = t3, $2[12] = visible, $2[13] = t4) : t4 = $2[13], t4;
});
Skeleton.displayName = "ForwardRef(Skeleton)";
var StyledSkeleton = dt(Skeleton).withConfig({
  displayName: "StyledSkeleton",
  componentId: "sc-2p7a1v-0"
})((props) => {
  const {
    $size,
    $style
  } = props, {
    font,
    media
  } = getTheme_v2(props.theme), fontStyle = font[$style];
  return _responsive(media, $size, (sizeIndex) => {
    const fontSize2 = fontStyle.sizes[sizeIndex];
    return {
      height: fontSize2.lineHeight - fontSize2.ascenderHeight - fontSize2.descenderHeight
    };
  });
});
var TextSkeleton = (0, import_react53.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime2.c)(7);
  let restProps, t0;
  $2[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $2[0] = props, $2[1] = restProps, $2[2] = t0) : (restProps = $2[1], t0 = $2[2]);
  const $size = useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $2[3] !== $size || $2[4] !== ref || $2[5] !== restProps ? (t1 = (0, import_jsx_runtime13.jsx)(StyledSkeleton, { ...restProps, $size, ref, $style: "text" }), $2[3] = $size, $2[4] = ref, $2[5] = restProps, $2[6] = t1) : t1 = $2[6], t1;
});
TextSkeleton.displayName = "ForwardRef(TextSkeleton)";
var LabelSkeleton = (0, import_react53.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime2.c)(7);
  let restProps, t0;
  $2[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $2[0] = props, $2[1] = restProps, $2[2] = t0) : (restProps = $2[1], t0 = $2[2]);
  const $size = useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $2[3] !== $size || $2[4] !== ref || $2[5] !== restProps ? (t1 = (0, import_jsx_runtime13.jsx)(StyledSkeleton, { ...restProps, $size, ref, $style: "label" }), $2[3] = $size, $2[4] = ref, $2[5] = restProps, $2[6] = t1) : t1 = $2[6], t1;
});
LabelSkeleton.displayName = "ForwardRef(LabelSkeleton)";
var HeadingSkeleton = (0, import_react53.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime2.c)(7);
  let restProps, t0;
  $2[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $2[0] = props, $2[1] = restProps, $2[2] = t0) : (restProps = $2[1], t0 = $2[2]);
  const $size = useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $2[3] !== $size || $2[4] !== ref || $2[5] !== restProps ? (t1 = (0, import_jsx_runtime13.jsx)(StyledSkeleton, { ...restProps, $size, ref, $style: "heading" }), $2[3] = $size, $2[4] = ref, $2[5] = restProps, $2[6] = t1) : t1 = $2[6], t1;
});
HeadingSkeleton.displayName = "ForwardRef(HeadingSkeleton)";
var CodeSkeleton = (0, import_react53.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime2.c)(7);
  let restProps, t0;
  $2[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $2[0] = props, $2[1] = restProps, $2[2] = t0) : (restProps = $2[1], t0 = $2[2]);
  const $size = useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $2[3] !== $size || $2[4] !== ref || $2[5] !== restProps ? (t1 = (0, import_jsx_runtime13.jsx)(StyledSkeleton, { ...restProps, $size, ref, $style: "code" }), $2[3] = $size, $2[4] = ref, $2[5] = restProps, $2[6] = t1) : t1 = $2[6], t1;
});
CodeSkeleton.displayName = "ForwardRef(CodeSkeleton)";
var TabPanel = (0, import_react53.forwardRef)(function(props, ref) {
  const $2 = (0, import_react_compiler_runtime2.c)(9);
  let flex, restProps;
  $2[0] !== props ? ({
    flex,
    ...restProps
  } = props, $2[0] = props, $2[1] = flex, $2[2] = restProps) : (flex = $2[1], restProps = $2[2]);
  const t0 = props.tabIndex === void 0 ? 0 : props.tabIndex;
  let t1;
  return $2[3] !== flex || $2[4] !== props.children || $2[5] !== ref || $2[6] !== restProps || $2[7] !== t0 ? (t1 = (0, import_jsx_runtime13.jsx)(Box, { "data-ui": "TabPanel", ...restProps, flex, ref, role: "tabpanel", tabIndex: t0, children: props.children }), $2[3] = flex, $2[4] = props.children, $2[5] = ref, $2[6] = restProps, $2[7] = t0, $2[8] = t1) : t1 = $2[8], t1;
});
TabPanel.displayName = "ForwardRef(TabPanel)";
var LOADING_BAR_HEIGHT = 2;
var STATUS_CARD_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "neutral"
};
var BUTTON_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "neutral"
};
var TextBox = dt(Flex).withConfig({
  displayName: "TextBox",
  componentId: "sc-1rr7rxo-0"
})`overflow-x:auto;`;
var StyledToast = dt(Card).withConfig({
  displayName: "StyledToast",
  componentId: "sc-1rr7rxo-1"
})`pointer-events:all;width:100%;position:relative;overflow:hidden;overflow:clip;&[data-has-duration]{padding-bottom:calc(${LOADING_BAR_HEIGHT}px / 2);}`;
var LoadingBar = dt.div.withConfig({
  displayName: "LoadingBar",
  componentId: "sc-1rr7rxo-2"
})`display:flex;position:absolute;bottom:0px;top:0px;left:0px;right:0px;pointer-events:none;z-index:-1;overflow:hidden;overflow:clip;background:transparent;align-items:flex-end;will-change:opacity;`;
var LoadingBarMask = dt(Card).withConfig({
  displayName: "LoadingBarMask",
  componentId: "sc-1rr7rxo-3"
})`position:absolute;top:0;left:-${LOADING_BAR_HEIGHT}px;right:-${LOADING_BAR_HEIGHT}px;bottom:${LOADING_BAR_HEIGHT}px;z-index:1;`;
var LoadingBarProgress = dt(Card).withConfig({
  displayName: "LoadingBarProgress",
  componentId: "sc-1rr7rxo-4"
})`display:block;height:100%;width:100%;transform-origin:0% 50%;background-color:${(props) => {
  const {
    color: color3
  } = getTheme_v2(props.theme);
  return color3.button.default[props.tone].enabled.bg;
}};`;
var ROLES = {
  error: "alert",
  warning: "alert",
  success: "alert",
  info: "alert"
};
var LONG_ENOUGH_BUT_NOT_TOO_LONG = 1e3 * 60 * 60 * 24 * 24;
function Toast(props) {
  const $2 = (0, import_react_compiler_runtime2.c)(50);
  let closable, description, duration, onClose, restProps, status, t0, title, updatedAt;
  $2[0] !== props ? ({
    closable,
    description,
    duration,
    onClose,
    radius: t0,
    title,
    status,
    updatedAt,
    ...restProps
  } = props, $2[0] = props, $2[1] = closable, $2[2] = description, $2[3] = duration, $2[4] = onClose, $2[5] = restProps, $2[6] = status, $2[7] = t0, $2[8] = title, $2[9] = updatedAt) : (closable = $2[1], description = $2[2], duration = $2[3], onClose = $2[4], restProps = $2[5], status = $2[6], t0 = $2[7], title = $2[8], updatedAt = $2[9]);
  const radius = t0 === void 0 ? 3 : t0, cardTone = status ? STATUS_CARD_TONE[status] : "default", buttonTone = status ? BUTTON_TONE[status] : "default", role = status ? ROLES[status] : "status", visualDuration = usePrefersReducedMotion() ? 0 : 0.26;
  let t1;
  $2[10] !== visualDuration ? (t1 = visualDuration ? {
    type: "spring",
    visualDuration,
    bounce: 0.25
  } : {
    duration: 0
  }, $2[10] = visualDuration, $2[11] = t1) : t1 = $2[11];
  const transition = t1, hasDuration = duration && isFinite(duration) && duration < LONG_ENOUGH_BUT_NOT_TOO_LONG;
  let t2;
  $2[12] === Symbol.for("react.memo_cache_sentinel") ? (t2 = ["hidden", "initial"], $2[12] = t2) : t2 = $2[12];
  const initial = t2;
  let t3;
  $2[13] === Symbol.for("react.memo_cache_sentinel") ? (t3 = ["visible", "slideIn"], $2[13] = t3) : t3 = $2[13];
  const animate2 = t3;
  let t4;
  $2[14] === Symbol.for("react.memo_cache_sentinel") ? (t4 = ["hidden", "slideOut"], $2[14] = t4) : t4 = $2[14];
  const exit = t4, t5 = hasDuration ? "" : void 0;
  let t6;
  $2[15] !== title ? (t6 = title && (0, import_jsx_runtime13.jsx)(Text, { size: 1, weight: "medium", children: title }), $2[15] = title, $2[16] = t6) : t6 = $2[16];
  let t7;
  $2[17] !== description || $2[18] !== transition ? (t7 = description && (0, import_jsx_runtime13.jsx)(MotionText, { muted: true, size: 1, variants: content, transition, children: description }), $2[17] = description, $2[18] = transition, $2[19] = t7) : t7 = $2[19];
  let t8;
  $2[20] !== t6 || $2[21] !== t7 ? (t8 = (0, import_jsx_runtime13.jsx)(TextBox, { flex: 1, padding: 3, children: (0, import_jsx_runtime13.jsxs)(Stack, { space: 3, children: [
    t6,
    t7
  ] }) }), $2[20] = t6, $2[21] = t7, $2[22] = t8) : t8 = $2[22];
  let t9;
  $2[23] !== buttonTone || $2[24] !== closable || $2[25] !== onClose ? (t9 = closable && (0, import_jsx_runtime13.jsx)(Box, { padding: 1, children: (0, import_jsx_runtime13.jsx)(Button, { as: "button", icon: CloseIcon, mode: "bleed", padding: 2, tone: buttonTone, onClick: onClose, style: {
    verticalAlign: "top"
  } }) }), $2[23] = buttonTone, $2[24] = closable, $2[25] = onClose, $2[26] = t9) : t9 = $2[26];
  let t10;
  $2[27] !== t8 || $2[28] !== t9 || $2[29] !== transition ? (t10 = (0, import_jsx_runtime13.jsxs)(MotionFlex2, { align: "flex-start", variants: content, transition, children: [
    t8,
    t9
  ] }), $2[27] = t8, $2[28] = t9, $2[29] = transition, $2[30] = t10) : t10 = $2[30];
  let t11;
  $2[31] !== cardTone || $2[32] !== duration || $2[33] !== hasDuration || $2[34] !== onClose || $2[35] !== radius || $2[36] !== transition || $2[37] !== updatedAt || $2[38] !== visualDuration ? (t11 = hasDuration && (0, import_jsx_runtime13.jsxs)(MotionLoadingBar, { variants: content, transition, children: [
    (0, import_jsx_runtime13.jsx)(LoadingBarMask, { tone: cardTone, radius }),
    (0, import_jsx_runtime13.jsx)(MotionLoadingBarProgress, { tone: cardTone, initial: {
      scaleX: 0
    }, animate: {
      scaleX: 1
    }, transition: {
      delay: visualDuration,
      duration: duration / 1e3,
      ease: "linear"
    }, onAnimationComplete: onClose }, `progress-${updatedAt}`)
  ] }), $2[31] = cardTone, $2[32] = duration, $2[33] = hasDuration, $2[34] = onClose, $2[35] = radius, $2[36] = transition, $2[37] = updatedAt, $2[38] = visualDuration, $2[39] = t11) : t11 = $2[39];
  let t12;
  return $2[40] !== cardTone || $2[41] !== radius || $2[42] !== restProps || $2[43] !== role || $2[44] !== t10 || $2[45] !== t11 || $2[46] !== t5 || $2[47] !== transition || $2[48] !== visualDuration ? (t12 = (0, import_jsx_runtime13.jsxs)(MotionToast, { "data-ui": "Toast", role, ...restProps, "data-has-duration": t5, custom: visualDuration, radius, shadow: 2, tone: cardTone, forwardedAs: "li", layout: "position", variants: container, initial, animate: animate2, exit, transition, children: [
    t10,
    t11
  ] }), $2[40] = cardTone, $2[41] = radius, $2[42] = restProps, $2[43] = role, $2[44] = t10, $2[45] = t11, $2[46] = t5, $2[47] = transition, $2[48] = visualDuration, $2[49] = t12) : t12 = $2[49], t12;
}
Toast.displayName = "Toast";
var container = {
  initial: {
    y: 32,
    scale: 0.5,
    zIndex: 1
  },
  hidden: {
    opacity: 0
  },
  visible: (visualDuration) => visualDuration ? {
    opacity: 1,
    transition: {
      when: "beforeChildren",
      staggerChildren: visualDuration / 3,
      duration: visualDuration / 3
    }
  } : {
    opacity: 1
  },
  slideIn: {
    y: 0,
    scale: 1
  },
  slideOut: {
    zIndex: 0,
    scale: 0.75
  }
};
var content = {
  initial: {
    willChange: "transform"
  },
  hidden: {
    opacity: 0
  },
  visible: {
    opacity: 1
  }
};
var MotionToast = motion.create(StyledToast);
var MotionFlex2 = motion.create(Flex);
var MotionText = motion.create(Text);
var MotionLoadingBar = motion.create(LoadingBar);
var MotionLoadingBarProgress = motion.create(LoadingBarProgress);
function useMounted() {
  return (0, import_react53.useSyncExternalStore)(subscribe, _temp$12, _temp22);
}
function _temp22() {
  return false;
}
function _temp$12() {
  return true;
}
var subscribe = () => () => {
};
var ToastContext = createGlobalScopedContext("@sanity/ui/context/toast", null);
function ToastLayer(props) {
  const $2 = (0, import_react_compiler_runtime2.c)(9), {
    children,
    padding: t0,
    paddingX,
    paddingY,
    gap: t1
  } = props, padding = t0 === void 0 ? 4 : t0, gap = t1 === void 0 ? 3 : t1, {
    zIndex
  } = useLayer();
  let t2;
  $2[0] !== zIndex ? (t2 = {
    zIndex
  }, $2[0] = zIndex, $2[1] = t2) : t2 = $2[1];
  let t3;
  return $2[2] !== children || $2[3] !== gap || $2[4] !== padding || $2[5] !== paddingX || $2[6] !== paddingY || $2[7] !== t2 ? (t3 = (0, import_jsx_runtime13.jsx)(StyledLayer2, { forwardedAs: "ul", "data-ui": "ToastProvider", padding, paddingX, paddingY, gap, columns: 1, style: t2, children }), $2[2] = children, $2[3] = gap, $2[4] = padding, $2[5] = paddingX, $2[6] = paddingY, $2[7] = t2, $2[8] = t3) : t3 = $2[8], t3;
}
ToastLayer.displayName = "ToastLayer";
var StyledLayer2 = dt(Grid).withConfig({
  displayName: "StyledLayer",
  componentId: "sc-1tbwn58-0"
})`box-sizing:border-box;position:fixed;right:0;bottom:0;list-style:none;pointer-events:none;max-width:420px;width:100%;`;
var toastId = 0;
function generateToastId() {
  return String(toastId++);
}
function ToastProvider(props) {
  const $2 = (0, import_react_compiler_runtime2.c)(13), {
    children,
    padding,
    paddingX,
    paddingY,
    gap,
    zOffset: t0
  } = props, zOffset = t0 === void 0 ? 1 : t0;
  let t1;
  $2[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = [], $2[0] = t1) : t1 = $2[0];
  const [state, setState] = (0, import_react53.useState)(t1), mounted = useMounted();
  let t2, t3;
  $2[1] === Symbol.for("react.memo_cache_sentinel") ? (t3 = {
    version: 0,
    push: (params) => {
      const id3 = params.id || generateToastId(), duration = params.duration || 5e3;
      return (0, import_react53.startTransition)(() => {
        setState((prevState) => {
          if (duration === 0.01)
            return prevState.filter((toast) => toast.id !== id3);
          const dismiss = () => (0, import_react53.startTransition)(() => setState((currentState) => currentState.filter((toast_0) => toast_0.id !== id3)));
          return [...prevState.filter((toast_1) => toast_1.id !== id3), {
            dismiss,
            id: id3,
            updatedAt: Date.now(),
            params: {
              ...params,
              duration
            }
          }];
        });
      }), id3;
    }
  }, $2[1] = t3) : t3 = $2[1], t2 = t3;
  const value = t2;
  let t4;
  $2[2] !== gap || $2[3] !== mounted || $2[4] !== padding || $2[5] !== paddingX || $2[6] !== paddingY || $2[7] !== state || $2[8] !== zOffset ? (t4 = mounted && (0, import_jsx_runtime13.jsx)(LayerProvider, { zOffset, children: (0, import_jsx_runtime13.jsx)(ToastLayer, { padding, paddingX, paddingY, gap, children: (0, import_jsx_runtime13.jsx)(AnimatePresence, { initial: false, mode: "popLayout", children: state.map(_temp4) }) }) }), $2[2] = gap, $2[3] = mounted, $2[4] = padding, $2[5] = paddingX, $2[6] = paddingY, $2[7] = state, $2[8] = zOffset, $2[9] = t4) : t4 = $2[9];
  let t5;
  return $2[10] !== children || $2[11] !== t4 ? (t5 = (0, import_jsx_runtime13.jsxs)(ToastContext.Provider, { value, children: [
    children,
    t4
  ] }), $2[10] = children, $2[11] = t4, $2[12] = t5) : t5 = $2[12], t5;
}
function _temp4(t0) {
  const {
    dismiss: dismiss_0,
    id: id_0,
    params: params_0,
    updatedAt
  } = t0;
  return (0, import_jsx_runtime13.jsx)(Toast, { closable: params_0.closable, description: params_0.description, onClose: dismiss_0, status: params_0.status, title: params_0.title, duration: params_0.duration, updatedAt }, id_0);
}
ToastProvider.displayName = "ToastProvider";
function useToast() {
  const value = (0, import_react53.useContext)(ToastContext);
  if (!value)
    throw new Error("useToast(): missing context value");
  if (!isRecord2(value) || value.version !== 0)
    throw new Error("useToast(): the context value is not compatible");
  return value;
}
function _findPrevItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(0, idx), len = els.length;
  for (let i2 = len - 1; i2 >= 0; i2 -= 1) {
    const itemKey = els[i2].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p2 = [];
    let expanded = true;
    for (let j2 = 0; j2 < segments.length; j2 += 1) {
      p2.push(segments[j2]);
      const k2 = p2.join("/");
      if (!((_a = state[k2]) == null ? void 0 : _a.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded)
      return els[i2];
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  var _a;
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(idx), len = itemElements.length;
  for (let i2 = 1; i2 < len; i2 += 1) {
    if (!els[i2])
      continue;
    const itemKey = els[i2].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p2 = [];
    let expanded = true;
    for (let j2 = 0; j2 < segments.length; j2 += 1) {
      p2.push(segments[j2]);
      const k2 = p2.join("/");
      if (!((_a = state[k2]) == null ? void 0 : _a.expanded)) {
        expanded = false;
        break;
      }
    }
    if (expanded)
      return els[i2];
  }
  return null;
}
function _focusItemElement(el) {
  if (el.getAttribute("role") === "treeitem" && el.focus(), el.getAttribute("role") === "none") {
    const firstChild = el.firstChild;
    firstChild && firstChild instanceof HTMLElement && firstChild.focus();
  }
}
var TreeContext = createGlobalScopedContext("@sanity/ui/context/tree", null);
var Tree = (0, import_react53.memo)((0, import_react53.forwardRef)(function(props, forwardedRef) {
  const $2 = (0, import_react_compiler_runtime2.c)(37);
  let children, onFocus, restProps, t0;
  $2[0] !== props ? ({
    children,
    space: t0,
    onFocus,
    ...restProps
  } = props, $2[0] = props, $2[1] = children, $2[2] = onFocus, $2[3] = restProps, $2[4] = t0) : (children = $2[1], onFocus = $2[2], restProps = $2[3], t0 = $2[4]);
  const space = t0 === void 0 ? 1 : t0, ref = (0, import_react53.useRef)(null), [focusedElement, setFocusedElement] = (0, import_react53.useState)(null), focusedElementRef = (0, import_react53.useRef)(focusedElement);
  let t1, t2;
  $2[5] === Symbol.for("react.memo_cache_sentinel") ? (t2 = [], $2[5] = t2) : t2 = $2[5], t1 = t2;
  const path = t1;
  let t3;
  $2[6] === Symbol.for("react.memo_cache_sentinel") ? (t3 = [], $2[6] = t3) : t3 = $2[6];
  const [itemElements, setItemElements] = (0, import_react53.useState)(t3);
  let t4;
  $2[7] === Symbol.for("react.memo_cache_sentinel") ? (t4 = {}, $2[7] = t4) : t4 = $2[7];
  const [state, setState] = (0, import_react53.useState)(t4), stateRef = (0, import_react53.useRef)(state);
  let t5;
  $2[8] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => ref.current, $2[8] = t5) : t5 = $2[8], (0, import_react53.useImperativeHandle)(forwardedRef, t5);
  let t6, t7;
  $2[9] !== focusedElement ? (t6 = () => {
    focusedElementRef.current = focusedElement;
  }, t7 = [focusedElement], $2[9] = focusedElement, $2[10] = t6, $2[11] = t7) : (t6 = $2[10], t7 = $2[11]), (0, import_react53.useEffect)(t6, t7);
  let t8, t9;
  $2[12] !== state ? (t8 = () => {
    stateRef.current = state;
  }, t9 = [state], $2[12] = state, $2[13] = t8, $2[14] = t9) : (t8 = $2[13], t9 = $2[14]), (0, import_react53.useEffect)(t8, t9);
  let t10;
  $2[15] === Symbol.for("react.memo_cache_sentinel") ? (t10 = (element, path_0, expanded, selected) => (setState((s2) => ({
    ...s2,
    [path_0]: {
      element,
      expanded
    }
  })), selected && setFocusedElement(element), () => {
    setState((s_0) => {
      const newState = {
        ...s_0
      };
      return delete newState[path_0], newState;
    });
  }), $2[15] = t10) : t10 = $2[15];
  const registerItem = t10;
  let t11;
  $2[16] === Symbol.for("react.memo_cache_sentinel") ? (t11 = (path_1, expanded_0) => {
    setState((s_1) => {
      const itemState = s_1[path_1];
      return itemState ? {
        ...s_1,
        [path_1]: {
          ...itemState,
          expanded: expanded_0
        }
      } : s_1;
    });
  }, $2[16] = t11) : t11 = $2[16];
  const setExpanded = t11;
  let t12;
  const t13 = focusedElement || itemElements[0] || null;
  let t14;
  $2[17] !== space || $2[18] !== state || $2[19] !== t13 ? (t14 = {
    version: 0,
    focusedElement: t13,
    level: 0,
    path,
    registerItem,
    setExpanded,
    setFocusedElement,
    space,
    state
  }, $2[17] = space, $2[18] = state, $2[19] = t13, $2[20] = t14) : t14 = $2[20], t12 = t14;
  const contextValue = t12;
  let t15;
  $2[21] !== itemElements ? (t15 = (event) => {
    var _a;
    if (focusedElementRef.current) {
      if (event.key === "ArrowDown") {
        event.preventDefault();
        const nextEl = _findNextItemElement(stateRef.current, itemElements, focusedElementRef.current);
        nextEl && (_focusItemElement(nextEl), setFocusedElement(nextEl));
        return;
      }
      if (event.key === "ArrowUp") {
        event.preventDefault();
        const prevEl = _findPrevItemElement(stateRef.current, itemElements, focusedElementRef.current);
        prevEl && (_focusItemElement(prevEl), setFocusedElement(prevEl));
        return;
      }
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
        if (!itemKey)
          return;
        const itemState_0 = stateRef.current[itemKey];
        if (!itemState_0)
          return;
        if (itemState_0.expanded)
          setState((s_2) => {
            const itemState_1 = s_2[itemKey];
            return itemState_1 ? {
              ...s_2,
              [itemKey]: {
                ...itemState_1,
                expanded: false
              }
            } : s_2;
          });
        else {
          const itemPath = itemKey.split("/");
          itemPath.pop();
          const parentKey = itemPath.join("/"), parentState = parentKey && stateRef.current[parentKey];
          parentState && (parentState.element.focus(), setFocusedElement(parentState.element));
        }
        return;
      }
      if (event.key === "ArrowRight") {
        event.preventDefault();
        const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
        if (!focusedKey)
          return;
        ((_a = stateRef.current[focusedKey]) == null ? void 0 : _a.expanded) || setState((s_3) => {
          const itemState_2 = s_3[focusedKey];
          return itemState_2 ? {
            ...s_3,
            [focusedKey]: {
              ...itemState_2,
              expanded: true
            }
          } : s_3;
        });
        return;
      }
    }
  }, $2[21] = itemElements, $2[22] = t15) : t15 = $2[22];
  const handleKeyDown = t15;
  let t16;
  $2[23] !== onFocus ? (t16 = (event_0) => {
    setFocusedElement(event_0.target), onFocus == null ? void 0 : onFocus(event_0);
  }, $2[23] = onFocus, $2[24] = t16) : t16 = $2[24];
  const handleFocus = t16;
  let t17;
  $2[25] === Symbol.for("react.memo_cache_sentinel") ? (t17 = () => {
    if (!ref.current)
      return;
    const _itemElements = Array.from(ref.current.querySelectorAll('[data-ui="TreeItem"]'));
    setItemElements(_itemElements);
  }, $2[25] = t17) : t17 = $2[25];
  let t18;
  $2[26] !== children ? (t18 = [children], $2[26] = children, $2[27] = t18) : t18 = $2[27], (0, import_react53.useEffect)(t17, t18);
  let t19;
  $2[28] !== children || $2[29] !== handleFocus || $2[30] !== handleKeyDown || $2[31] !== restProps || $2[32] !== space ? (t19 = (0, import_jsx_runtime13.jsx)(Stack, { as: "ul", "data-ui": "Tree", ...restProps, onFocus: handleFocus, onKeyDown: handleKeyDown, ref, role: "tree", space, children }), $2[28] = children, $2[29] = handleFocus, $2[30] = handleKeyDown, $2[31] = restProps, $2[32] = space, $2[33] = t19) : t19 = $2[33];
  let t20;
  return $2[34] !== contextValue || $2[35] !== t19 ? (t20 = (0, import_jsx_runtime13.jsx)(TreeContext.Provider, { value: contextValue, children: t19 }), $2[34] = contextValue, $2[35] = t19, $2[36] = t20) : t20 = $2[36], t20;
}));
Tree.displayName = "Memo(ForwardRef(Tree))";
function treeItemRootStyle() {
  return lt`
    &[role='none'] > [role='treeitem'] {
      outline: none;
      cursor: default;
      border-radius: 3px;

      background-color: var(--card-bg-color);
      color: var(--treeitem-fg-color);

      &:focus {
        position: relative;
      }
    }

    &[role='treeitem'] {
      outline: none;

      & > div {
        cursor: default;
        border-radius: 3px;

        background-color: var(--card-bg-color);
        color: var(--treeitem-fg-color);
      }

      &:focus > div {
        position: relative;
      }
    }
  `;
}
function treeItemRootColorStyle(props) {
  const $tone = "default", {
    color: color3
  } = getTheme_v2(props.theme), tone = color3.selectable[$tone];
  return lt`
    &[role='none'] {
      & > [role='treeitem'] {
        ${_cardColorStyle(color3, tone.enabled)}
      }

      &[data-selected] > [role='treeitem'] {
        ${_cardColorStyle(color3, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {
          ${_cardColorStyle(color3, tone.hovered)}
        }

        & > [role='treeitem']:focus {
          ${_cardColorStyle(color3, tone.selected)}
        }
      }
    }

    &[role='treeitem'] {
      & > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color3, tone.enabled)}
      }

      &[data-selected] > [data-ui='TreeItem__box'] {
        ${_cardColorStyle(color3, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {
          ${_cardColorStyle(color3, tone.hovered)}
        }

        &:focus > [data-ui='TreeItem__box'] {
          ${_cardColorStyle(color3, tone.selected)}
        }
      }
    }
  `;
}
function treeItemBoxStyle(props) {
  const {
    $level
  } = props, {
    space
  } = getTheme_v2(props.theme);
  return lt`
    padding-left: ${rem(space[2] * $level)};

    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function useTree() {
  const tree = (0, import_react53.useContext)(TreeContext);
  if (!tree)
    throw new Error("Tree: missing context value");
  return tree;
}
var TreeGroup = (0, import_react53.memo)(function(props) {
  const $2 = (0, import_react_compiler_runtime2.c)(9);
  let children, restProps, t0;
  $2[0] !== props ? ({
    children,
    expanded: t0,
    ...restProps
  } = props, $2[0] = props, $2[1] = children, $2[2] = restProps, $2[3] = t0) : (children = $2[1], restProps = $2[2], t0 = $2[3]);
  const expanded = t0 === void 0 ? false : t0, tree = useTree(), t1 = !expanded;
  let t2;
  return $2[4] !== children || $2[5] !== restProps || $2[6] !== t1 || $2[7] !== tree.space ? (t2 = (0, import_jsx_runtime13.jsx)(Stack, { as: "ul", "data-ui": "TreeGroup", ...restProps, hidden: t1, marginTop: tree.space, role: "group", space: tree.space, children }), $2[4] = children, $2[5] = restProps, $2[6] = t1, $2[7] = tree.space, $2[8] = t2) : t2 = $2[8], t2;
});
var StyledTreeItem = (0, import_react53.memo)(dt.li.withConfig({
  displayName: "StyledTreeItem",
  componentId: "sc-iiskig-0"
})(treeItemRootStyle, treeItemRootColorStyle));
var TreeItemBox = dt(Box).attrs({
  forwardedAs: "a"
}).withConfig({
  displayName: "TreeItemBox",
  componentId: "sc-iiskig-1"
})(treeItemBoxStyle);
var ToggleArrowText = dt(Text).withConfig({
  displayName: "ToggleArrowText",
  componentId: "sc-iiskig-2"
})`& > svg{transition:transform 100ms;}`;
var TreeItem = (0, import_react53.memo)(function(props) {
  const {
    children,
    expanded: expandedProp = false,
    fontSize: fontSize2 = 1,
    href,
    icon: IconComponent,
    id: idProp,
    linkAs,
    muted,
    onClick,
    padding = 2,
    selected = false,
    space = 2,
    text,
    weight,
    ...restProps
  } = props, rootRef = (0, import_react53.useRef)(null), treeitemRef = (0, import_react53.useRef)(null), tree = useTree(), {
    path,
    registerItem,
    setExpanded,
    setFocusedElement
  } = tree, _id = (0, import_react53.useId)(), id3 = idProp || _id, itemPath = (0, import_react53.useMemo)(() => path.concat([id3 || ""]), [id3, path]), itemKey = itemPath.join("/"), itemState = tree.state[itemKey], focused = tree.focusedElement === rootRef.current, expanded = (itemState == null ? void 0 : itemState.expanded) === void 0 ? expandedProp : (itemState == null ? void 0 : itemState.expanded) || false, tabIndex = tree.focusedElement && tree.focusedElement === rootRef.current ? 0 : -1, contextValue = (0, import_react53.useMemo)(() => ({
    ...tree,
    level: tree.level + 1,
    path: itemPath
  }), [itemPath, tree]), handleClick = (0, import_react53.useCallback)((event) => {
    onClick && onClick(event);
    const target = event.target;
    target instanceof HTMLElement && (target.getAttribute("data-ui") === "TreeItem" || target.closest('[data-ui="TreeItem__box"]')) && (event.stopPropagation(), setExpanded(itemKey, !expanded), setFocusedElement(rootRef.current));
  }, [expanded, itemKey, onClick, setExpanded, setFocusedElement]), handleKeyDown = (0, import_react53.useCallback)((event_0) => {
    var _a;
    focused && event_0.key === "Enter" && ((_a = treeitemRef.current || rootRef.current) == null ? void 0 : _a.click());
  }, [focused]);
  (0, import_react53.useEffect)(() => {
    if (rootRef.current)
      return registerItem(rootRef.current, itemPath.join("/"), expanded, selected);
  }, [expanded, itemPath, registerItem, selected]);
  const content2 = (0, import_jsx_runtime13.jsxs)(Flex, { padding, children: [
    (0, import_jsx_runtime13.jsxs)(Box, { marginRight: space, style: {
      visibility: IconComponent || children ? "visible" : "hidden",
      pointerEvents: "none"
    }, children: [
      IconComponent && (0, import_jsx_runtime13.jsx)(Text, { muted, size: fontSize2, weight, children: (0, import_jsx_runtime13.jsx)(IconComponent, {}) }),
      !IconComponent && (0, import_jsx_runtime13.jsx)(ToggleArrowText, { muted, size: fontSize2, weight, children: (0, import_jsx_runtime13.jsx)(ToggleArrowRightIcon, { style: {
        transform: expanded ? "rotate(90deg)" : void 0
      } }) })
    ] }),
    (0, import_jsx_runtime13.jsx)(Box, { flex: 1, children: (0, import_jsx_runtime13.jsx)(Text, { muted, size: fontSize2, textOverflow: "ellipsis", weight, children: text }) })
  ] });
  return href ? (0, import_jsx_runtime13.jsxs)(StyledTreeItem, { "data-selected": selected ? "" : void 0, "data-tree-id": id3, "data-tree-key": itemKey, "data-ui": "TreeItem", ...restProps, onClick: handleClick, ref: rootRef, role: "none", children: [
    (0, import_jsx_runtime13.jsx)(TreeItemBox, { $level: tree.level, "aria-expanded": expanded, as: linkAs, "data-ui": "TreeItem__box", href, ref: treeitemRef, role: "treeitem", tabIndex, children: content2 }),
    (0, import_jsx_runtime13.jsx)(TreeContext.Provider, { value: contextValue, children: children && (0, import_jsx_runtime13.jsx)(TreeGroup, { hidden: !expanded, children }) })
  ] }) : (0, import_jsx_runtime13.jsxs)(StyledTreeItem, { "data-selected": selected ? "" : void 0, "data-ui": "TreeItem", "data-tree-id": id3, "data-tree-key": itemKey, ...restProps, "aria-expanded": expanded, onClick: handleClick, onKeyDown: handleKeyDown, ref: rootRef, role: "treeitem", tabIndex, children: [
    (0, import_jsx_runtime13.jsx)(TreeItemBox, { $level: tree.level, as: "div", "data-ui": "TreeItem__box", children: content2 }),
    (0, import_jsx_runtime13.jsx)(TreeContext.Provider, { value: contextValue, children: children && (0, import_jsx_runtime13.jsx)(TreeGroup, { expanded, children }) })
  ] });
});
TreeItem.displayName = "Memo(TreeItem)";

export {
  COLOR_HUES,
  black,
  white,
  gray,
  blue,
  purple,
  red,
  yellow,
  green,
  hues,
  createColorTheme,
  getTheme_v2,
  multiply,
  screen,
  rgbToHex,
  parseColor,
  rgba,
  buildTheme,
  lt,
  dt,
  ft,
  mt,
  require_react_is,
  AnimatePresence,
  motion,
  ResizeObserver2 as ResizeObserver,
  useEffectEvent,
  rgba3 as rgba2,
  studioTheme,
  isHTMLElement3 as isHTMLElement,
  rem,
  _responsive,
  useArrayProp,
  useClickOutsideEvent,
  useElementSize,
  useGlobalKeyDown,
  ThemeProvider,
  ThemeColorProvider,
  useTheme,
  useMediaIndex,
  usePrefersDark,
  Label,
  Avatar,
  AvatarCounter,
  AvatarStack,
  Box,
  Text,
  Badge,
  Flex,
  Spinner,
  Button,
  Card,
  Checkbox,
  Code,
  Container,
  Grid,
  Heading,
  Inline,
  BoundaryElementProvider,
  useBoundaryElement,
  ElementQuery,
  LayerProvider,
  useLayer,
  Layer,
  usePortal,
  Portal,
  PortalProvider,
  VirtualList,
  Popover,
  Radio,
  Select,
  Stack,
  Switch,
  TextArea,
  TextInput,
  TooltipDelayGroupProvider,
  Tooltip,
  Hotkeys,
  Menu,
  MenuDivider,
  MenuGroup,
  MenuItem,
  Tab,
  TabList,
  focusFirstDescendant,
  focusLastDescendant,
  useElementRect,
  ErrorBoundary,
  Autocomplete,
  Breadcrumbs,
  Dialog,
  DialogProvider,
  MenuButton,
  Skeleton,
  TextSkeleton,
  TabPanel,
  ToastProvider,
  useToast
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
*/
//# sourceMappingURL=chunk-EBTAS26V.js.map
